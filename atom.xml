<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烟花散尽13141</title>
  
  <subtitle>慢慢的学习，慢慢的进步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zxhtom.oschina.io/"/>
  <updated>2018-01-18T13:15:10.050Z</updated>
  <id>https://zxhtom.oschina.io/</id>
  
  <author>
    <name>张新华</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A*寻路解析(源码+图例解析)</title>
    <link href="https://zxhtom.oschina.io/zxh/20180115.html"/>
    <id>https://zxhtom.oschina.io/zxh/20180115.html</id>
    <published>2018-01-15T03:24:00.000Z</published>
    <updated>2018-01-18T13:15:10.050Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>A*算法，A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法。算法中的距离估算值与实际值越接近，最终搜索速度越快。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>首先在大学我们遇到最多的算法Dijkstra、Floyd、广度搜索、深度搜索。关于这些算法我们以后再慢慢的研究，今天的重点在A*算法上。A*算法是一种启发式算法。与上述几种算法不同的是A*算法在考虑起始节点的同时还会考虑到目标节点的代价。</li><li>在A*算法中我们给每个节点都定义一些属性。最基本的就是下文提到的三基数-这里的三基数是我自己定义的一个名词。什么叫启发式就是在探索路径的时候既要选择里起始点最近也要考虑到里目标节点的消费问题。</li></ul><h2 id="三基值"><a href="#三基值" class="headerlink" title="三基值"></a>三基值</h2><ul><li>上面的一些概念可能会使你很模糊，这里我们直接看定义。</li></ul><p>&gt;<br> F=G+H  : 表示一个节点的总消费值；换句话说就是离起始节点和目标节点距离的总和<br> G      : 表示该从其实节点到该节点的消费值；<br> H      : 表示从该节点到目标节点的消费值；(这里注意一下，这里的消费值其实是一个预估值，因为我们无法判断到目标节点的具体路径，这个H值得获取本文会提供三种方法，其中使用最广泛的是曼哈顿距离)</p><ul><li><p><img src="http://oytmxyuek.bkt.clouddn.com/20171228_1.png" alt="三基数定义">图1</p></li></ul><h2 id="三基值计算"><a href="#三基值计算" class="headerlink" title="三基值计算"></a>三基值计算</h2><h3 id="常规约定"><a href="#常规约定" class="headerlink" title="常规约定"></a>常规约定</h3><ul><li>在方格地图中我们约定横向或者纵向单位消费为10</li><li>在方格地图中斜向单位消费为14</li><li>在墙（墙、河流等不可经过的节点统称）角我们是不可以斜着穿越的，这是常识。实际中我们每个移动的物体都是有自己的空间的，如下图这样S–&gt;E的过程S’已经占用了Q（墙）的领域了。</li><li><p><img src="http://oytmxyuek.bkt.clouddn.com/20171228_zxh003.png" alt="墙角不可斜穿解释">图2</p></li></ul><ul><li>在非墙角地方根据自己需求可以设定可穿越，也可以设定不可穿越。本文设定是可穿越的。</li></ul><p>  <img src="http://oytmxyuek.bkt.clouddn.com/20171228_zxh002.png" alt="基本常识定义">图3</p><h3 id="G值计算"><a href="#G值计算" class="headerlink" title="G值计算"></a>G值计算</h3><ul><li>三基数在上面定义中我们已经列出了其计算公式，可能有的人看的不是很明白。我们这里详细解释一下</li><li>首先我们先看三基值中的G值，G<code>表示该从其实节点到该节点的消费值</code>，这句话的意思从开始节点移动到当前节点需要的实际的消费，这里是需要考虑到不可经过的节点的。如下图S表示起始点，E表示目标节点,N表示当前节点，黑色的表示墙(不可经过的节点集合)。我们规定在墙角是无法斜着穿过去，在其他地方是可以斜着经过的。有了这个约定，我们可以算出图3中<ul><li>S—&gt;N<sub>1</sub> 消费10，</li><li>S—&gt;N<sub>2</sub>消费14，因为从S到N<sub>2</sub>不是处于墙角。</li><li>途中N<sub>3</sub>—&gt;N<sub>4</sub>就是明显的墙角。所以N<sub>3</sub>—&gt;N<sub>4</sub>消费是20。</li></ul></li></ul><h3 id="H值计算方式"><a href="#H值计算方式" class="headerlink" title="H值计算方式"></a>H值计算方式</h3><ul><li>H值和G值作用相反，H值是预估到目标节点的消费值。<ul><li>首先G是针对其实点的，而H值是针对目标节点的</li><li>其次G值是真实值，而H值是预估值</li><li>最后G值得计算是允许斜线行走的，但是H值计算只能横向和纵向的结合</li></ul></li><li>下图(图4中从N<sub>2</sub>—&gt;E点的H=40+10),其中40部分已经穿墙了。这里因为是预估值所以不考虑墙的存在。到这里我们基本的定义已经结束了</li></ul><p>  <img src="http://oytmxyuek.bkt.clouddn.com/20171228_zxh004.png" alt="H值计算">图4</p><h2 id="集合列表"><a href="#集合列表" class="headerlink" title="集合列表"></a>集合列表</h2><ul><li>在我们A*寻路的过程中，我们需要用到两个集合，一个我们成为开放集合(OpenList),另外一个我们称之为闭合集合(ClosedList)。</li><li>举个例子我们去超市购物，我们都会推个手推车，把喜欢的东西放进购物车里。最后结算的时候或者是中途我们会选择价格更实惠的东西替代我们已经选择的同等产品</li><li>在A*中我们也是这样，openList就相当于购物车，我们会将见到的喜欢的物品加入购物车，但是加入购物车并不一定最后会买，在A*中，我们会将节点周围可用的节点加入openList，但是并不一定最后需要。在openList添加的过程我们会慢慢用’更实惠’的节点代替已经选择的相同的节点。在超市最后放到我们自己的包里才是最后我们要带回家的东西。在A*算法中加到closedList中才是我们最后的东西。</li></ul><h1 id="寻路解析"><a href="#寻路解析" class="headerlink" title="寻路解析"></a>寻路解析</h1><blockquote><p><sup>本小节图片来源以下文章。其中思想参考源以下文章</sup></p><ul><li><a href="http://blog.csdn.net/zgwangbo/article/details/52078338" target="_blank" rel="noopener">http://blog.csdn.net/zgwangbo/article/details/52078338</a></li><li><a href="http://blog.csdn.net/hitwhylz/article/details/23089415" target="_blank" rel="noopener">http://blog.csdn.net/hitwhylz/article/details/23089415</a></li></ul></blockquote><ul><li>经过上面的介绍我们了解了A*中我们一些约定的定义，理解上面这些定义的基础上我们下面的流程会很易懂。</li></ul><h2 id="初始地图"><a href="#初始地图" class="headerlink" title="初始地图"></a>初始地图</h2><ul><li>如图5,地图上蓝色方格表示墙，关于墙的定义上面已经解释过了。左边青色的表示S(起始节点)，右边的红色节点表示我们的目标节点。小圆点表示从S到E的最有路径之一。从图5我们可以看出我们在墙角没有斜走，而在其他路段上我们选择斜着走了。下面介绍节点就以图5中的坐标为准。比如起始节点我们就称之为(2,3)。<ul><li>蓝色方格表示不可经过方格</li><li>青色的边框的方格表示已经加入openList</li><li>高亮显示的边框表示添加在closedList</li><li>青色表示其实节点</li><li>红色表示目标节点</li><li><img src="http://oytmxyuek.bkt.clouddn.com/20171228_introduce.png" alt="图介绍"></li></ul></li></ul><p>  <img src="http://oytmxyuek.bkt.clouddn.com/20171228_zxh007.png" alt="地图上初始的两个点"></p><h2 id="递归寻走"><a href="#递归寻走" class="headerlink" title="递归寻走"></a>递归寻走</h2><ul><li>首先我们常规的寻路是不可能出现首尾相同的情况。但是项目中得处理这种情况，如果其实节点和目标节点是地图上的统一节点，那么我们的路径就是当前节点。</li><li>选择当前节点周围可用的节点，如果不在openList集合中则分别计算三基数的值并且加入到openList集合中,计算三基数的同事将待加入openList的节点的父节点设置为当前节点。</li><li>如果已经存在openList集合中且结合中的G值大于当前节点(周围节点之一)的G值，则将当前节点更新到openList集合中。否则不加入也不更新。</li><li>周围节点选择完之后我们就把该节点(起始节点)加入closedList中，然后从openList中选择F值最小的节点，在继续重复上面三步骤。</li></ul><h3 id="图示流程"><a href="#图示流程" class="headerlink" title="图示流程"></a>图示流程</h3><ul><li>按照图5中我们可以获得起始节点(2,3)的周围节点列表如图6。并逐个分析是否该加入openList中。</li></ul><p>  <img src="http://oytmxyuek.bkt.clouddn.com/20171228_image002.jpg" alt="周围节点图示"> 图6</p><ul><li>通过比较我们发现目前周围的八个节点全部有效且全不在openList中，那么我们就全部加入并计算三基数的值，并设置他们的父节点为(2,3)。如图7</li></ul><p>  <img src="http://oytmxyuek.bkt.clouddn.com/20171228_image003.jpg" alt="周围节点三基数展示"> 图7</p><ul><li>从图7中我们可以看出在起始节点(2,3)周围(3,3)这个节点的F值此时在openList中最小，所以此时我们将(2,3)移除openList并将(2,3)加入到closedList中。此时(2,3)由高亮方格显示表示加入closedList集合，</li><li>(2,3)节点就算是结束了他的使命了，加入了closedList集合中的节点我们将不会再去考虑，我们可以认为加入到closedList集合中的点已经成墙了。那么下面我们从openList中选取F值最小(3,3)为新的起始节点，开始重复上面的流程，但是我们发现(3,3)的右上、正右、右下都是墙，还有正左(2,3)在closedList集合中。这四点我们是不用考虑的。那么只剩下<br>(2,2),(3,2),(2,4),(3,4)这四个点。但是这四个点恰巧有全部在openList中。依照上面的流程我们得以此比较这四个点和openList集合中对应的点的G值谁大谁小。就一个原则<font color="red">谁小留谁</font>。由图8我们可以知道，新获得的这四个点的G值均大于openlist里对应的点的G值，所以我们这里放弃这四个点。他们没有被我们喜欢，我们抛弃这些点。这一轮结束我们将(3,3)加入到closedList集合中。如果新节点G值小于对应的openList中的点的G值得话，我们就要更新openList集合中的对应的那个点。所谓的更新就是将新节点替换原来那个节点。<font color="red">注意此时新节点和openList对应的那个点出了三基数不同，还有父节点也不同了。</font></li><li><p>这里需要解释下为什么新节点的G值都会加10呢，那是因为我们最起始的节点是(2,3)，而此时的起始节点是(3,3),比如我们算(2,2)G值得时候实际上是(2,3)—&gt;(3,3)—&gt;(2,2)整个过程的G值。所以是10+14。</p><p><img src="http://oytmxyuek.bkt.clouddn.com/20171228_new2old.png" alt="新旧节点对比图"> 图8</p></li><li><p>由图9我们能够看到此时我们openList中最小F值应该是(3,4)，下面的步骤就是一直重复。</p><p><img src="http://oytmxyuek.bkt.clouddn.com/20171228_last.png" alt="最后流程"> 图9</p></li><li><p>直到我们的目标节点成为起始节点就表示循环结束，这个时候我们通过我们的目标节点在closedlist总通过父节点就能反向回去获得整条路径了。</p></li></ul><h1 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h1><ul><li>关键在于估价函数h(n)的选取：估价值h(n)&lt;= n到目标节点的距离实际值，这种情况下，搜索的点数多，搜索范围大，效率低。但能得到最优解。并且如果h(n)=d(n)，即距离估计h(n)等于最短距离，那么搜索将严格沿着最短路径进行， 此时的搜索效率是最高的。如果 估价值&gt;实际值,搜索的点数少，搜索范围小，效率高，但不能保证得到最优解</li></ul><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><font size="6"><a href="https://gitee.com/zxhGroup/Algorithm.git" target="_blank" rel="noopener">源码下载点我</a></font> <p><em>[//]: A</em>译文： <a href="http://blog.csdn.net/coutamg/article/details/53923717" target="_blank" rel="noopener">http://blog.csdn.net/coutamg/article/details/53923717</a><br><em>[//]:其他最小路径算法：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html</a></em>[//]:启发式算法：<a href="https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;A*算法，A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法。算法中的距离估算值与实际值越接近，最终搜索速度越快。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
      <category term="算法" scheme="https://zxhtom.oschina.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java String类中formatter给我们的好处</title>
    <link href="https://zxhtom.oschina.io/zxh/20180105.html"/>
    <id>https://zxhtom.oschina.io/zxh/20180105.html</id>
    <published>2018-01-05T10:00:30.000Z</published>
    <updated>2018-01-18T13:15:10.058Z</updated>
    
    <content type="html"><![CDATA[<p>javaweb开发中我们经常需要对结果进行格式化整理。有的时候我们需要按照一定的格式返回数据给前台才能达到我们预定的效果。java string类中给我们提供的格式化(format)的方法。</p><a id="more"></a><h1 id="格式化标准"><a href="#格式化标准" class="headerlink" title="格式化标准"></a>格式化标准</h1><pre><code class="java">// %[argument_index$][flags][width][.precision][t]conversionprivate static final String formatSpecifier        = &quot;%(\\d+\\$)?([-#+ 0,(\\&lt;]*)?(\\d+)?(\\.\\d+)?([tT])?([a-zA-Z%])&quot;;</code></pre><ul><li>查看jdk源码我们可以看到，源码是通过正则表达式捕获我们的格式化语句。我们格式化语句(下文称为<font color="red">占位符</font>)完整格式即为这个正则表达式所匹配的。换句话说就是上面注释部分的格式</li><li><p>完整占位符：</p><font color="green" size="4"><br><code>java %[argument_index$][flags][width][.precision][t]conversion</code><br></font></li><li><p>通过formatSpecifier我们可以看出占位符可以不按照标准占位符来。最简便的一种占位符<code>%（[a-zA-Z]）</code>,所以针对不同数据类型的格式化，占位符的格式将有所裁剪。其中.precision这个占位符是针对浮点数转换类型而言的。其他转换类型不能使用该占位符。否则会报<code>java.util.IllegalFormatPrecisionException</code>错(非法精度)。</p><ul><li><p>%   ， 占位符开始的符号(同时也是占位符中的转义字符)。</p></li><li><p>[argument_index$] ，位置索引从1开始计算，用于指定对索引相应的实参进行格式化并替换掉该占位符。</p></li><li><p>[flags] ，用于增强格式化能力，可同时使用多个 [flags] ，但某些标识是不能同时使用的。</p></li><li><p>[width] ，用于设置格式化后的字符串最小长度，若使用 [最小宽度] 而无设置 [标识] ，那么当字符串长度小于最小宽度时，则以左边补空格的方式凑够最小宽度。</p></li><li><p>[•precision] ，对于浮点数类型格式化使用，设置保留小数点后多少位。</p></li><li><p>[t]  , 时间格式</p></li><li><p>conversion ，用于指定格式化的样式，和限制对应入参的数据类型。</p></li></ul></li></ul><h1 id="格式化整数"><a href="#格式化整数" class="headerlink" title="格式化整数"></a>格式化整数</h1><pre><code>%[argument_index$][flags][width]conversion</code></pre><ul><li>这里的占位符和上述的标准占位符一样。唯一需要解释的就是flags(可用标识)和conversion(转换类型)。</li><li>flags:<ul><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">-</font>    :在最小宽度内左对齐,不可以与0标识一起使用。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">0</font>    :若内容长度不足最小宽度，则在左边用0来填充。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">#</font>   :对8进制和16进制，8进制前添加一个0,16进制前添加0x。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">+</font>    :结果总包含一个+或-号。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">空格</font> :正数前加空格，负数前加-号。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">,</font>    :只用与十进制，每3位数字间用,分隔。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">(</font>    :若结果为负数，则用括号括住，且不显示符号。</li></ul></li><li>conversion:<ul><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">d</font>        :十进制   </li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">o</font>        :八进制   </li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">x或X</font>     :十六进制</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">n</font>     :平台独立的换行符, 也可通过System.getProperty(“line.separator”)获取。 <code>String.format(&quot;%n&quot;,&quot;234&quot;)</code>，实际就是一个换行符</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">b</font>     :布尔类型，只要实参为非false的布尔类型，均格式化为字符串true，否则为字符串false。</li></ul></li><li><p>examples: 其中 十进制、八进制、十六进制都是整数可以互相使用，只有#适合八进制或者十六进制</p><pre><code class="java">    System.out.println(&quot;实现左对齐：&quot;);    System.out.println(String.format(&quot;%1$-9d&quot;, 1245));    System.out.println(&quot;实现用0填充：&quot;);    System.out.println(String.format(&quot;%1$09d&quot;, 1245));    System.out.println(&quot;实现用+/-填充：&quot;);    System.out.println(String.format(&quot;%1$+9d&quot;, 1245));    System.out.println(&quot;实现用空格填充：&quot;);    System.out.println(String.format(&quot;%1$ 9d&quot;, 1245));    System.out.println(String.format(&quot;%1$ 9d&quot;, -1245));    System.out.println(&quot;实现用,填充：&quot;);    System.out.println(String.format(&quot;%1$,9d&quot;, 1245));    System.out.println(&quot;实现用(填充：&quot;);    System.out.println(String.format(&quot;%1$(9d&quot;, -1245));    System.out.println(&quot;实现结合使用：&quot;);    System.out.println(String.format(&quot;%1$0(9d&quot;, -1245));</code></pre><p>  <img src="http://oytmxyuek.bkt.clouddn.com/20180105_001.png" alt="结果"></p></li></ul><h1 id="格式化浮点数"><a href="#格式化浮点数" class="headerlink" title="格式化浮点数"></a>格式化浮点数</h1><pre><code>%[argument_index$][flags][width][.precision]conversion</code></pre><ul><li>这里的占位符和上述的标准占位符一样。唯一需要解释的就是flags(可用标识)和conversion(转换类型)。</li><li>flags:<ul><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">-</font>    :在最小宽度内左对齐,不可以与0标识一起使用。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">0</font>    :若内容长度不足最小宽度，则在左边用0来填充。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">+</font>    :结果总包含一个+或-号。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">空格</font> :正数前加空格，负数前加-号。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">,</font>    :只用与十进制，每3位数字间用,分隔。</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">(</font>    :若结果为负数，则用括号括住，且不显示符号。</li></ul></li><li>conversion:<ul><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">e或E</font>  :结果被格式化为用计算机科学记数法表示的十进制数   </li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">f</font>     :结果被格式化为十进制普通表示方式   </li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">g或G</font>  :根据具体情况，自动选择用普通表示方式还是科学计数法方式，</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">a或A</font>  :结果被格式化为带有效位数和指数的十六进制浮点数</li></ul></li><li>notes:<ul><li>在浮点数中，如果精度(precision)没有指定的情况下，默认精度(precision)为6</li><li>conversion=e,保留小数点后<code>precision</code>位</li><li>conversion=f,保留小数点后<code>precision</code>位</li><li>conversion=g,保留<code>precision</code>位有效数字</li><li>conversion=a,保留小数点后<code>precision</code>位</li></ul></li><li><p>examples: </p><pre><code class="java">    System.out.println(String.format(&quot;%20.9a&quot;, 1223d));    System.out.println(String.format(&quot;%20.9e&quot;, 1223d));    System.out.println(String.format(&quot;%20.9f&quot;, 1223d));    System.out.println(String.format(&quot;%20.9g&quot;, 12123d));</code></pre><p><img src="http://oytmxyuek.bkt.clouddn.com/20180105_002.png" alt="效果"></p></li></ul><h1 id="格式化字符"><a href="#格式化字符" class="headerlink" title="格式化字符"></a>格式化字符</h1><pre><code>%[argument_index$][flags][width]conversion</code></pre><ul><li>flags:<ul><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">-</font>    :在最小宽度内左对齐,不可以与0标识一起使用。</li></ul></li><li>conversion<ul><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">s</font>    ：字符串</li><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">c</font>    :字符类型，实参必须为char或int、short等可转换为char类型的数据类型，否则抛IllegalFormatConversionException异常。</li></ul></li></ul><h1 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h1><pre><code>%[argument_index$][flags][width]conversion</code></pre><ul><li>flags:<ul><li><font color="blue" size="4" style="font-weight:bold;font-style:italic;">-</font>    :在最小宽度内左对齐,不可以与0标识一起使用。</li></ul></li><li><p>conversion:<br><font color="red">以下转换字符用来格式化时间</font>：<br>‘H’     24 小时制的小时，被格式化为必要时带前导零的两位数，即 00 - 23。<br>‘I’     12 小时制的小时，被格式化为必要时带前导零的两位数，即 01 - 12。<br>‘k’     24 小时制的小时，即 0 - 23。<br>‘l’     12 小时制的小时，即 1 - 12。<br>‘M’     小时中的分钟，被格式化为必要时带前导零的两位数，即 00 - 59。<br>‘S’     分钟中的秒，被格式化为必要时带前导零的两位数，即 00 - 60 （”60” 是支持闰秒所需的一个特殊值）。<br>‘L’     秒中的毫秒，被格式化为必要时带前导零的三位数，即 000 - 999。<br>‘N’     秒中的毫微秒，被格式化为必要时带前导零的九位数，即 000000000 - 999999999。<br>‘p’     特定于语言环境的 上午或下午 标记以小写形式表示，例如 “am” 或 “pm”。使用转换前缀 ‘T’ 可以强行将此输出转换为大写形式。<br>‘z’     相对于 GMT 的 RFC 822 格式的数字时区偏移量，例如 -0800。<br>‘Z’     表示时区缩写形式的字符串。Formatter 的语言环境将取代参数的语言环境（如果有）。<br>‘s’     自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的秒数，即 Long.MIN_VALUE/1000 与 Long.MAX_VALUE/1000 之间的差值。<br>‘Q’     自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的毫秒数，即 Long.MIN_VALUE 与 Long.MAX_VALUE 之间的差值。</p><p><font color="red">以下转换字符用来格式化日期</font>：<br>‘B’     特定于语言环境的月份全称，例如 “January” 和 “February”。<br>‘b’     特定于语言环境的月份简称，例如 “Jan” 和 “Feb”。<br>‘h’     与 ‘b’ 相同。<br>‘A’     特定于语言环境的星期几全称，例如 “Sunday” 和 “Monday”<br>‘a’     特定于语言环境的星期几简称，例如 “Sun” 和 “Mon”<br>‘C’     除以 100 的四位数表示的年份，被格式化为必要时带前导零的两位数，即 00 - 99<br>‘Y’     年份，被格式化为必要时带前导零的四位数（至少），例如，0092 等于格里高利历的 92 CE。<br>‘y’     年份的最后两位数，被格式化为必要时带前导零的两位数，即 00 - 99。<br>‘j’     一年中的天数，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 001 - 366。<br>‘m’     月份，被格式化为必要时带前导零的两位数，即 01 - 13。<br>‘d’     一个月中的天数，被格式化为必要时带前导零两位数，即 01 - 31<br>‘e’     一个月中的天数，被格式化为两位数，即 1 - 31。</p><p><font color="red">式化常见的日期/时间组合。</font>:<br>‘R’     24 小时制的时间，被格式化为 “%tH:%tM”<br>‘T’     24 小时制的时间，被格式化为 “%tH:%tM:%tS”。<br>‘r’     12 小时制的时间，被格式化为 “%tI:%tM:%tS %Tp”。上午或下午标记 (‘%Tp’) 的位置可能与语言环境有关。<br>‘D’     日期，被格式化为 “%tm/%td/%ty”。<br>‘F’     ISO 8601 格式的完整日期，被格式化为 “%tY-%tm-%td”。<br>‘c’     日期和时间，被格式化为 “%ta %tb %td %tT %tZ %tY”，例如 “Sun Jul 20 16:17:00 EDT 1969”。</p></li></ul><h1 id="格式化百分数"><a href="#格式化百分数" class="headerlink" title="格式化百分数"></a>格式化百分数</h1><pre><code>%[argument_index$][flags][width]conversion</code></pre><ul><li><p>这里百分数其实就是我们一个固定格式，这里需要注意的是%是占位符的开始符号，所以我们用%需要用%%来表达原来的意思</p><p><code>System.out.println(String.format(&quot;%1$02d%%&quot;, 30));</code>这个就是输出30%。</p></li></ul><h1 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h1><p>  <font size="4">转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <font color="#e67e22">烟花散尽13141</font></font></p><blockquote><p><sup>以上参考：<br>    <a href="https://www.cnblogs.com/xytop/articles/1277125.html" target="_blank" rel="noopener">https://www.cnblogs.com/xytop/articles/1277125.html</a><br>    <a href="https://www.cnblogs.com/fsjohnhuang/p/4094777.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsjohnhuang/p/4094777.html</a><br>  </sup><br><img src="http://oytmxyuek.bkt.clouddn.com/20180105_theme.jpg" alt="主题"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javaweb开发中我们经常需要对结果进行格式化整理。有的时候我们需要按照一定的格式返回数据给前台才能达到我们预定的效果。java string类中给我们提供的格式化(format)的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
      <category term="formatter" scheme="https://zxhtom.oschina.io/tags/formatter/"/>
    
  </entry>
  
  <entry>
    <title>mybatis关联</title>
    <link href="https://zxhtom.oschina.io/zxh/20171218.html"/>
    <id>https://zxhtom.oschina.io/zxh/20171218.html</id>
    <published>2017-12-18T10:00:30.000Z</published>
    <updated>2018-01-18T13:15:10.090Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>web项目开发中目前很多企业都是在SSM框架基础上开发。其中的M指的的mybatis(ibatis).mybatis里指的一说的是规避了传统的jdbc等的繁琐。在mybatis中我们可以只用关注sql本身。而不用太在意之个执行过程。大大简化了我们平时的开发。mybatis深究的话会有很多要说的。今天我们只来看看mybatis中提供了映射中的关联标签。</p><a id="more"></a><h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>下表stage_order中的stage_list是有stage表中ID组成的一个字符串，之间由逗号相隔。比如stage_list=1,2,3表示该stage_order中关联着ID为1或2或3的stage。我们得分别取查询stageID=1或2或3的stage进行实体映射展示。下一节我们看看实体的构造</p><p><img src="http://oytmxyuek.bkt.clouddn.com/20171218_1.png" alt="表结构"></p><h2 id="实体准备"><a href="#实体准备" class="headerlink" title="实体准备"></a>实体准备</h2><h3 id="基本实体-对应stage-order单表"><a href="#基本实体-对应stage-order单表" class="headerlink" title="基本实体(对应stage_order单表)"></a>基本实体(对应stage_order单表)</h3><ul><li>在下面的实体中出现的注解我们不需要在意，这是swagger框架的注解，在本章节中不需要理解。换句话说我们可以吧注解删掉。不会影响我们的功能的。</li></ul><pre><code>@ApiModel(description = &quot;阶段顺序表&quot;)@Table(name = &quot;STAGE_ORDER&quot;)public class StageOrder {    @Id    @ApiModelProperty(&quot;阶段顺序ID&quot;)    @NotNull(message = &quot;阶段顺序ID不可为空(NULL)&quot;)    private Long stageOrderId;    @ApiModelProperty(&quot;路口编号&quot;)    @NotNull(message = &quot;路口编号不可为空(NULL)&quot;)    private Long intersectionId;    @ApiModelProperty(&quot;相序名称&quot;)    @NotBlank(message = &quot;相序名称不可为空白&quot;)    @ByteLength(max = 30, message = &quot;相序名称长度不能超过{max}&quot;)    private String orderName;    @ApiModelProperty(&quot;阶段列表&quot;)    @NotBlank(message = &quot;阶段列表不可为空白&quot;)    @ByteLength(max = 200, message = &quot;阶段列表长度不能超过{max}&quot;)    private String stageList;    public Long getStageOrderId() {        return stageOrderId;    }    public void setStageOrderId(Long stageOrderId) {        this.stageOrderId = stageOrderId;    }    public Long getIntersectionId() {        return intersectionId;    }    public void setIntersectionId(Long intersectionId) {        this.intersectionId = intersectionId;    }    public String getOrderName() {        return orderName;    }    public void setOrderName(String orderName) {        this.orderName = orderName == null ? null : orderName.trim();    }    public String getStageList() {        return stageList;    }    public void setStageList(String stageList) {        this.stageList = stageList == null ? null : stageList.trim();    }}</code></pre><h3 id="扩展实体"><a href="#扩展实体" class="headerlink" title="扩展实体"></a>扩展实体</h3><pre><code>public class StageOrderDto extends StageOrder {    /**     * 相位列表     */    private List&lt;Stage&gt; stageInfoList;    public List&lt;Stage&gt; getStageInfoList() {        return stageInfoList;    }    public void setStageInfoList(List&lt;Stage&gt; stageInfoList) {        this.stageInfoList = stageInfoList;    }}</code></pre><h1 id="基本映射"><a href="#基本映射" class="headerlink" title="基本映射"></a><span id="baseMapped">基本映射</span></h1><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><ul><li>有了上面的实体和对应的Table，那么我们如何在mybatis中将Table和实体关联呢。看如下在mapper.xml中的配置</li></ul><pre><code>&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.jsits.xk.dto.StageOrderDto&quot;&gt;    &lt;id column=&quot;STAGE_ORDER_ID&quot; jdbcType=&quot;NUMERIC&quot; property=&quot;stageOrderId&quot;/&gt;    &lt;result column=&quot;INTERSECTION_ID&quot; jdbcType=&quot;NUMERIC&quot; property=&quot;intersectionId&quot;/&gt;    &lt;result column=&quot;ORDER_NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderName&quot;/&gt;    &lt;result column=&quot;STAGE_LIST&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;stageList&quot;/&gt;    &lt;association column=&quot;STAGE_LIST&quot; property=&quot;stageInfoList&quot; select=&quot;selectStageInfos&quot;/&gt;&lt;/resultMap&gt;</code></pre><ul><li><p>但是我们会发现resultMap中stageInfoList这个在跟数据库怎么对应呢？还有association是什么？assocaition中select又是什么？为什么assocaition中的column和上面一样？<br>我想对于刚接触的朋友来说心里一定会有这些疑问。</p></li><li><p>上面已经说了resultmap是用来衔接实体去数据库表的桥梁。resultMap中ID属性就是一个唯一性的作用。一般只需要在当前xml中唯一就行了。因为在每个xml中有<code>namespace</code>,来确定当前的mapper.xml的唯一性。</p><p><img src="http://oytmxyuek.bkt.clouddn.com/20171218_2.png" alt="mapper文件的唯一性确定"></p></li><li><p>resultMap字标签id 和result都是用来映射单列值到type对应的实体或者map中属性。在使用上ID是对应数据库中主键使用的。数据库中会有联合主键，在resultMap中就用两个ID标签对应就行了。还有一点ID也是用来做唯一标识的。当和其他对象进行比较的时候这个时候ID就有作用了。这里和数据库一样主键就是代表一条数据。这里也是同样的作用。在mybatis中有缓存机制。就是通过这个ID实现的。比如mybatis这个时候需要缓存这个对象。则以ID为key ，对象的json化为值存储到缓存中。</p></li></ul><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><ul><li><p>这里一对多就用到了上面的BaseResultMap这个resultMap了。上面我们的讲的ID和result就是我们平时简单单表查询中的一对一关系处理。但是association就是用来关联查询的。association中文翻译就是联想的意思。在mybatis中association的作用就是在查询到STAGE_LIST这个字段的时候默认会将STAGE_LIST的值传到selectStageInfos这个查询语句中查询。传递进去是按照上面的写法我们不能用#{stage_list}取，得通过#{id}获取。这里是默认的必须用#{id}.但是一个健全的框架不会这么死板的。下面我们在介绍如何动态传递。</p></li><li><p>association严格上来说应该是用于selectStageInfos查询获取的也是一个基本类型数据。但是在我们上面的需求描述中我们知道STAGE_LIST,对应到stage表中其实回事多条数据。所以我们在StageOrderDto中stageInfoList也是用list集合来承载的。这个时候用association不会出错。mybatis底层却不同，底层实际上是转换成了collection标签来实现的。应为collection对应的是集合的映射处理。所以追求完美的程序员在级联查询是如果级联出的是集合就用collection标签。但是两种情况用association都是可以的。</p></li></ul><h2 id="查询应用"><a href="#查询应用" class="headerlink" title="查询应用"></a>查询应用</h2><ul><li>说了这么多，下面我们通过两个查询看看查询的实现代码</li></ul><pre><code>    &lt;select id=&quot;selectStageOrderDtoListByIntersectionId&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from stage_order        where INTERSECTION_ID=#{intersectionId}    &lt;/select&gt;    &lt;select id=&quot;selectStageInfos&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.jsits.xk.model.Stage&quot;&gt;        select        &lt;include refid=&quot;Stage_Column_List&quot;/&gt;        from stage        where stage_id in (#{id})    &lt;/select&gt;</code></pre><ul><li>当我们调用selectStageOrderDtoListByIntersectionId通过intersectionId查询到数据的时候，会在通过查询到的STAGE_LIST作为条件调用selectStageInfos这个查询语句的。在selectStageInfos中的#{id}就是selectStageOrderDtoListByIntersectionId查询到的STAGE_LIST。</li></ul><h1 id="复杂映射"><a href="#复杂映射" class="headerlink" title="复杂映射"></a>复杂映射</h1><ul><li>但是我们平时企业开发中光这样的查询有时候并不能满足我们的需求。常见复杂的查询有： 多重级联和联合主键查询</li></ul><h2 id="多重映射"><a href="#多重映射" class="headerlink" title="多重映射"></a>多重映射</h2><ul><li>多重查询说白了就是多用几次级联(association或collection)，对就是这个简单。这个可能有的人没有过甚至没想过。下面贴段实际的代码。因为下面代码在联合主键章节也需要用到。</li></ul><pre><code>&lt;sql id=&quot;Program_Column_List&quot;&gt;        PHASE_LIST,PROGRAM_ID,PROGRAM_NAME,INTERSECTION_ID,STAGE_ID,STAGE_NAME,STAGE_SEQ,GREEN,RED_YELLOW,YELLOW,ALL_RED,MIN_GREEN,MAX_GREEN    &lt;/sql&gt;    &lt;resultMap id=&quot;weekProgramResultMap&quot; type=&quot;com.jsits.xk.dto.WeekPlanProgramDto&quot;&gt;        &lt;result column=&quot;PLAN_ID&quot; property=&quot;planId&quot; /&gt;        &lt;result column=&quot;PLAN_NAME&quot; property=&quot;planName&quot; /&gt;        &lt;association column=&quot;{intersectionId=INTERSECTION_ID,dayPlanNo=PLAN_ID}&quot; property=&quot;dayPlanList&quot; select=&quot;selectDayPlanInfosByPlanNo&quot;/&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;dayPlanResultMap&quot; type=&quot;com.jsits.xk.dto.DayPlanAndProgramListDto&quot;&gt;        &lt;result property=&quot;timeDuration&quot; column=&quot;time_duration&quot; /&gt;        &lt;result property=&quot;programId&quot; column=&quot;program_id&quot; /&gt;        &lt;result property=&quot;stageOrderId&quot; column=&quot;stage_order_id&quot; /&gt;        &lt;result property=&quot;dayPlanId&quot; column=&quot;day_plan_id&quot; /&gt;        &lt;result property=&quot;phaseList&quot; column=&quot;phase_list&quot; /&gt;        &lt;result property=&quot;programName&quot; column=&quot;program_name&quot; /&gt;        &lt;result property=&quot;stageOrderName&quot; column=&quot;order_name&quot; /&gt;        &lt;result property=&quot;controlModeId&quot; column=&quot;control_mode_id&quot; /&gt;        &lt;result property=&quot;controlModeName&quot; column=&quot;control_mode_name&quot; /&gt;        &lt;result property=&quot;cycle&quot; column=&quot;cycle&quot; /&gt;        &lt;association column=&quot;program_id&quot; property=&quot;programList&quot; select=&quot;selectProgramInfosByProgramId&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectProgramInfosByProgramId&quot; parameterType=&quot;long&quot;        resultType=&quot;com.jsits.xk.model.Program&quot;&gt;        select        &lt;include refid=&quot;Program_Column_List&quot; /&gt;        from program where program_id=#{id}    &lt;/select&gt;    &lt;select id=&quot;selectDayPlanInfosByPlanNo&quot; parameterType=&quot;java.util.HashMap&quot; resultMap=&quot;dayPlanResultMap&quot; &gt;        select * from (select        dp.day_plan_id,        trim(REGEXP_REPLACE(to_char(dp.time_duration,&#39;0000&#39;),&#39;([[:digit:]]{2})([[:digit:]]{2})&#39;,&#39;\1:\2&#39;)) as time_duration,        pg.program_id,        pg.program_name,        so.order_name,        so.stage_order_id,        cm.control_mode_id,        cm.control_mode_name,        &#39;120&#39; as cycle        from day_plan dp        left join control_mode cm on dp.control_mode_id=cm.control_mode_id        left join program pg on dp.program_id=pg.program_id        left join stage_order so on dp.stage_order_id=so.stage_order_id        where dp.day_plan_no=#{dayPlanNo}        and dp.intersection_id=#{intersectionId}        )        group by (day_plan_id,time_duration,program_id,program_name,order_name,stage_order_id,control_mode_id,control_mode_name,cycle)        order by time_duration asc    &lt;/select&gt;    &lt;select id=&quot;selectWeekInfosByIntersectionId&quot; parameterType=&quot;long&quot;        resultMap=&quot;weekProgramResultMap&quot;&gt;        select #{intersectionId} as intersection_id,week.plan_name,week.plan_id from        (            select &#39;星期一&#39; as plan_name,intersection_id,monday as plan_id from week_plan            union            select &#39;星期二&#39; as plan_name,intersection_id,tuesday as plan_id from week_plan            union            select &#39;星期三&#39; as plan_name,intersection_id,wendesday as plan_id from week_plan            union            select &#39;星期四&#39; as plan_name,intersection_id,thursday as plan_id from week_plan            union            select &#39;星期五&#39; as plan_name,intersection_id,friday as plan_id from week_plan            union            select &#39;星期六&#39; as plan_name,intersection_id,saturday as plan_id from week_plan            union            select &#39;星期日&#39; as plan_name,intersection_id,sunday as plan_id from week_plan        )week        left join day_plan dp on dp.day_plan_no=week.plan_id        where week.intersection_id=#{intersectionId}        group by week.plan_id,week.plan_name,week.intersection_id        order by week.plan_id    &lt;/select&gt;</code></pre><h2 id="联合主键查询"><a href="#联合主键查询" class="headerlink" title="联合主键查询"></a>联合主键查询</h2><ul><li>在我们很多时候数据库中的主键并不是一个字段，而是通过两个甚至多个字段组合成主键。我们习惯上称之为联合主键。在多重映射中的代码中我们可以看到<code>weekProgramResultMap</code>中级联<code>selectDayPlanInfosByPlanNo</code>这个sql查询。但是有意思的是column中并不是我们熟悉的一个字段。而是通过花括号做首尾，中间加入多个字段组成的一个字符串。这个就是我们本章节引入的概念—联合主键级联查询。column属性值我们分析一下可以看出<code>intersectionId=INTERSECTION_ID</code>和<code>dayPlanNo=PLAN_ID</code>组成的。我们可以看成是两个map，等号前是key等号后是value。key就是我们在新的select中引用的key，及#{key}方式获取。value就是原来的select查询获得的数据。也是通过value来查询新的数据的。这里就解决了我们上面<a href="#baseMapped">基本映射章节</a>说必须用#{id}的局限性。所以在上面中如何我们不想用#{id},那么需要修改column的传入风格{stageId=stage_list}就可以用#{stageId}</li></ul><h1 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h1><p>  工作遇到的需求，mybatis还有很多神操作。以后有机会更新。在mybatis中映射并不是仅仅字段这么简单。还有点逗风格的引用。这些以后看时间在更新。</p><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><h1 id="格言"><a href="#格言" class="headerlink" title="格言"></a>格言</h1><font size="6" color="blue"><br>    人生贵知心，定交无暮早。 —— 袁中道<br></font><p><img src="http://oytmxyuek.bkt.clouddn.com/20171218_theme.jpg" alt="主题图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;web项目开发中目前很多企业都是在SSM框架基础上开发。其中的M指的的mybatis(ibatis).mybatis里指的一说的是规避了传统的jdbc等的繁琐。在mybatis中我们可以只用关注sql本身。而不用太在意之个执行过程。大大简化了我们平时的开发。mybatis深究的话会有很多要说的。今天我们只来看看mybatis中提供了映射中的关联标签。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发工具" scheme="https://zxhtom.oschina.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mybatis" scheme="https://zxhtom.oschina.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透好帮手</title>
    <link href="https://zxhtom.oschina.io/zxh/20171111.html"/>
    <id>https://zxhtom.oschina.io/zxh/20171111.html</id>
    <published>2017-11-11T09:48:30.000Z</published>
    <updated>2018-01-18T13:15:10.067Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]<br>IT程序员经常会用到服务器，但是为了一个功能不值得买一个阿里云服务器，通过ngrok可以实现本地转外网穿透<br><a id="more"></a></p><p><br>作为一个 Web 开发者，我如何让其他非局域网的人可以体验或者协助调试我的网站呢？<br>当我在开发支付宝、微信这类应用时，如何能直接连接到我的本地环境呢？<br>Ngrok 为你提供了一个解决方案，它能帮助你把你本地运行的服务映射到一个公网地址，这样你就相当于部署到了互联网上。<br>例如我本地跑了一个 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a> 这样的一个 Web 服务，当我通过 ngrok demo 8080 运行 Ngrok 之后，<br>任何想访问我网站的人就可以通过 <a href="http://demo.ngrok.io" target="_blank" rel="noopener">http://demo.ngrok.io</a> 来访问我的网站了。<br></p><h1 id="ngrox介绍"><a href="#ngrox介绍" class="headerlink" title="ngrox介绍"></a>ngrox介绍</h1><ul><li>网上介绍很多，ngrox就是一个反向代理。简单的说我们可以将外部的请求映射到本地来。通俗的将就是讲本地对外公布了。</li></ul><h1 id="ngrox使用"><a href="#ngrox使用" class="headerlink" title="ngrox使用"></a>ngrox使用</h1><ul><li><p>首先到ngrok官网上下载ngrok <a href="https://ngrok.com/download" target="_blank" rel="noopener">ngrok</a>软件。</p><p>下载后解压我们可以看到只有一个ngrok客户端。</p><p><img src="http://oytmxyuek.bkt.clouddn.com/20171111_1.png" alt="ngrok-1.png加载失败，去原网站https://zxhtom.oschina.io,搜索对应文章阅读"></p></li><li><p>双击ngrok.exe会弹出cmd窗口<br><img src="http://oytmxyuek.bkt.clouddn.com/20171111_2.png" alt="ngrok-2.png加载失败，去原网站https://zxhtom.oschina.io,搜索对应文章阅读"></p></li><li><p>在上面的也可以通过<code>ngrok -help</code>命令获得以下提示信息。其中examples中是告诉我们平时使用的映射命令。<br>有了客户端我们就可以进行我们的内外网映射了。但是在映射之前我们还需要注册一个账号用来使用这个客户端</p></li></ul><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><ul><li>在<a href="https://dashboard.ngrok.com/user/login" target="_blank" rel="noopener">ngrok注册登录页面</a>可以先注册一个账号并登陆。<br>登录后页面展示两条命令就是我们本地操作该两条命令就可以映射了。<br><img src="http://oytmxyuek.bkt.clouddn.com/20171111_3.png" alt="ngrok-3.png加载失败，去原网站https://zxhtom.oschina.io,搜索对应文章阅读"></li><li>这里提供一个免费的账号：<code>6vYfEsgm4TRSqoYfkywws_36L3cE5cUz24x9KjMaovX</code></li></ul><h2 id="映射内网"><a href="#映射内网" class="headerlink" title="映射内网"></a>映射内网</h2><ul><li>注册账号之后上一步其实已经官网提示如何映射了。如果我们注册的账号的free版本的。那么很遗憾只能通过<code>ngrok http 端口号</code><br>这个命令来映射了。而且映射的地址形式都是这样的<code>http://XXXX.ngrok.io</code>，其中XXXX是随机生成的字符串。<br><img src="http://oytmxyuek.bkt.clouddn.com/20171111_4.png" alt="ngrok-4.png加载失败，去原网站https://zxhtom.oschina.io,搜索对应文章阅读"></li></ul><h2 id="使用映射个性化域名1"><a href="#使用映射个性化域名1" class="headerlink" title="使用映射个性化域名1"></a>使用映射个性化域名1</h2><ul><li>上面我们虽然已经将内网映射到外网了，但是每种不足的是我们的外网地址里面有一部分是随机字符串，考虑到不好记忆我们。我们可以采用下面命令<pre><code>ngrok http -subdomain=zxh 8080</code></pre>但是由于上面账号是free版本的。所以读者应该会遇到下面的问题<br><img src="http://oytmxyuek.bkt.clouddn.com/20171111_5.png" alt="ngrok-5.png加载失败，去原网站https://zxhtom.oschina.io,搜索对应文章阅读"><br>这里我们只能按照上面提示<a href="https://dashboard.ngrok.com/billing/plan" target="_blank" rel="noopener">去升级</a><br><img src="http://oytmxyuek.bkt.clouddn.com/20171111_6.png" alt="ngrok-6.png加载失败，去原网站https://zxhtom.oschina.io,搜索对应文章阅读"></li></ul><h2 id="使用映射个性化域名2"><a href="#使用映射个性化域名2" class="headerlink" title="使用映射个性化域名2"></a>使用映射个性化域名2</h2><ul><li>这步骤对于了解Linux可能会很轻松。因为ngrok采用的go语言编写的。我们既然无法使用个性地址又不想花钱升级，那么作为程序员我们就重新编译源码<font size="6" color="red">待更新</font></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;br&gt;IT程序员经常会用到服务器，但是为了一个功能不值得买一个阿里云服务器，通过ngrok可以实现本地转外网穿透&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发工具" scheme="https://zxhtom.oschina.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ngrok" scheme="https://zxhtom.oschina.io/tags/ngrok/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3激活及个性化配置</title>
    <link href="https://zxhtom.oschina.io/zxh/20171103.html"/>
    <id>https://zxhtom.oschina.io/zxh/20171103.html</id>
    <published>2017-11-03T15:22:30.000Z</published>
    <updated>2018-01-18T13:52:22.355Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]<br>在我们的开发过程中，选择正确的开发工具会让我们事半功倍。作为后端开发我们熟悉的myeclipse和itellij idea这些工具我也介绍曾介绍过关于他们的安装及破解。但是我们并不能仅仅使用后端。前端开发工具也是有很多的。今天让我们来破解和配置<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">sublime text</a>这个前端神器。<br><a id="more"></a></p><h1 id="软件激活"><a href="#软件激活" class="headerlink" title="软件激活"></a>软件激活</h1><h2 id="激活码-build-3143"><a href="#激活码-build-3143" class="headerlink" title="激活码(build 3143)"></a>激活码(build 3143)</h2><pre><code>    —– BEGIN LICENSE —–    TwitterInc    200 User License    EA7E-890007    1D77F72E 390CDD93 4DCBA022 FAF60790    61AA12C0 A37081C5 D0316412 4584D136    94D7F7D4 95BC8C1C 527DA828 560BB037    D1EDDD8C AE7B379F 50C9D69D B35179EF    2FE898C4 8E4277A8 555CE714 E1FB0E43    D5D52613 C3D12E98 BC49967F 7652EED2    9D2D2E61 67610860 6D338B72 5CF95C69    E36B85CC 84991F19 7575D828 470A92AB    —— END LICENSE ——</code></pre><h2 id="激活步骤"><a href="#激活步骤" class="headerlink" title="激活步骤"></a>激活步骤</h2><p>我们安装好软件之后，在Help–&gt;Register Licence中贴入我们上面的激活码。这里申明一下本人激活时<font color="red">2017年11月03日</font>。离得久远的激活可能会因为用此激活码的人太多导致失效的。所以最好越早激活越好</p><h1 id="风格设置"><a href="#风格设置" class="headerlink" title="风格设置"></a>风格设置</h1><h2 id="设置主题风格"><a href="#设置主题风格" class="headerlink" title="设置主题风格"></a>设置主题风格</h2><p>Adaptive.sublime-theme这个主题挺好的，个人喜欢全屏黑，可能程序员的个性吧。我们在Preferences中选择Theme后选择这个主题就可以了。其他的主题读者可以根据自己的喜好设置安装配置。</p><h2 id="设置左侧风格"><a href="#设置左侧风格" class="headerlink" title="设置左侧风格"></a>设置左侧风格</h2><p>如果选择了Adaptive.sublime-theme我们左侧就会同步主题。如果其他主题没有同步的，我们还可以选择Afterglow.sublime-theme这个主题，然后在对应的主题的user配置文件中进行配置</p><pre><code>{    &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.tmTheme&quot;,    &quot;font_face&quot;: &quot;YaHei Consolas Hybrid&quot;,    &quot;font_options&quot;:    [        &quot;no_bold&quot;,        &quot;no_italic&quot;,        &quot;no_antialias&quot;,        &quot;gray_antialias&quot;    ],    &quot;font_size&quot;: 13,    &quot;ignored_packages&quot;:    [        &quot;Markdown&quot;,        &quot;Vintage&quot;    ],    &quot;tab_height&quot;: 12,    &quot;theme&quot;: &quot;Afterglow.sublime-theme&quot;}</code></pre><h1 id="设置markdown浏览器预览"><a href="#设置markdown浏览器预览" class="headerlink" title="设置markdown浏览器预览"></a>设置markdown浏览器预览</h1><ol><li>通过sublime text3我们如果使用markdown来写博客的。肯定会装关于markdown的插件的</li></ol><ul><li>Markdown Editing    // Markdown编辑和语法高亮支持 </li><li>Markdown Preview    // Markdown导出html预览支持 </li><li>LiveReload          // Markdown刷新浏览器中的Html</li></ul><ol><li>这里我们安装了Markdown Editing 插件后我选择的是打开md格式文件用MultiMarkdown格式打开，所以在Editing对应的MultiMarkdown设置了<code>&quot;draw_centered&quot;: false</code>，让md文章靠左排版。然后我们还是需要设置Markdown Preview 中设置如下</li></ol><pre><code>&quot;browser&quot;: &quot;chrome&quot;,&quot;enable_autoreload&quot;: true,&quot;enable_highlight&quot;: true</code></pre><ol><li><p>其中browser就是你希望那个浏览器打开md文章预览。浏览器对应名称在preview的默认配置文件中有解释。enable_autoreload就是设置是否自动加载md格式成html。但是浏览器中的不会改变。如果想做到实时刷新我们还需要最后一个插件LiveReload。</p></li><li><p>安装完成LiveReload后需要重启sublime text3. 按下Ctrl+Shift+p 输入 LiveReload: Enable/disable plug-ins, 回车.</p></li><li><p>然后选择 Simple Reload with delay (400ms), 也可以选择 Simple Reload. 这个命令运行一次就可以了，无需每打开一个文件就运行一次.</p></li><li><p>至此以后改变md格式只要保存后400ms。浏览器自动刷新</p></li></ol><h1 id="设置字体编码"><a href="#设置字体编码" class="headerlink" title="设置字体编码"></a>设置字体编码</h1><p>安装ConverToUTF8插件</p><h1 id="sublime-text基本命令简单介绍"><a href="#sublime-text基本命令简单介绍" class="headerlink" title="sublime text基本命令简单介绍"></a>sublime text基本命令简单介绍</h1><p>Ctrl+Shift+P : 召唤命令输入窗口。后面得命令都是在这里执行</p><p>ip : 安装插件<br>rp : 移除插件<br>mp : 预览md文件(前提装了markdown preview) 也可以设置快捷键</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;br&gt;在我们的开发过程中，选择正确的开发工具会让我们事半功倍。作为后端开发我们熟悉的myeclipse和itellij idea这些工具我也介绍曾介绍过关于他们的安装及破解。但是我们并不能仅仅使用后端。前端开发工具也是有很多的。今天让我们来破解和配置&lt;a href=&quot;http://www.sublimetext.com/3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sublime text&lt;/a&gt;这个前端神器。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开发工具" scheme="https://zxhtom.oschina.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="前端" scheme="https://zxhtom.oschina.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="sublime text3" scheme="https://zxhtom.oschina.io/tags/sublime-text3/"/>
    
  </entry>
  
  <entry>
    <title>log4j2的使用介绍</title>
    <link href="https://zxhtom.oschina.io/zxh/20171030.html"/>
    <id>https://zxhtom.oschina.io/zxh/20171030.html</id>
    <published>2017-10-30T05:49:50.000Z</published>
    <updated>2018-01-18T13:15:10.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong><center>一张图带你了解log4j2使用</center></strong></p><hr><a id="more"></a><ul><li><p>环境准备</p><ul><li>log4j-api-2.3.jar</li><li>log4j-core-2.3.jar</li><li>log4j-web-2.3.jar  (在web项目中需要引入的jar包。这里做了数据的初始化)  </li></ul></li><li><p>数据初始化</p><p>我们知道在web项目的入口在web.xml中。所以我们得加入log4j的监听器和过滤器</p><pre><code>   &lt;listener&gt;       &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;   &lt;/listener&gt;   &lt;filter&gt;       &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt;       &lt;filter-class&gt;org.apache.logging.log4j.web.Log4jServletFilter&lt;/filter-class&gt;   &lt;/filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt;       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;       &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;       &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;       &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;       &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;   &lt;/filter-mapping&gt;</code></pre><p>到这里我们log4j就已经配置成功了。但是在实际开发中发现没有上面的监听器和过滤器也是可以的。由于时间问题没有研究原因。大概网上查阅了一下好像是log4j源码中有默认的配置。我们上面没有指定具体的配置文件的地址在哪，log4j就会读取jar中默认的配置。系统中选择的默认配置文件有以下几种：</p><ul><li>classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件.  </li><li>classpath下的名为log4j2-test.xml的文件.</li><li>classpath下名为log4j2.json 或者log4j2.jsn的文件.</li><li>classpath下名为log4j2.xml的文件.</li></ul></li></ul><ul><li><p>log4j2配置详解</p><ul><li><img src="http://img.blog.csdn.net/20171026154033576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li></ul></li><li><p>logger等级</p><ul><li>共有8个等级 按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF.</li><li>All:最低等级的，用于打开所有日志记录.</li><li>Trace:是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出.</li><li>Debug:指出细粒度信息事件对调试应用程序是非常有帮助的.</li><li>Info:消息在粗粒度级别上突出强调应用程序的运行过程.</li><li>Warn:输出警告及warn以下级别的日志.</li><li>Error:输出错误信息日志.</li><li>Fatal:输出每个严重的错误事件将会导致应用程序的退出的日志.</li><li>OFF:最高等级的，用于关闭所有日志记录.　　　</li></ul></li><li><p>举例</p><p><img src="http://img.blog.csdn.net/20171026153948683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>像上面那样我们已经配置了很多Logger了。每个Logger都有自己的名字。我们在代码中这样使用<br><code>private static final Logger bossRequestTeletextLogger = LogManager.getLogger(&quot;bossRequestTeletextLogger&quot;);</code><br>意思就是bossRequestTeletxtLogger将使用我们最后一个Logger，该Logger等级是info等级的。存储采用的是<code>teletextLoggerFile</code>存储到文件中的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;center&gt;一张图带你了解log4j2使用&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="log4j2" scheme="https://zxhtom.oschina.io/tags/log4j2/"/>
    
  </entry>
  
  <entry>
    <title>pdf.js跨域加载文件</title>
    <link href="https://zxhtom.oschina.io/zxh/20171029.html"/>
    <id>https://zxhtom.oschina.io/zxh/20171029.html</id>
    <published>2017-10-29T02:12:30.000Z</published>
    <updated>2018-01-18T13:15:10.061Z</updated>
    
    <content type="html"><![CDATA[<p><strong>pdf.js一个基于Html的工具类，熟悉pdf.js的朋友们很清楚，pdf.js帮助我们做了很多事。尤其金融类网站会产生很多的报表。需要在线预览。pdf.js绝对是我们的首选</strong></p> <a id="more"></a><h2 id="本地预览"><a href="#本地预览" class="headerlink" title=" 本地预览"></a> 本地预览</h2><p>在pdf.js的官网上下载的demo中我们就可以直接进行预览。官网的案列在web文件夹下的view.html。这里我整理了一个pdf.js精简版的。<br><img src="http://img.blog.csdn.net/20170725141417149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这两个demo里面加载的是本地文件。这里没什么说的。其中demo2的效果如下。<br><img src="http://img.blog.csdn.net/20170725141559469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>代码也很简单：<br><img src="http://img.blog.csdn.net/20170725141613067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>pdfjs 为我们做了其他的操作，。我们通过pdfjs只需要将本地文件当做参数传递给viewer.html就可以了。</p><h2 id="远程加载-跨域"><a href="#远程加载-跨域" class="headerlink" title="远程加载(跨域)"></a>远程加载(跨域)</h2><ul><li><p>通过上面我们很轻松在实际项目中实现pdf的预览。但是这样的预览存在一个问题。我们分布式项目中往往资源服务和业务服务不在同一台服务器上。这个时候我们在对文件进行预览就时跨域操作了。遇到这个问题我想当然的将上面的a.pdf 换成了我们远程pdf地址了。</p></li><li><p>首先看看我们的远程文件是否正常<br><img src="http://img.blog.csdn.net/20170725142215114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li></ul><ul><li><p>然后再看看我们的代码修改是否正常<br><img src="http://img.blog.csdn.net/20170725142236511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>所有的就绪后，我很高兴的刷新了demo2的页面并进行了操作。但是令人很失望。报错了<br><img src="http://img.blog.csdn.net/20170725142314244?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>报错大概的意思就是文件没找到。为什么没找到是因为我们的文件是远程文件。pdf.js跨域了。在网上找了很多答案。有的说是在web.xml配置放置跨域的操作。测试无效。还有的说请求头修改成跨域的但是没说明白。没有实现。最终我发小在viewer.html中获取file文件参数的原因是需要通过该文件获取文件的文件流从而获取数据对viewer.html记性渲染。所以我换了一下思路。</p></li><li><p>既然是获取文件流为什么一开始不直接传递文件流。基于这个想法。我开始实现获取远程地址的文件流。果然让我找到了方法。我们先通过httpclient爬虫获取远程的文件流。</p></li></ul><pre><code>public InputStream getYCFile(String urlPath) {          InputStream inputStream = null;          try {              try {                  String strUrl = urlPath.trim();                  URL url=new URL(strUrl);                //打开请求连接                URLConnection connection = url.openConnection();                HttpURLConnection httpURLConnection=(HttpURLConnection) connection;                httpURLConnection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;);                // 取得输入流，并使用Reader读取                inputStream = httpURLConnection.getInputStream();                return inputStream;              } catch (IOException e) {                  System.out.println(e.getMessage());                inputStream = null;              }          } catch (Exception e) {              System.out.println(e.getMessage());            inputStream = null;          }          return inputStream;      }</code></pre><ul><li><p>就通过这个方法我们只要传递的地址是正确的，我就可以将该远程文件的文件流返回给你。</p></li><li><p>基于这个方法我们只需要在springmvc中在前台请求到后台的时候调用该方法就可以获取文件流。在通过response将文件流返回到前台。</p></li><li><p>前台：</p></li></ul><pre><code>&lt;iframe src=&quot;../test/js/pdfjs/web/viewer.html?file=&lt;%=basePath%&gt;source/http://192.168.1.184:8080/manage/spirng.pdf&quot;        width=&quot;100%&quot; height=&quot;750&quot;&gt;&lt;/iframe&gt;</code></pre><ul><li>最终我们看看远程的效果。是不是我们可以预览远程的了。其中的好处无疑减轻服务器压力了。</li></ul><p><img src="http://img.blog.csdn.net/20170725143316061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><font color="red"><br>    因为在SSM项目集成的。里面有好多的配置没有细说。有不清楚了，可以扫描左侧二维码加群找我。<br><br><a href="http://download.csdn.net/detail/u013132051/9909958" target="_blank" rel="noopener">源码下载</a><br></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;pdf.js一个基于Html的工具类，熟悉pdf.js的朋友们很清楚，pdf.js帮助我们做了很多事。尤其金融类网站会产生很多的报表。需要在线预览。pdf.js绝对是我们的首选&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="spring" scheme="https://zxhtom.oschina.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>hexo 简单介绍</title>
    <link href="https://zxhtom.oschina.io/zxh/20171028.html"/>
    <id>https://zxhtom.oschina.io/zxh/20171028.html</id>
    <published>2017-10-28T04:12:30.000Z</published>
    <updated>2018-01-18T13:15:10.090Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="案例" scheme="https://zxhtom.oschina.io/categories/%E6%A1%88%E4%BE%8B/"/>
    
    
      <category term="hexo" scheme="https://zxhtom.oschina.io/tags/hexo/"/>
    
      <category term="nodejs" scheme="https://zxhtom.oschina.io/tags/nodejs/"/>
    
      <category term="前端" scheme="https://zxhtom.oschina.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(一)----工厂模式</title>
    <link href="https://zxhtom.oschina.io/zxh/20170611.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170611.html</id>
    <published>2017-06-11T06:34:00.000Z</published>
    <updated>2018-01-18T13:15:10.065Z</updated>
    
    <content type="html"><![CDATA[<p>基本的业务逻辑的编写并不是难事<br><a id="more"></a></p><p><strong><font face="楷体" size="4">基本的业务逻辑的编写并不是难事，作为一个合格的程序员能够编写出易扩展，可维护，高内聚，低耦合的代码才是真正的能力。所以从今天开始会陆陆续续的研究一下设计模式。设计模式并不是针对编程语言，而是考察的编程的思想。</font></strong></p><hr><ul><li><font face="楷体" size="4">设计模式中最简单的应该就是工厂模式了，在我们企业项目中工厂模式和单例模式也是应用最多的模式了。今天我们就简单的介绍一下工厂模式。都是个人总结，不喜勿喷！！！<br></font></li></ul><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul><li><font face="楷体" size="4">工厂模式就是简化了对象的构建。正常情况下我们在Java中是通过new来构建对象，但是有的对象可能需要设置一些默认值等等的额外操作。这个时候为了简化用户的操作我们引入了工厂模式的设计思想。工厂模式就是将构建对象的过程封装在工厂类中，我们需要具体的工厂类中的对象我们就可以通过工厂来获取了。提高了使用的灵活性。</font></li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><font face="楷体" size="4">通过上面的描述我们能够轻松的发现工厂模式带来的好处。有了工厂模式我们构建对象不需要关注对象构建的过程，我们需要的对象只需要想工厂发出生产对象的指令就可以了。抛弃构建的复杂过程，增加代码的阅读性。</font></li></ul><h2 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h2><ul><li><font face="楷体" size="4">工业时代到来之前我们的生产都是人工的，换句话说就是我们需要什么，我们需要自己动手去完成。而有了工厂之后就摆脱了自己的双手。比如说你现在是一家服装厂的老板，夏天来临你需要购进一批夏季服装。相信现在的你不可能自己动手去做衣服，都是通过跟服装厂联系，告诉服装厂你需要衣服的款式，一段时间后你就获得了这些你指定的衣服。至于这些衣服是如何实现的你根本不用关心。服装厂在这里就是我们工厂模式的工厂。</font></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><font face="楷体" size="4">工厂模式又细分为三种：<font face="楷体" size="4" color="red">简单工厂模式</font>+<font face="楷体" size="4" color="red">工厂方法模式</font>+<font face="楷体" size="4" color="red">抽象工厂模式</font></font></li></ul><ul><li><p><font face="楷体" size="4" color="red">简单工厂模式:</font><br> 简单工厂模式是我们上面的情景再现的情况，简单工厂就是说所有的细节都是依靠一个工厂统一完成，这种模式下工厂的压力特别大。</p></li><li><p><font face="楷体" size="4" color="red">工厂方法模式:</font><br>工厂方法模式在上面情景的基础上将工厂进行了更改优化，之前工厂是一个工厂生产一年四季的衣服，现在抽象一个工厂类，在有四个工厂是该抽象工厂的具体实现类，这四个工厂具体分别负责生产春夏秋冬衣服。这样仍然是工厂模式，只不过相对简单工厂模式已经减轻了工厂的压力了。</p></li><li><p><font face="楷体" size="4" color="red">抽象工厂模式:</font><br>抽象工厂模式在抽象方法模式的基础上有进行了强化，抽象方法中是一个具体工厂的实现类负责生产一种类型的衣服，而在抽象工厂模式下一个具体的工厂的实现类可以生产多个类别的衣服。这样更加的减轻服装厂的压力了。</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><font face="楷体" size="4">这里我们就实现简单工厂模式的代码，其他两种的模式知识在简单工厂模式的基础上进行工厂类的强化</font><font face="楷体" size="4" color="blue">服装抽象类(Clothes)</font><pre><code>package zhangxinhua.JavaDesignDetails.工厂模式.features;public abstract class Clothes{    //袖口的数量    private int wristband=2;    //领口的数量    private int neckline=1;    //穿衣方式    public void hold()    {        System.out.println(&quot;我的穿衣方式是从领口&quot;);    }    public int getWristband()    {        return wristband;    }    public void setWristband(int wristband)    {        this.wristband = wristband;    }    public int getNeckline()    {        return neckline;    }    public void setNeckline(int neckline)    {        this.neckline = neckline;    }}</code></pre><font face="楷体" size="4" color="blue">具体服装类一(AutumnCloth)</font><pre><code>package zhangxinhua.JavaDesignDetails.工厂模式.special;import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes;public class AutumnCloth extends Clothes{    @Override    public void hold()    {        System.out.println(&quot;我是秋装，我要倒着穿&quot;);    }}</code></pre><font face="楷体" size="4" color="blue">具体服装类二(SpringCloth)</font><pre><code>package zhangxinhua.JavaDesignDetails.工厂模式.special;import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes;public class SpringCloth extends Clothes{    @Override    public void hold()    {        System.out.println(&quot;我是春装，我要从领口穿衣&quot;);    }}</code></pre><font face="楷体" size="4" color="blue">具体服装类三(SummerCloth)</font><pre><code>package zhangxinhua.JavaDesignDetails.工厂模式.special;import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes;public class SummerCloth extends Clothes{    @Override    public void hold()    {        System.out.println(&quot;我是夏装，我要从怀口穿&quot;);    }}</code></pre><font face="楷体" size="4" color="blue">工厂类(Clothfactory)</font><pre><code>package zhangxinhua.JavaDesignDetails.工厂模式.简单工厂模式.factory;import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes;import zhangxinhua.JavaDesignDetails.工厂模式.special.AutumnCloth;import zhangxinhua.JavaDesignDetails.工厂模式.special.SpringCloth;import zhangxinhua.JavaDesignDetails.工厂模式.special.SummerCloth;public class ClothFactory{    public static Clothes createClothes(String type) throws Exception    {        Clothes clothes=null;        switch (type)        {        case &quot;spring&quot;:            clothes=new SpringCloth();            break;        case &quot;summer&quot;:            clothes=new SummerCloth();            break;        case &quot;autumn&quot;:            clothes=new AutumnCloth();            break;        default:            throw new Exception(&quot;目前不支持你指定的类型&quot;);        }        return clothes;    }}</code></pre><font face="楷体" size="4" color="blue">客户端调用(client)</font><pre><code>package zhangxinhua.JavaDesignDetails.工厂模式.简单工厂模式.client;import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes;import zhangxinhua.JavaDesignDetails.工厂模式.简单工厂模式.factory.ClothFactory;public class client{    public static void main(String[] args) throws Exception    {        System.out.println(&quot;工厂你给我一套春装&quot;);        Clothes spring = ClothFactory.createClothes(&quot;spring&quot;);        spring.hold();        System.out.println(&quot;********************&quot;);        System.out.println(&quot;工厂你给我一套秋装&quot;);        Clothes autum = ClothFactory.createClothes(&quot;autumn&quot;);        autum.hold();        System.out.println(&quot;********************&quot;);        System.out.println(&quot;工厂你给我一套夏装&quot;);        Clothes summer = ClothFactory.createClothes(&quot;summer&quot;);        summer.hold();        System.out.println(&quot;********************&quot;);    }}</code></pre><font face="楷体" size="4" color="blue">效果展示</font><p><img src="http://img.blog.csdn.net/20170611143100083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>设计模式的学习是潜移默化，学习设计模式不要急，成长是需要时间的，今天的努力，将来的一天终会回报。</li></ul><font face="楷体" size="5" color="green">有需要源码的，或者有不理解，欢迎扫描左侧二维码，进群交流讨论。</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本的业务逻辑的编写并不是难事&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>简单认识Nginx---负载均衡</title>
    <link href="https://zxhtom.oschina.io/zxh/20170428.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170428.html</id>
    <published>2017-04-28T09:48:00.000Z</published>
    <updated>2018-01-18T13:15:10.064Z</updated>
    
    <content type="html"><![CDATA[<p>中大型项目都会考虑到分布式<br><a id="more"></a></p><p><strong>中大型项目都会考虑到分布式，前面几篇文章着重介绍了数据处理的技术集群。今天来研究一下关于服务器的负载均衡–Nginx。他除了静态资源的处理外还有可以决定将请求置于那台服务上。</strong></p><h1 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h1><p><a href="http://nginx.org/" target="_blank" rel="noopener"><font color="red">点我下载</font></a></p><ul><li>下载好之后我们可以直接点击进行服务开启</li></ul><font color="blue">友情提醒：nginx的路径不能有汉字</font><br><img src="http://img.blog.csdn.net/20170414095443454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><br>  -  或者我们通过cmd命令来开启服务。首先到D:\Chirs\Downloads\nginx-1.11.11\nginx-1.11.11目录下执行命令<br><br><code>nginx</code><br><br>  -  顺便说一下关闭命令：<br><br><code>nginx -s  stop</code><br><br>  - 就这么简单nginx开启了。查看是否开启成功只需要打开浏览器输入127.0.0.1或者localhost<br><br><img src="http://img.blog.csdn.net/20170414095732987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><br>Nginx的基本命令<br>–<br><br>  -  上面已经提到了启动命令： nginx.exe<br><br>  重启： nginx.exe -s reload<br>  关闭：nginx.exe -s stop<br>  检测配置合法性：nginx.exe -t<br><br><font color="blue">友情提醒：尽量在重启的时候用重启命令。有的人喜欢先关闭服务在开启服务。这样做如果修改后的配置是错误的，就会影响到nginx的使用。而如果用重启命令，就算修改后的配置错误了，仅仅影响新修改的功能，之前的服务仍然可以执行。</font><h1 id="Nginx与Tomcat实现负载均衡"><a href="#Nginx与Tomcat实现负载均衡" class="headerlink" title="Nginx与Tomcat实现负载均衡"></a>Nginx与Tomcat实现负载均衡</h1><ul><li>在现在数万访问量的大数据时代，分布式是我们所必须要考虑的一个因素。那么nginx就可以帮助我们缓解大数据的压力。我们可以通过Nginx的反向代理将请求发送到不同的tomat，这样就大大的缓解了我们服务器的压力了。</li></ul><h2 id="准备两个Tomcat"><a href="#准备两个Tomcat" class="headerlink" title="准备两个Tomcat"></a>准备两个Tomcat</h2><ul><li>想要实现负载均衡我们就得有多个服务器，这样nginx才能够将请求平均分配在不同的服务上。所以这里为了掩饰效果我们只准备两个服务 器(Tomcat)。配置不同的访问端口就可以了。</li></ul><h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><p>首先贴出一段官网的windows的配置文件。下面逐条解释。</p><pre><code>#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server {        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html;            index  index.html index.htm;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ {        #    proxy_pass   http://127.0.0.1;        #}        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ {        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #}        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ /\.ht {        #    deny  all;        #}    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}</code></pre><ul><li><p><code>#user  nobody;</code> ： user属性在windows中不用设置，人家注释写的很清楚 nobody,但是在Linux系统中我们建议写 user nginx(用户) nginx(组) 。</p></li><li><p><code>worker_processes  1;</code> ： 工作进程 正常是CPU*2</p></li><li><p><code>error_log</code> : nginx 的错误日志记录的文件地址</p></li><li><p><code>pid</code> ： 在windows中每个进程在后台都是有一个pid的。</p></li></ul><p><img src="http://img.blog.csdn.net/20170428161940355?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li><code>events</code> :  里面设置一些属性比如连接数 worker_connections</li></ul><ul><li><p><code>http</code>  ： http就是nginx通过设置的http实现负载均衡的</p><ul><li><p><code>include mime.types;</code> ： 设定mime类型,类型由mime.type文件定义</p></li><li><p><code>default_type application/octet-stream;</code> ： 设置默认的请求类型</p></li><li><p><code>log_format</code>  ： 日志的输出格式。</p></li><li><p>日志格式参数解释：</p></li><li><p><code>$remote_addr</code>与<code>$http_x_forwarded_for</code>用以记录客户端的ip地址；</p></li><li><p>$remote_user：用来记录客户端用户名称；</p></li><li><p>$time_local： 用来记录访问时间与时区；</p></li><li><p>$request： 用来记录请求的url与http协议；</p></li><li><p>$status： 用来记录请求状态；成功是200，</p></li><li><p>$body_bytes_sent ：记录发送给客户端文件主体内容大小；</p></li><li><p>$http_referer：用来记录从那个页面链接访问过来的；</p></li><li><p>$http_user_agent：记录客户浏览器的相关信息；</p></li><li><p><code>sendfile on;</code> :　sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。　</p></li></ul></li></ul><pre><code>-  `tcp_nopush on;`: 此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 　　</code></pre><font color="blue"><a href="http://blog.csdn.net/tjcyjd/article/details/50695922" target="_blank" rel="noopener">详细</a></font>　　　<br><br><br>nginx.conf修改<br>–<br><br>  -  上面我们已经详细的介绍了nginx的各个参数的设置了。在配置之前我们先看看nginx初始配置http的location<br><br><img src="http://img.blog.csdn.net/20170428165415512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><br>  -  通过上面的我们可以看出，当我们访问localhost(server_name):80(listen)的时候，nginx就会自动跳转到html文件夹中的index.html或者是index.htm的页面上了。<br><img src="http://img.blog.csdn.net/20170428165621997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><br>  -  我们现在要做的就是在访问nginx是随机的跳转到我们指定的Tomcat上。相信大家都知道了，就是修改location的映射路径就行了。但是我们的映射路径是个选择器，所以我们首先构造一个选择器出来<br><br><code>upstream mynginxserver {        server 192.168.1.183:8888 weight=2;        server 192.168.1.183:8080 weight=1;  }</code><br><br>  -  其中weight是权重，就是nginx在随机选择的时候回根据这个权重去选择服务。<br><br>  -  然后我们将location的映射路径映射到mynginserver上就行了。<br><br><code>location / {            proxy_pass http://mynginxserver;        }</code><br><br><font color="red">注意： proxy_pass 后必须以<a href="http://开头。" target="_blank" rel="noopener">http://开头。</a></font><ul><li>一切配置好之后我们重启nginx（nginx.exe -s reload）。这个时候我们先分别看看两个Tomcat访问的效果<br><font color="red">注意看路径的端口是不同的</font><br>Tomcat1：<br><img src="http://img.blog.csdn.net/20170428170239709?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ul><p>Tomcat2：<br><img src="http://img.blog.csdn.net/20170428170252157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>然后我们这个时候在访问nginx的端口：<code>http://192.168.1.183:802/springtests/</code></p><p><img src="http://img.blog.csdn.net/20170428170535775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170428170552369?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>上面的效果就是同一个请求但是请求的页面是两个页面，实际上是请求的两个Tomcat。我们实际运行中会在两个Tomcat上放置完全相同的项目。这样用户体验就是使用的同一个项目，但是我们已经实现了负载均衡了。</li></ul><h2 id="负载均衡的几个策略"><a href="#负载均衡的几个策略" class="headerlink" title="负载均衡的几个策略"></a>负载均衡的几个策略</h2><ul><li><p>上面我们已经实现了负载均衡。nginx给我提供了关于负载均衡的策略。</p></li><li><p>默认策略–轮询：</p></li></ul><pre><code>upstream mynginxserver {        server 192.168.1.183:8888;        server 192.168.1.183:8080;    }</code></pre><p>  通过请求的时间顺序请求不同的Tomcat。如果某一个宕机了，则自动忽略。</p><ul><li>最少链接 : 顾名思义就是在选择的时候谁的连接数最少，就选择谁</li></ul><pre><code>upstream mynginxserver {    least_conn;        server 192.168.1.183:8888;        server 192.168.1.183:8080;    }</code></pre><ul><li>weight权重： 这种方式也是我上面实现负载均衡采用的方式。默认值是1 。就是在选择具体发送到哪一个Tomcat的时候是根据Tomcat的权重判断的。</li></ul><pre><code>upstream mynginxserver {        server 192.168.1.183:8888 weight=2;        server 192.168.1.183:8080 weight=1;    }</code></pre><ul><li>ip_hash : 这个就是根据当前请求的ip，根据ip算出对应的hash值，然后在根据hash值选择对应的Tomcat。这种效果就是一台客户端至始至终访问的都是同一台Tomcat。这里的session就是一样的。</li></ul><pre><code>upstream mynginxserver {    ip_hash;        server 192.168.1.183:8888 ;        server 192.168.1.183:8080 ;    }</code></pre><ul><li>url_hash: 和ip_hash是一个效果</li></ul><pre><code>upstream mynginxserver {    hash $request_url;        server 192.168.1.183:8888;        server 192.168.1.183:8080;    }</code></pre><ul><li>fair：根据响应时间来定的。谁的响应时间短，就连谁。</li></ul><pre><code>upstream mynginxserver {        server 192.168.1.183:8888 ;        server 192.168.1.183:8080 ;        fair;    }</code></pre><h1 id="nginx地址映射"><a href="#nginx地址映射" class="headerlink" title="nginx地址映射"></a>nginx地址映射</h1><ul><li><p>nginx除了作为服务器的负载均衡外，还有一个亮点就是地址映射。作为资源服务器来使用。在我们的web开发中经常需要上传资源到服务上。我们总不能将资源放在Tomcat上。这样会大大增加Tomcat的压力的。而且这样数据很容易丢失的。nginx就可以解决这个问题。</p></li><li><p>其实在上面实现负载均衡的时候就已经实现了地址映射。location就是地址映射的桥梁。</p></li></ul><pre><code>location ~ ^/images/(.*)          # location ~ ^/images/(.*\.jpg)          #“.”表示任何字符，“*”表示任意数量，         #“\.jpg”表示jpg后缀名的文件      {         expires 1s;         alias D:/zxh/test/$1;   #“$1”表是location后面（）的内容         index  index.html index.htm;         break;      }</code></pre><p>上面的location表示在通过server+port+^images^.^的形式就会映射到D:/zxh/test这个文件夹下。<br>比如我在浏览器中访问：<code>http://192.168.1.183:802/images/test.jpg</code></p><p>这个时候nginx就会去访问D:/zxh/test下时候有test.jpg的图片。<br><img src="http://img.blog.csdn.net/20170428173650052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20170428173702894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>以上是在网上参考别人写的整理。不喜勿喷！@　　　　　　</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中大型项目都会考虑到分布式&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Windows下的bat原来可以为我们做很多</title>
    <link href="https://zxhtom.oschina.io/zxh/20170422.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170422.html</id>
    <published>2017-04-22T05:18:00.000Z</published>
    <updated>2018-01-18T13:15:10.056Z</updated>
    
    <content type="html"><![CDATA[<p>用了windows系统这么多年了，对bat也不是很了解。最近研究了一下bat的用法。这里就大概列举一下自己的用法**<br><a id="more"></a></p><p><strong>用了windows系统这么多年了，对bat也不是很了解。最近研究了一下bat的用法。这里就大概列举一下自己的用法</strong></p><p><a href="http://www.jb51.net/article/49627.htm" target="_blank" rel="noopener">参考网址</a></p><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><ul><li><p>echo我们可以理解成程序中的输出，和我们Java的System.out.println是一个效果。</p></li><li><p>关于echo有两种设置 echo on 和echo off.前者是在此命令之后的命令都会显示输出，后者则不显示后面的执行命令了</p></li></ul><p>@<br>-</p><ul><li>@ 的功能和echo off的功能一样都是让命令不显示的。唯一的区别的@ 影响的是当前行而echo off影响的是在其后的所有的命令行。</li></ul><pre><code>  @echo off    redis-server.exe redis.conf  @pause</code></pre><ul><li>例如上面的bat文件的语句最终执行的效果是 echo off 这个命令不显示  因为@ 控制当前行不显示。redis-server.exe redis.conf 这个命令也不显示 。因为echo off之后的命令都不现实。除非遇到echo on在此开启了显示的功能。</li></ul><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul><li>call别人说和start功能一样，但是自己测试call无法使用，取而代之的我用的是start， start和call的作用就是在本bat文件中调用了别的bat文件。如果不用start或者call的话，那么本bat文件将执行完别的bat就不在继续执行本bat的其他语句了。相当于Java中的break了。</li></ul><h2 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h2><ul><li>pause是暂停的意思，就是bat执行完了之后cmd窗口不会关闭而是在pause的地方输出 press any  key …. 。他和exit相对。exit是指程序结束后就关闭窗口。正常pause和exit在文件的最后存在。</li></ul><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><ul><li>作为程序员都是知道注释的重要性的。就算是自己写的代码没有良好的注释过一段时间自己都会忘记这段代码的作用。而在bat批处理语言中rem就是起到注释的作用。<br>rem  我是注释</li></ul><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><ul><li><p>Java或者其他语言中都是可以进行参数传递的，这样可以增加各个模块的联系，bat也是可以传递参数的。他的传递参数的方法比较特别，不需要指定参数的类型。只是按参数的顺序来获取的。分别用%0~%9来获取参数。这样也就是说参数只能是9个。其中%0表示的bat方法的本身。%1~%9表示第几个参数。</p></li><li><p>新建一个method.bat,内容为echo %1。我们新开cmd窗口。首先cd到method.bat所在的文件目录中。执行语句 method.bat  helloworld  程序结果 为  helloworld。</p></li></ul><h1 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h1><ul><li>上面的一些基础的命令之外还有一些属于高级命令  ，正常情况写我们做逻辑判断的时候经常用到  if  goto choice for，这四个使我们经常用到。</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li><p>if 就是我们用到的程序判断，根据条件执行不同的语句。其中的基本格式如下</p><p>if “%1”==”test” echo test</p></li><li><p>上面的代码执行的效果就是输入了test的参数就会输出test 结果，输入的可以是“ hello world ”  ,在程序中的参数就是带引号的参数。</p></li><li><p>if [not] exist 判断不存在是执行的语句</p></li><li><p>if exist  判断存在时存在的语句</p></li><li><p>if errorlevel num 根据程序的返回值判断 </p></li></ul><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><ul><li>goto就是跳转到哪里  基本语法</li></ul><pre><code> goto zxh :zxh echo 跳转啦</code></pre><ul><li>其中goto去的端点 需要用：开头</li></ul><h2 id="choice"><a href="#choice" class="headerlink" title="choice"></a>choice</h2><ul><li><p>这个选择项用的挺多的，因为考虑程序的大众化，我们程序正常会给用户提供选择，这里就需要用到了choice了。</p></li><li><p>关于choice中有哪些参数，我们可以打开cmd窗口执行 choice /?<br><img src="http://img.blog.csdn.net/20170420131213689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li></ul><ul><li><p>上面的一张图片已经解释了choice的选项说明，我们有设么格式的提示选项上面的图片事列已经列出了五种类型的。我们根据不同需求些不同的bat.</p></li><li><p>其中在/c后面的提示列表的编号我们一次是1,2,3….N。在我们根据errorlevel的值判断的时候必须从高到底比如如下一段代码才有效</p></li></ul><pre><code>@echo offchoice /C dme /M &quot;defrag,mem,end&quot;if errorlevel 3 goto endif errorlevel 2 goto memif errorlevel 1 goto defrag:defragecho I am defraggoto end:memecho I am memgoto end:endecho good byepause</code></pre><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul><li>for循环是我们遍历数据用的最多了。我们经常通过for来执行相同理念的操作。</li></ul><pre><code>FOR %%variable IN (set) DO command [command-parameters]</code></pre><ul><li>上面的for循环其实用Java语言写就是一下代码</li></ul><pre><code>for(Object obj in List&lt;Object&gt;){//执行操作}</code></pre><ul><li>所以上面的variable就是下面的obj</li><li>set 就是下面的list集合</li><li>command是我们的执行操作</li><li><p>command parameters 是我们执行操作的时候用到的参数正常就是variable(obj)</p><p><img src="http://img.blog.csdn.net/20170425221944614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用了windows系统这么多年了，对bat也不是很了解。最近研究了一下bat的用法。这里就大概列举一下自己的用法**&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="bat语法" scheme="https://zxhtom.oschina.io/tags/bat%E8%AF%AD%E6%B3%95/"/>
    
      <category term="命令" scheme="https://zxhtom.oschina.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Spring 集成Kafka(完整版)</title>
    <link href="https://zxhtom.oschina.io/zxh/20170416.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170416.html</id>
    <published>2017-04-16T13:31:00.000Z</published>
    <updated>2018-01-18T13:15:10.055Z</updated>
    
    <content type="html"><![CDATA[<p>前面的文章我们已经完成了Kafka基于Zookeeper的集群的搭建了<br><a id="more"></a></p><p>前面的文章我们已经完成了Kafka基于Zookeeper的集群的搭建了。<a href="http://blog.csdn.net/u013132051/article/details/68925935" target="_blank" rel="noopener">Kafka集群搭建请点我</a>。记过几天的研究已经实现Spring的集成了。本文重点</p><h1 id="jar包准备"><a href="#jar包准备" class="headerlink" title="jar包准备"></a>jar包准备</h1><ul><li>集成是基于spring-integration-kafka完成的。我这里用的项目是maven。该jar包在maven的位置</li></ul><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;    &lt;artifactId&gt;spring-integration-kafka&lt;/artifactId&gt;    &lt;version&gt;1.3.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><font color="blue">友情提醒：</font>自己在网上看的教程多引入了kafka_2.10jar包。我的项目报错。建议搭建指引入和kafka相关的上面那个jar包</p><h1 id="配置生产者-spring-kafka-producer-xml"><a href="#配置生产者-spring-kafka-producer-xml" class="headerlink" title="配置生产者(spring-kafka-producer.xml)"></a>配置生产者(spring-kafka-producer.xml)</h1><ul><li><p>有了jar包我们只需要在spring的配置文件中配置就行了。这里我单独将生产者和消费者进行抽离配置</p></li><li><p>首先我们配置生产消息的频道(工具类)，这个频道基于queue。最后我们在消息发送也是通过该类实现发送消息的</p></li></ul><pre><code>&lt;int:channel id=&quot;kafkaProducerChannel&quot;&gt;    &lt;int:queue /&gt;&lt;/int:channel&gt;</code></pre><ul><li>有了频道我们需要将频道和消息分类结合起来 ， outbound-channel-adapter  。顾名思义发送+频道+分类。该类就是设置这三个的联系的。这里我们主要看的是kafka-producer-context-ref。他是生产者消息的来源地</li></ul><pre><code>&lt;int-kafka:outbound-channel-adapter        id=&quot;kafkaOutboundChannelAdapterTopic&quot; kafka-producer-context-ref=&quot;producerContextTopic&quot;        auto-startup=&quot;true&quot; channel=&quot;kafkaProducerChannel&quot; order=&quot;3&quot;&gt;        &lt;int:poller fixed-delay=&quot;1000&quot; time-unit=&quot;MILLISECONDS&quot;            receive-timeout=&quot;1&quot; task-executor=&quot;taskExecutor&quot; /&gt;    &lt;/int-kafka:outbound-channel-adapter&gt;</code></pre><ul><li>生产者的类别设置。及消息的编码序列化等操作都是该类设置的<br>首先就是这里的topic。每个topic对应一个类。topic中的broker-list是kafka服务(集群)。key-serializer和key-encoder分别设置序列化和编码。两者只需要设置一个就行。value-class-type是消息的类型。value-serializer和value-encoder和key是一样的解释</li></ul><pre><code>&lt;int-kafka:producer-context id=&quot;producerContextTopic&quot;        producer-properties=&quot;producerProperties&quot;&gt;        &lt;int-kafka:producer-configurations&gt;            &lt;!-- 多个topic配置  broker-list kafaka服务            key_serializer  value-serializer 就是用了自己的编码格式            value-class-type 指定发送消息的类型--&gt;            &lt;int-kafka:producer-configuration                broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot;                value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot;                topic=&quot;testTopic&quot; /&gt;            &lt;int-kafka:producer-configuration                broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot;                value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot;                topic=&quot;myTopic&quot; /&gt;        &lt;/int-kafka:producer-configurations&gt;    &lt;/int-kafka:producer-context&gt;</code></pre><ul><li>上面消费者设置的序列化我们需要单独设置一下。我们可以采用spring-integration-kafka提供的序列化类。但是用了那个序列只能传递字符串。我们可以从定义该类实现传递对象(包括字符串)<br><img src="http://img.blog.csdn.net/20170412150618965?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><pre><code>&lt;bean id=&quot;stringSerializer&quot; class=&quot;com.bshinfo.web.base.kafka.producer.MySerializer&quot; /&gt;</code></pre></li></ul><ul><li>完整配置</li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:int=&quot;http://www.springframework.org/schema/integration&quot;    xmlns:int-kafka=&quot;http://www.springframework.org/schema/integration/kafka&quot;    xmlns:task=&quot;http://www.springframework.org/schema/task&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/integration/kafka http://www.springframework.org/schema/integration/kafka/spring-integration-kafka.xsd        http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!-- 生产者生产信息是键值对内容的格式。默认是 org.apache.kafka.common.serialization.StringSerializer    这里我们重写方法。便于方法传递对象  具体看MySerializer--&gt;    &lt;bean id=&quot;stringSerializer&quot; class=&quot;com.bshinfo.web.base.kafka.producer.MySerializer&quot; /&gt;    &lt;!-- 这里的Encoder在下面没有用到 删掉也可以  Encoder和Serializer只用设置一个就行了。    consumer.xml中的配置也是一样 --&gt;    &lt;!-- &lt;bean id=&quot;kafkaEncoder&quot;        class=&quot;org.springframework.integration.kafka.serializer.avro.AvroReflectDatumBackedKafkaEncoder&quot;&gt;        &lt;constructor-arg value=&quot;com.kafka.demo.util.ObjectEncoder&quot; /&gt;    &lt;/bean&gt; --&gt;    &lt;!-- 生产者一些配置属性。不配置按默认执行 --&gt;    &lt;bean id=&quot;producerProperties&quot;        class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt;        &lt;property name=&quot;properties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;topic.metadata.refresh.interval.ms&quot;&gt;3600000&lt;/prop&gt;                &lt;prop key=&quot;message.send.max.retries&quot;&gt;5&lt;/prop&gt;                &lt;!-- &lt;prop key=&quot;serializer.class&quot;&gt;com.kafka.demo.util.ObjectEncoder&lt;/prop&gt; --&gt;                &lt;prop key=&quot;request.required.acks&quot;&gt;1&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 生产者通过这个频道传送消息  基于queue--&gt;    &lt;int:channel id=&quot;kafkaProducerChannel&quot;&gt;        &lt;int:queue /&gt;    &lt;/int:channel&gt;    &lt;!-- 生产者发送消息设置  频道+方法配置 --&gt;    &lt;int-kafka:outbound-channel-adapter        id=&quot;kafkaOutboundChannelAdapterTopic&quot; kafka-producer-context-ref=&quot;producerContextTopic&quot;        auto-startup=&quot;true&quot; channel=&quot;kafkaProducerChannel&quot; order=&quot;3&quot;&gt;        &lt;int:poller fixed-delay=&quot;1000&quot; time-unit=&quot;MILLISECONDS&quot;            receive-timeout=&quot;1&quot; task-executor=&quot;taskExecutor&quot; /&gt;    &lt;/int-kafka:outbound-channel-adapter&gt;    &lt;task:executor id=&quot;taskExecutor&quot; pool-size=&quot;5&quot;        keep-alive=&quot;120&quot; queue-capacity=&quot;500&quot; /&gt;    &lt;!-- 消息发送的主题设置。必须设置了主题才能发送相应主题消息 --&gt;    &lt;int-kafka:producer-context id=&quot;producerContextTopic&quot;        producer-properties=&quot;producerProperties&quot;&gt;        &lt;int-kafka:producer-configurations&gt;            &lt;!-- 多个topic配置  broker-list kafaka服务            key_serializer  value-serializer 就是用了自己的编码格式            value-class-type 指定发送消息的类型--&gt;            &lt;int-kafka:producer-configuration                broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot;                value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot;                topic=&quot;testTopic&quot; /&gt;            &lt;int-kafka:producer-configuration                broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot;                value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot;                topic=&quot;myTopic&quot; /&gt;        &lt;/int-kafka:producer-configurations&gt;    &lt;/int-kafka:producer-context&gt;&lt;/beans&gt;</code></pre><ul><li>最后我们在生产消息的地方注入我们配置文件中的频道就可以发送消息了<br><img src="http://img.blog.csdn.net/20170412150811763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170412150837493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li></ul><h1 id="消费者配置-spring-kafka-consumer-xml"><a href="#消费者配置-spring-kafka-consumer-xml" class="headerlink" title="消费者配置(spring-kafka-consumer.xml)"></a>消费者配置(spring-kafka-consumer.xml)</h1><ul><li>上面的配置就可以实现消息的发送了。我们项目中会继续配置接收消息(消费者)。配置和生产者的配置一样。这里就不详细的解释了。代码里解释的很详细了。只不过里面多了配置Zookeeper的集群信息。还有一点因为在生产者我配置的序列化。所以这里为了配置全面这里采用配置的编码了 </li></ul><ul><li>完整配置</li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:int=&quot;http://www.springframework.org/schema/integration&quot;    xmlns:int-kafka=&quot;http://www.springframework.org/schema/integration/kafka&quot;    xmlns:task=&quot;http://www.springframework.org/schema/task&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/integration/kafka                         http://www.springframework.org/schema/integration/kafka/spring-integration-kafka.xsd                        http://www.springframework.org/schema/integration                         http://www.springframework.org/schema/integration/spring-integration.xsd                        http://www.springframework.org/schema/beans                         http://www.springframework.org/schema/beans/spring-beans.xsd                        http://www.springframework.org/schema/task                         http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!-- 接收的频道 也可以理解为接收的工具类 --&gt;    &lt;int:channel id=&quot;inputFromKafka&quot;&gt;        &lt;int:dispatcher task-executor=&quot;kafkaMessageExecutor&quot; /&gt;    &lt;/int:channel&gt;    &lt;!-- zookeeper配置 可以配置多个 --&gt;    &lt;int-kafka:zookeeper-connect id=&quot;zookeeperConnect&quot;        zk-connect=&quot;192.168.1.130:2181,192.168.1.130:2182,192.168.1.130:2183&quot; zk-connection-timeout=&quot;6000&quot;        zk-session-timeout=&quot;6000&quot; zk-sync-time=&quot;2000&quot; /&gt;    &lt;!-- channel配置 auto-startup=&quot;true&quot; 否则接收不发数据 --&gt;    &lt;int-kafka:inbound-channel-adapter        id=&quot;kafkaInboundChannelAdapter&quot; kafka-consumer-context-ref=&quot;consumerContext&quot;        auto-startup=&quot;true&quot; channel=&quot;inputFromKafka&quot;&gt;        &lt;int:poller fixed-delay=&quot;1&quot; time-unit=&quot;MILLISECONDS&quot; /&gt;    &lt;/int-kafka:inbound-channel-adapter&gt;    &lt;task:executor id=&quot;kafkaMessageExecutor&quot; pool-size=&quot;8&quot; keep-alive=&quot;120&quot; queue-capacity=&quot;500&quot; /&gt;    &lt;!-- &lt;bean id=&quot;kafkaDecoder&quot; class=&quot;org.springframework.integration.kafka.serializer.common.StringDecoder&quot; /&gt; --&gt;    &lt;bean id=&quot;kafkaDecoder&quot; class=&quot;com.bshinfo.web.base.kafka.consumer.MyDecoder&quot; /&gt;    &lt;bean id=&quot;consumerProperties&quot;        class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt;        &lt;property name=&quot;properties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;auto.offset.reset&quot;&gt;smallest&lt;/prop&gt;                &lt;prop key=&quot;socket.receive.buffer.bytes&quot;&gt;10485760&lt;/prop&gt; &lt;!-- 10M --&gt;                &lt;prop key=&quot;fetch.message.max.bytes&quot;&gt;5242880&lt;/prop&gt;                &lt;prop key=&quot;auto.commit.interval.ms&quot;&gt;1000&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 消息接收的BEEN --&gt;    &lt;bean id=&quot;kafkaConsumerService&quot; class=&quot;com.bshinfo.web.base.kafka.consumer.ConsumerMessages&quot; /&gt;    &lt;!-- 指定接收的方法 --&gt;    &lt;int:outbound-channel-adapter channel=&quot;inputFromKafka&quot;        ref=&quot;kafkaConsumerService&quot; method=&quot;processMessage&quot; /&gt;    &lt;int-kafka:consumer-context id=&quot;consumerContext&quot;        consumer-timeout=&quot;1000&quot; zookeeper-connect=&quot;zookeeperConnect&quot;        consumer-properties=&quot;consumerProperties&quot;&gt;        &lt;int-kafka:consumer-configurations&gt;            &lt;int-kafka:consumer-configuration                group-id=&quot;default1&quot; value-decoder=&quot;kafkaDecoder&quot; key-decoder=&quot;kafkaDecoder&quot;                max-messages=&quot;5000&quot;&gt;                &lt;!-- 两个TOPIC配置 --&gt;                &lt;int-kafka:topic id=&quot;myTopic&quot; streams=&quot;4&quot; /&gt;                &lt;int-kafka:topic id=&quot;testTopic&quot; streams=&quot;4&quot; /&gt;            &lt;/int-kafka:consumer-configuration&gt;        &lt;/int-kafka:consumer-configurations&gt;    &lt;/int-kafka:consumer-context&gt;&lt;/beans&gt;</code></pre><ul><li>配置中消费者实现类</li></ul><pre><code>package com.bshinfo.web.base.kafka.consumer;import java.util.Collection;import java.util.Iterator;import java.util.Map;import java.util.Set;import net.sf.json.JSONArray;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ConsumerMessages{    private static final Logger logger = LoggerFactory.getLogger(ConsumerMessages.class);    public void processMessage(Map&lt;String, Map&lt;Integer, Object&gt;&gt; msgs)     {        logger.info(&quot;================================processMessage===============&quot;);        for (Map.Entry&lt;String, Map&lt;Integer, Object&gt;&gt; entry : msgs.entrySet())         {            logger.info(&quot;============Topic:&quot; + entry.getKey());            System.err.println(&quot;============Topic:&quot; + entry.getKey());            Map&lt;Integer, Object&gt; messages = entry.getValue();            Set&lt;Integer&gt; keys = messages.keySet();            for (Integer i : keys)            {                 logger.info(&quot;======Partition:&quot; + i);                 System.err.println(&quot;======Partition:&quot; + i);            }            Collection&lt;Object&gt; values = messages.values();            for (Iterator&lt;Object&gt; iterator = values.iterator(); iterator.hasNext();)             {                Object object = iterator.next();                String message = &quot;[&quot;+object.toString()+&quot;]&quot;;                logger.info(&quot;=====message:&quot; + message);                System.err.println(&quot;=====message:&quot; + message);                JSONArray jsonArray = JSONArray.fromObject(object);                for (int i=0;i&lt;jsonArray.size();i++)                {                    Object object2 = jsonArray.get(i);                    System.out.println(object2.toString());                    /*JSONObject object2 = (JSONObject) jsonArray.get(i);                    UserInfo userInfo = (UserInfo) JSONObject.toBean(object2,UserInfo.class);                    System.out.println(userInfo.getRealName()+&quot;@@@&quot;+userInfo.getUserSex());*/                }            }        }    }}</code></pre><ul><li>消费者中转码的工具类</li></ul><p><img src="http://img.blog.csdn.net/20170412151253953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p> <a href="http://download.csdn.net/detail/u013132051/9811806" target="_blank" rel="noopener"><font color="red">源码下载</font></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的文章我们已经完成了Kafka基于Zookeeper的集群的搭建了&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Kafka集群配置---Windows版</title>
    <link href="https://zxhtom.oschina.io/zxh/20170410.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170410.html</id>
    <published>2017-04-10T03:06:00.000Z</published>
    <updated>2018-01-18T13:15:10.052Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka是一种高吞吐量的分布式发布订阅的消息队列系统<br><a id="more"></a></p><pre><code>Kafka是一种高吞吐量的分布式发布订阅的消息队列系统，Kafka对消息进行保存时是通过tipic进行分组的。今天我们仅实现Kafka集群的配置。理论的抽空在聊</code></pre><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>最近研究kafka，发现网上很多关于kafka的介绍都是基于Linux操作系统的。虽然这些服务最后都是配置Linux上的。但是我们平时使用的大多都是Windows系统。所以研究很是吃力。经过借鉴不同的网络文章终于在Windows上实现了kafka的配置。在这里现在的配置是基于Zookeeper 3.4.6 版本的。如果读者在操作希望能和我的版本保持一致。</li></ul><h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><ul><li><p>了解kafka的都知道。kafka是通过Zookeeper实现分布操作的。不管是broker，consumer,还是provide信息都是存储在Zookeeper中的。当broker挂掉都是Zookeeper来进行重新分配选择的。所以实现kafka集群前我们得先实现Zookeeper的集群配置。</p></li><li><p>首先我们从官网上下载Zookeeper到本地。我这里下载的是Zookeeper-3.4.6.tar.gz版本的。读者可以根据自己情况下载。下载好之后进行文件解压。然后找到conf文件中的zoo_sample.cfg文件。该文件是Zookeeper官网给我们提供的一套样板。我们赋值该文件到同级下并改名为zoo.cfg.如下图</p></li></ul><p><img src="http://img.blog.csdn.net/20170331155731286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><font color="gray">然后我们来看看这个配置文件里面都有些啥</font><pre><code>tickTime=2000</code></pre><ul><li>服务器之间或客户端与服务端之间维持心跳的时间。就是每隔tickTime就会发送一次心跳。单位毫秒</li></ul><pre><code>initLimit=10</code></pre><ul><li>这个是配置Zookeeper接收客户端初始化连接最长能忍受initLimit心跳时间间隔。</li></ul><pre><code>syncLimit=5</code></pre><ul><li>Leader与follow之间发送消息和应答的时间 总时间=syncLimit*tickTime</li></ul><pre><code>dataDir</code></pre><ul><li>zookeeper数据保持路径 默认将log日志也保存在dataDir</li></ul><pre><code>dataLogDir</code></pre><ul><li>zookeeper log日志保存地址 不设置默认是dataDir</li></ul><pre><code>clientPort=2181</code></pre><ul><li>客户端连接的端口</li></ul><pre><code>server.1=192.168.1.130:28881:38881server.2=192.168.1.130:28882:38882server.3=192.168.1.130:28883:38883</code></pre><ul><li>因为我的集群都是在同一台电脑上配置的，所以这里端口不能一样</li></ul><hr><font color="gray">知道配置文件里的意思应该就知道如何修改了吧</font><ul><li>对于新手我们只需要该以下地方呢。</li></ul><pre><code>dataDir+dataLogDir+clientPort</code></pre><ul><li>但是下面的server是Zookeeper配置里需要重点讲解的部分<br>上面的格式我们可以简单的总结为 server.num=B:C:D。<br>num：是正整数代表的服务的唯一标识。这个要和后面说道的myid文件保持一致。</li></ul><p>B： 标识Zookeeper集群中某一个服务的ip或者域名 192.168.1.130</p><p>C：表示server.num这个服务于集群中leader进行信息交流的端口。在kafka中我们leader和follower需要进行数据备份。具体服务就是通过这个地方制定的端口进行通信的。</p><p>D：表示万一leader宕机了，我们就通过这个端口来进行再follower中选举新的leader。</p><h2 id="大坑预防"><a href="#大坑预防" class="headerlink" title="大坑预防"></a>大坑预防</h2><ul><li><p>网上的很多教程也就介绍到这里。稍微好点就提了一下创建myid文件的事，我当时就纠结在这里。因为我根本不知道穿件的myid的类型。我就随便创建txt文件。结果是错的。这里我们创建myid我有两种方式。还有myid里面的内容就是我们对应的配置文件中server.num中的num。</p></li><li><p>第一种就是我们通过cmd窗口到我们要创建myid的文件夹下<br>执行如下命令</p></li></ul><pre><code>echo 1 &gt; myid</code></pre><p><img src="http://img.blog.csdn.net/20170331161705249?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li><p>第二种是我们先创建TXT文件将对应的内容写入。然后txt后缀删掉就可以了。</p></li><li><p>顺便提一下myid应该放在我们conf/zoo.cfg文件中指定的dataDir 的对应的文件路径下。</p></li></ul><h1 id="服务开启"><a href="#服务开启" class="headerlink" title="服务开启"></a>服务开启</h1><ul><li><p>所谓的集群就是讲上面的Zookeeper复制成多个，将上面提到的几个重要的属性更改掉就行了。</p></li><li><p>如果你到这一步说明你离成功已经不远了。下面我们只需要开启服务就行了。开启服务在我们解压的bin目录下。</p></li></ul><p><img src="http://img.blog.csdn.net/20170331162134910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>这里我们得有些常识，已sh结尾的是Linux 系统的shell文件。在windows上没有装插件是无法使用的。我们windows认识的就是bat文件。就是上面的cmd结尾才是我们可以用的功能。但是我们还需要进行一下修改。其实这里已经可以了。我们到cmd窗口中通过该命令去执行我们zoo.cfg文件。但是为了方便我们这里讲zoo.cfg配置进我们的zkServer.cmd文件中</li></ul><p><img src="http://img.blog.csdn.net/20170331162449799?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>好了。配置完成。我们只需要每次点击zkServer.cmd就开启了Zookeeper中的服务了。</li></ul><h1 id="友情提醒"><a href="#友情提醒" class="headerlink" title="友情提醒"></a>友情提醒</h1><ul><li><p>上面我们配置的Zookeeper在开启第一个时候回报错。为什么呢。原因就是我们开启了一个服务，。但是我们的配置文件配置的是集群的信息。这个时候就回去寻找其他服务。但是这个时候其他的服务还没有开启呢。所以这个错误是正常。等我们集群中的所有的服务都开启了就不会报错。这里大家不要被吓到。</p></li><li><p>除此之外，还有一点就是Zookeeper的安装目录(解压目录)是绝对<font color="red">不能包含汉字</font>的。我上面的截图有汉字那是我计算机上设置的。实际的路径是没有汉字的。不要被上面的图片诱导。</p></li><li><p>当所有的服务都开启了，我们如何查看我们的服务是否开启成功呢。这很简单。我们重新打开一个新的cmd窗口。直接执行jps就可以看到我们的服务了。QuorumPeerMain就是我们的服务主类</p></li></ul><p><img src="http://img.blog.csdn.net/20170331163035162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="Kafka集群配置"><a href="#Kafka集群配置" class="headerlink" title="Kafka集群配置"></a>Kafka集群配置</h1><ul><li>上面我们就完成了Zookeeper的集群的配置。实际上Kafka中就自带有Zookeeper的服务。但是为了数据的高可用性。我们最好选择自己搭建Zookeeper集群。这也是官网上的建议。</li><li><p>这里我的Kafka版本选择的是0.8.1.1。建议单价不要选择太高的版本。刚出的版本可能有未知的bug。</p></li><li><p>同样这里的集群就是讲Kafka复制多个。这里我选择其中一个进行讲解。其他的都是一样的主要就是讲端口改掉就行了。</p></li><li><p>将官网下载的Kafka解压改名为kafka1（其他的改名数字递增就行。或者自定义别的名字）。找到config/server.properties文件。</p></li></ul><h2 id="server-properties修改"><a href="#server-properties修改" class="headerlink" title="server.properties修改"></a>server.properties修改</h2>  <font color="gray">同样的先来了解里面的参数含义吧</font><pre><code>broker.id=1</code></pre><ul><li>在kafka这个集群中的唯一标识，且只能是正整数</li></ul><pre><code>port=9091</code></pre><ul><li>该服务监听的端口</li></ul><pre><code>host.name=192.168.1.130</code></pre><ul><li>broker 绑定的主机名称(IP) 如果不设置将绑定所有的接口。</li></ul><pre><code>advertised.host.name=192.168.1.130</code></pre><ul><li>broker服务将通知消费者和生产者 换言之，就是消费者和生产者就是通过这个主机(IP)来进行通信的。如果没有设置就默认采用host.name。</li></ul><pre><code>num.network.threads=2</code></pre><ul><li>broker处理消息的最大线程数，一般情况是CPU的核数</li></ul><pre><code>num.io.threads=8</code></pre><ul><li>broker处理IO的线程数  一般是num.network.threads的两倍</li></ul><pre><code>socket.send.buffer.bytes=1048576</code></pre><ul><li>socket发送的缓冲区。socket调优参数SO_SNDBUFF</li></ul><pre><code>socket.receive.buffer.bytes=1048576</code></pre><ul><li>socket接收的缓冲区 socket的调优参数SO_RCVBUF</li></ul><pre><code>socket.request.max.bytes=104857600</code></pre><ul><li>socket请求的最大数量，防止serverOOM。</li></ul><pre><code>log.dirs=\logs</code></pre><ul><li>kafka数据的存放地址，多个地址的话用逗号隔开。多个目录分布在不同的磁盘上可以提高读写性能</li></ul><pre><code>num.partitions=2</code></pre><ul><li>每个tipic的默认分区个数，在创建topic时可以重新制定</li></ul><pre><code>log.retention.hours=168</code></pre><ul><li>数据文件的保留时间  log.retention.minutes也是一个道理。</li></ul><pre><code>log.segment.bytes=536870912</code></pre><ul><li>topic中的最大文件的大小 -1表示没有文件大小限制  log.segment.bytes 和log.retention.minutes 任意一个<br>达到要求 都会删除该文件  在创建topic时可以重新制定。若没有.则选取该默认值</li></ul><pre><code>log.retention.check.interval.ms=60000</code></pre><ul><li>文件大小检查的周期时间，是否处罚 log.cleanup.policy中设置的策略</li></ul><pre><code>log.cleaner.enable=false</code></pre><ul><li>是否开启日志清理</li></ul><pre><code>zookeeper.connect=192.168.1.130:num1,192.168.1.130:num2,192.168.1.130:num3</code></pre><ul><li>上面我们的Zookeeper集群</li></ul><pre><code>zookeeper.connection.timeout.ms=1000000</code></pre><ul><li>进群链接时间超时</li></ul><hr><ul><li>同样的我们每次赋值kafka服务我们只需该配置文件里的下面两个属性就行了。</li></ul><pre><code>broker.id  +  port</code></pre><h2 id="服务启动前的命令准备"><a href="#服务启动前的命令准备" class="headerlink" title="服务启动前的命令准备"></a>服务启动前的命令准备</h2><ul><li><p>同样的我们观察bin目录中我们会发现Kafka针对Linux和windows提供了不同的组件。windows的组件放在了windows的文件夹下了。但是我在实际操作中无法使用里面的命令。报一些错误。这里我的解决办法是将windows里的bat全部复制到外面。就是复制到bin目录下。<br><img src="http://img.blog.csdn.net/20170331165149109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>上图中指出来的bat原本是在windows文件中。拷贝到bin目录之后我们需要修改一下kafka-run-class.bat文件。因为里面写的相对路径和引入的jar会导致出错。所以我们将里面的这段代码</p></li></ul><pre><code>set ivyPath=%USERPROFILE%\.ivy2\cacheset snappy=%ivyPath%/org.xerial.snappy/snappy-java/bundles/snappy-java-1.0.5.jar     call :concat %snappy%set library=%ivyPath%/org.scala-lang/scala-library/jars/scala-library-2.8.0.jar     call :concat %library%set compiler=%ivyPath%/org.scala-lang/scala-compiler/jars/scala-compiler-2.8.0.jar     call :concat %compiler%set log4j=%ivyPath%/log4j/log4j/jars/log4j-1.2.15.jar     call :concat %log4j%set slf=%ivyPath%/org.slf4j/slf4j-api/jars/slf4j-api-1.6.4.jar     call :concat %slf%set zookeeper=%ivyPath%/org.apache.zookeeper/zookeeper/jars/zookeeper-3.3.4.jar     call :concat %zookeeper%set jopt=%ivyPath%/net.sf.jopt-simple/jopt-simple/jars/jopt-simple-3.2.jar     call :concat %jopt%for %%i in (%BASE_DIR%\core\target\scala-2.8.0\*.jar) do (     call :concat %%i)for %%i in (%BASE_DIR%\core\lib\*.jar) do (     call :concat %%i)for %%i in (%BASE_DIR%\perf\target\scala-2.8.0/kafka*.jar) do (     call :concat %%i)</code></pre><ul><li>替换成</li></ul><pre><code>for %%i in (%BASE_DIR%\libs\*.jar) do (     call :concat %%i)</code></pre><ul><li>我们仔细观察原来的配置大概意思是引入一些jar包啥的。但是会出现有的时候我们的文件根本没有那个jar。但是又引入了。会经常报错。所以我们改成引入libs下的所有jar.有啥就引入啥。这样就不会报错的。</li></ul><h2 id="大坑预防-1"><a href="#大坑预防-1" class="headerlink" title="大坑预防"></a>大坑预防</h2><ul><li>到这里我原本天真的认为就已经完事了。但是谁知我按照网上的教程继续的时候就出现如下错误</li></ul><p><img src="http://img.blog.csdn.net/20170331165700492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>首先第一行提示 set JMX_PORT to default value 9999 这个错误是因为我没有设置这个值。这倒是小事。但是后面报说找不到或无法加载主类kafka.Kafka这就让我费解。在这里我也是卡了一天了。后来在网上找到了一个方法。我不知道这是不是Kafka的bug。反正用这个方法我是解决了这个错误了。</li></ul><ul><li>解决办法就是将kafka-run-class.bat文件中</li></ul><pre><code>set COMMAND= %JAVA% %KAFKA_OPTS% %KAFKA_JMX_OPTS% -cp %CLASSPATH% %*</code></pre><ul><li>修改为</li></ul><pre><code>set COMMAND= %JAVA% %KAFKA_OPTS% %KAFKA_JMX_OPTS% -cp &quot;%CLASSPATH%&quot; %*</code></pre><ul><li>对比我们发现就是将classpath加上双引号。搞了半天就是系统变量路径没有找到的原因。不过这个问题值得引起我们的注意。我们的kafka寄去你的搭建实在Java 的jdk基础是搭建的。所以前提我们得将jdk等这些配置到环境变量中去。这里的配置网上搜去吧很多。</li></ul><h2 id="服务开启-1"><a href="#服务开启-1" class="headerlink" title="服务开启"></a>服务开启</h2><ul><li><p>到这一步我们离kafka的成功又不远了。我们新开cmd窗口cd到kafka的bin目录中。</p></li><li><p>但是在执行开启之前我们需要先执行</p></li></ul><pre><code>Set JMX_PORT=19091(每个服务数字不能一样)</code></pre><ul><li>然后在执行</li></ul><pre><code>kafka-server-start.bat ..\config\server.properties</code></pre><h2 id="创建Topic批处理"><a href="#创建Topic批处理" class="headerlink" title="创建Topic批处理"></a>创建Topic批处理</h2><ul><li>官网上是没有提供windows版本的topic处理程序的。我们需要自己新建一个bat文件。这个bat文件的内容填写如下</li></ul><pre><code>kafka-run-class.bat  kafka.admin.TopicCommand  %*</code></pre><p><img src="http://img.blog.csdn.net/20170331170713381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><ul><li>有了这个批处理我们就可以通过它实现topic的创建。生产者发送消息和消费者的接收消息</li></ul><font face="楷体" color="red">创建Topic</font><ul><li>replication-factor：表示该topic需要在不同的broker中保存</li><li>partitions ： 对该top的分区数量</li><li>topic  ： 该top的名称。建议指定。否则采用默认<pre><code>kafka-topics.bat --create --zookeeper 192.168.1.130:2181 --replication-factor 2 --partitions 3 --topic my-replicated-topic</code></pre></li></ul><font face="楷体" color="red">查看Topic</font><pre><code>kafka-topics.bat --describe --zookeeper 192.168.1.130:2181 --topic my-replicated-topic</code></pre><font face="楷体" color="red">生产topic消息 </font><pre><code>kafka-console-producer.bat --broker-list 192.168.1.130:9093 --topic my-replicated-topic</code></pre><font face="楷体" color="red">消费topic消息 </font><pre><code>kafka-console-consumer.bat --zookeeper 192.168.1.130:2181 --from-beginning --topic my-replicated-topic</code></pre><ul><li>最后在接收发送消息是我们需要重新创建新的cmd窗口。下面看看效果图。最终实现实时接收消息</li></ul><p><img src="http://img.blog.csdn.net/20170331174451934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><font color="blue">资源由于大小限制暂时无法上传！后续再上传</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kafka是一种高吞吐量的分布式发布订阅的消息队列系统&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>大话 Spring Session 共享</title>
    <link href="https://zxhtom.oschina.io/zxh/20170401.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170401.html</id>
    <published>2017-04-01T01:56:00.000Z</published>
    <updated>2018-01-18T13:15:10.062Z</updated>
    
    <content type="html"><![CDATA[<p>javaweb中我们项目稍微正规点<br><a id="more"></a></p><pre><code>javaweb中我们项目稍微正规点，都会用到单点登录这个技术。实现它的方法各家有各界的看法。这几天由于公司项目需求正在研究。下面整理一下最近整理的心得。</code></pre><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>在分布式项目中另我们头疼的是多项目之间的数据共享(即Session共享)，经常会出现数据丢失的情况。为了解决这种Bug。前人已经把我们实现了两种解决的办法。今天我在这里一下这两种方式。侧重偏向第二种方法</li></ul><h1 id="配tomcat实现session共享"><a href="#配tomcat实现session共享" class="headerlink" title="配tomcat实现session共享"></a>配tomcat实现session共享</h1><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p><a href="http://download.csdn.net/detail/u013132051/9793434" target="_blank" rel="noopener">点我下载</a></p><hr><h2 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h2><ul><li><p>下载好上面的jar包，把他放在tomcat的lib文件下。</p><p><img src="http://img.blog.csdn.net/20170325143631803?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>然后修改Tomcat里的conf/context.xml文件</p></li></ul><pre><code>&lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt;  &lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;  host=&quot;192.168.1.130&quot;   port=&quot;7006&quot;   database=&quot;db0&quot;   maxInactiveInterval=&quot;60&quot; /&gt;</code></pre><ul><li>上面配置的host和port就是我们redis的host和port，所以在此之前我们需要先开启一个redis服务出来。<br><a href="http://blog.csdn.net/u013132051/article/details/53764042" target="_blank" rel="noopener">点我查看如何配置redis(本文配置集群，配置单节点一样)</a><br><a href="http://blog.csdn.net/u013132051/article/details/53765344" target="_blank" rel="noopener">点我查看如何配置redis和spring的整合</a><br><a href="http://blog.csdn.net/u013132051/article/details/54584180" target="_blank" rel="noopener">点我查看如何配置redis中你遇到的问题汇总</a></li></ul><ul><li>database就是讲该tomcat与浏览器会话时产生的session存放在redis中的位置</li></ul><p><img src="http://img.blog.csdn.net/20170325144239743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>maxInactiveInterval 就是设置缓存的过期时间。但是在实际测试中我发现这个属性并没有发生作用。(你有啥见解欢迎点评)</li></ul><font color="blue" face="楷体">到这里我们的第一个Tomcat配置完成。下面就是重复上面的步骤多配制几个Tomcat</font><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><ul><li>nginx功能丰富，可以作为HTTP服务器，也可以作为反向代理的服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。</li><li><p>nginx的下载官网有现成的，直接下载符合自己电脑的版本傻瓜式安装就行了。(<font color="red" face="楷体">安装或者解压不要出现中文</font>)</p></li><li><p>找到conf/nginx.conf文件在里面修改设置</p><ul><li>listen       802： 我们监听的端口</li><li>server_name  192.168.1.130：监听的地址</li><li>proxy_pass <a href="http://mynginxserver：根据情况跳转最后的连接" target="_blank" rel="noopener">http://mynginxserver：根据情况跳转最后的连接</a></li><li>在mynginxserver配置多个Tomcat：</li></ul></li></ul><pre><code>upstream mynginxserver {            server 192.168.1.78:8080 weight=1;            server 192.168.1.130:8080 weight=1;        }</code></pre><ul><li>完成配置</li></ul><pre><code>upstream mynginxserver {        server 192.168.1.78:8080 weight=1;        server 192.168.1.130:8080 weight=1;    }    server {        listen       802;        server_name  192.168.1.130;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            proxy_pass http://mynginxserver;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ {        #    proxy_pass   http://127.0.0.1;        #}        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ {        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #}        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ /\.ht {        #    deny  all;        #}    }</code></pre><ul><li>这个时候当我们两个Tomcat都在运行状态我们浏览器中输入</li></ul><pre><code>192.168.1.130:802</code></pre><ul><li>nginx就会随机选择一个Tomcat来运行了。同时这两个Tomcat的session是共享的。就是说A Tomcat的session B 可以用。就算A 宕机了B也照样按到A的session。</li></ul><hr><h1 id="配spring-session实现session共享"><a href="#配spring-session实现session共享" class="headerlink" title="配spring session实现session共享"></a>配spring session实现session共享</h1><ul><li>上面的一种方式我也是在网上案列操作的。在自己的项目中并不适合。因为我的项目中配置的是redis集群(非sentinel).所以在Tomcat里面配置是不行的。<br><font color="blue" face="楷体">解释：</font>第一种方式配置的redis默认是单节点的redis。也就是我们的session会产生sessionID作为redis中key存在我们配置redis节点的库上面。但是如果我们是redis集群的话，集群会将根据key值算出slot值，在根据slot值决定存取在哪一台redis服务商。也就是说在存session前我们根本不知道会存在哪一台redis上。所以这种方法不适合于redis集群。</li></ul><p>具体看看我画的思维导图吧：</p><p><img src="http://img.blog.csdn.net/20170325151422103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>第二章明显出错了，事实上并没有存储在实现约定的redis上</p><p><img src="http://img.blog.csdn.net/20170325152606702?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><h2 id="spring-session-配置"><a href="#spring-session-配置" class="headerlink" title="spring session 配置"></a>spring session 配置</h2><ul><li>说了这么多了，我们下面开始讲解spring中集成的session共享配置。首先如果你是maven项目那么直接引入jar</li></ul><pre><code>&lt;dependency&gt;                                                    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;&lt;artifactId&gt;spring-session&lt;/artifactId&gt;&lt;version&gt;1.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>若果你不是maven项目，那么就麻烦你自己去下载这些相关的jar包。</li></ul><pre><code>spring-data-redis.jarredis.clients.jarspring-session.jar</code></pre><ul><li>同样这里你需要一下几篇文章来配置redis集群<br><a href="http://blog.csdn.net/u013132051/article/details/53764042" target="_blank" rel="noopener">点我查看如何配置redis</a><br><a href="http://blog.csdn.net/u013132051/article/details/53765344" target="_blank" rel="noopener">点我查看如何配置redis和spring的整合</a><br><a href="http://blog.csdn.net/u013132051/article/details/54584180" target="_blank" rel="noopener">点我查看如何配置redis中你遇到的问题汇总</a></li></ul><h2 id="spring配置文件配置"><a href="#spring配置文件配置" class="headerlink" title="spring配置文件配置"></a>spring配置文件配置</h2><ul><li><p>有了上面的准备资料后，我们可以在是spring的配置文件中配置spring session了</p></li><li><p>很简单我们需要引入spring session中的bean</p></li></ul><pre><code>&lt;bean class=&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;&gt;</code></pre><ul><li>在spring的配置文件中我们只需要配置这一个bean就可以了。下面离将session共享到redis集群上只差一步了。就是在web.xml文件中配置拦截器</li></ul><pre><code>&lt;filter&gt;    &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;      &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><ul><li>到这里配置完成了，我们可以重启我们的项目运行一下存取session的部分。然后再去redis集群找看看有没有session。在redis中默认的session的key是<code>spring:session:sessions:c0d1fadd-b04a-4244-9525-0f13ea7173bf</code>。其中后面一串id就是我们Tomcat和浏览器会话时差生的sessionid。</li></ul><p><img src="http://img.blog.csdn.net/20170325153910006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>在上面我们配置spring session 已经可以实现了session共享了。但是细心的朋友可以发现。session并没有真正意义上的共享。上面我们可以看到session在redis集群中的key包含了Tomcat和浏览器的sessionid。也就是说redis上这个session只能是我的这个Tomcat在该浏览器上才可以访问到。别的Tomcat就算和同一个浏览器交互也是拿不到redis上这个session的。这种效果是你们想要的吗。答案并不是。上面实现的效果我用一幅图描述一下。<br><img src="http://img.blog.csdn.net/20170325154948709?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>也就是说上面我的配置只是将Tomcat的session转移到了redis上。多服务的session仍然是各区各的。这是一个大坑。坑了好久。然后我想了另外一种办法现在可以解决这个局限性。</p></li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>解决上面的问题。这里我提供三种思路。三种思路我都实现了一下。各有利弊。最后决定采用第三种比较靠谱。</li></ul><p>1– 重写spring session源码，重写里面讲session存储在redis那部分代码，主要就是为了将redis 中session的key写成固定值。以后我们在去session中取这个固定的key就可以实现session共享了。</p><p>2–只重写spring session中我们的session仓库中去的策略，就是在A项目登录后将产生的sessionID传递给B项目。B项目在根据这个sessionid去redis中获取。</p><font color="blue" face="楷体">上面两中方法需要自定义很多类，整理了自定义的类和配置文件的配置。<a href="http://download.csdn.net/detail/u013132051/9793521" target="_blank" rel="noopener">点我下载</a></font><p>3– 在向session中存值的地方，将sessionid作为value，请求头中的Host和Agent组合最为key存储在redis上。然后我们在spring session去session的方法里在根据Host和Agent组成的key去获取sessionid，然后就可以获取对应的session了。</p><h2 id="存取策略重构"><a href="#存取策略重构" class="headerlink" title="存取策略重构"></a>存取策略重构</h2><ul><li>这里主要讲解一下第三种的实现步骤。首先我新建一个类用来读取request求情头中的host和agent拼接的key值。</li></ul><pre><code>public static Map&lt;String, Object&gt; getInfoFromUrl(HttpServletRequest request)    {        Map&lt;String, Object&gt; resultMap=new HashMap&lt;String, Object&gt;();        String Agent = request.getHeader(&quot;User-Agent&quot;);         String Host = request.getHeader(&quot;Host&quot;);         resultMap.put(&quot;agent&quot;, Agent);        resultMap.put(&quot;host&quot;, Host);        return resultMap;    }     public static String getKeyFromUrl(HttpServletRequest request)    {        String result=&quot;&quot;;        Map&lt;String, Object&gt; map = getInfoFromUrl(request);        Set&lt;String&gt; keySet = map.keySet();        for (String key : keySet)        {            result+=map.get(key).toString();        }        return result;    }</code></pre><ul><li>然后在我们调用session存值的地方，也就是登录的地方。通过我们项目中的redis操作类将其存储起来。</li></ul><p><img src="http://img.blog.csdn.net/20170325162342669?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>然后我们修改spring session中的cookie仓库中的去request的sessionid的策略</li></ul><p><img src="http://img.blog.csdn.net/20170325162456412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>最后我们在spring的配置中修改是spring session的策略为我么你的cook策略</li></ul><pre><code>&lt;bean id=&quot;redisCacheTemplate&quot; class=&quot;com.bshinfo.web.base.cache.RedisCacheTemplate&quot;/&gt;    &lt;bean id=&quot;zxh&quot; class=&quot;com.bshinfo.web.base.cache.CookieHttpSessionStrategyTest&quot;&gt;        &lt;property name=&quot;redisCacheTemplate&quot; ref=&quot;redisCacheTemplate&quot; /&gt;    &lt;/bean&gt;     &lt;bean class=&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;&gt;          &lt;property name=&quot;httpSessionStrategy&quot; ref=&quot;zxh&quot;/&gt;         &lt;property name=&quot;maxInactiveIntervalInSeconds&quot; value=&quot;60&quot;/&gt;     &lt;/bean&gt;</code></pre><ul><li>最后就实现了我们的效果。效果就是A项目在X浏览器上登录后。B项目在X浏览器获取session的用户可以正常获取。否则获取失败。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javaweb中我们项目稍微正规点&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>通过注解实现通用导出Excel</title>
    <link href="https://zxhtom.oschina.io/zxh/20170322.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170322.html</id>
    <published>2017-03-22T09:57:00.000Z</published>
    <updated>2018-01-18T13:15:10.066Z</updated>
    
    <content type="html"><![CDATA[<p>Javaweb开发中数据的导入导出很常见<br><a id="more"></a></p><pre><code>Javaweb开发中数据的导入导出很常见，每次我们都需要写很多代码，所以我就在想能不能写一些通用的方法，之前已经在网上整理过一些通用的方法，最近在网上看到一位牛人封装的更加简介，自己拿过来整理了一下。</code></pre><h2 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h2><ul><li>之前我们了解了<a href="http://blog.csdn.net/u013132051/article/details/58049085" target="_blank" rel="noopener">Java注解的使用</a>,现在我们正是通过注解的方式来简化javaweb中繁琐的Excel上传和下载两个功能。由于时间有限今天先实现了Excel的下载(Excel 导出)。</li></ul><p><img src="http://img.blog.csdn.net/20170322172750536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>上面的就是我们的注解类的简化图。参数的意思分别是指定表头的名字+表头所占列宽度+该列是否明文显示+加密显示的方式+特殊文本的格式</li></ul><h2 id="数据实体类"><a href="#数据实体类" class="headerlink" title="数据实体类"></a>数据实体类</h2><ul><li>有了上面的注解我们的实体类非常的简单，只是在我们平常建的Javabean的属性字段上加上我们刚才的注解就行了。</li></ul><p><img src="http://img.blog.csdn.net/20170322173234758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>其中ExportConfig注解中的属性值我们可以不设置，不设置就是默认的。这里设置完成后就开始写导出了。</li></ul><h2 id="Excel导出"><a href="#Excel导出" class="headerlink" title="Excel导出"></a>Excel导出</h2><ul><li>现在该如何获取我们的注解呢，之前的文章已经介绍了。我们得首先获得我们的Javabean的字段。</li></ul><pre><code>for (Field field : _class.getDeclaredFields())</code></pre><ul><li>可能会出现我们的Javabean的数据并不是完全的查出来了。所以这里我们得先看看这个字段到底有没有值。</li></ul><pre><code>property = BeanUtils.getProperty(data.get(0), field.getName());</code></pre><ul><li>在有值得前提下我们在获取字段的注解。</li></ul><pre><code>ExportConfig config = field.getAnnotation(ExportConfig.class);</code></pre><ul><li>最后我们开始讲注解的信息存在到信息类上ExportItem.java</li></ul><pre><code>items.add(new ExportItem.$Build()                            .setField(field.getName())                            .setDisplay(                                    &quot;field&quot;.equals(config.value()) ? field                                            .getName() : config.value())                            .setWidth(config.width())                            .setIsExport(config.isExport())                            .setContent(config.blankContent())                            .setFieldTypeName(field.getClass().getSimpleName())                            .setFormat(config.format())                            .create());</code></pre><ul><li>ExportItem 类也很简单。里面拷贝了自身的一个类实现了链式操作。这里没什么讲解的。到这里我们的表头显示设置已经完成了。下面自然就是遍历list集合数据了。当然遍历之前先设置表头样式。</li></ul><pre><code>ExportItem exportItem = items.get(index);// 首先创建该行指定列的单元格Cell cell = headRow.createCell(index);sheet.setColumnWidth(index, (short) (exportItem.getWidth() * 35.7));cell.setCellValue(exportItem.getDisplay());CellStyle style = handler.getHeadCellStyle(wb);if (style != null){    cell.setCellStyle(style);}</code></pre><ul><li>在设置表身的时候我们得先去注解信息类中拿到该列显示的风格(是否是明文)。</li></ul><pre><code>if (exportItem.getIsExport())</code></pre><ul><li>在设置了内容之后我们还要根据注解的单元格格式进行样式的设置</li></ul><pre><code>setStyleByType(wb,exportItem.getFormat());</code></pre><h2 id="Excel输出"><a href="#Excel输出" class="headerlink" title="Excel输出"></a>Excel输出</h2><pre><code> fileName += getExcelSuffix(type);                _response.setContentType(getContentType(type));                _response.setHeader(                        &quot;Content-disposition&quot;,                        &quot;attachment; filename=&quot;                                + new String(fileName.getBytes(&quot;gbk&quot;), &quot;iso8859-1&quot;));                if (out == null)                {                    out = _response.getOutputStream();                }                wb.write(out);                out.flush();                out.close();</code></pre><h2 id="所需jar"><a href="#所需jar" class="headerlink" title="所需jar"></a>所需jar</h2><pre><code>log4j-1.2.17.jar 日志jar包servlet-api.jar  正常在web项目中都不需要引入该jar包poi-3.9.jar      操作表格jar包pi-ooxml-3.12.jar XSSFWorkbook 处理2007版本及以上的excel</code></pre><h2 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h2><pre><code>List&lt;ExcelUser&gt; list = adminManageServiceI.getUsers(ConstantUtil.ADMIN_ID);// 生成Excel并使用浏览器下载ExcelTool.$Brower(ExcelUser.class, response).toExcel(list, &quot;用户信息&quot;);</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="http://img.blog.csdn.net/20170322175157016?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><font color="blue" face="楷体">源码正在更新，导入导出全部完成在上传源码。</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javaweb开发中数据的导入导出很常见&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>bootstrape select使用小结</title>
    <link href="https://zxhtom.oschina.io/zxh/20170318.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170318.html</id>
    <published>2017-03-18T07:03:00.000Z</published>
    <updated>2018-01-18T13:15:10.056Z</updated>
    
    <content type="html"><![CDATA[<p>看看上面的效果是bootstrape使用的效果。虽然不是很好看，但是符合bootstrape的风格。来看看普通的select的样式<br><a id="more"></a></p><p><img src="http://img.blog.csdn.net/20170317140240579?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p>看看上面的效果是bootstrape使用的效果。虽然不是很好看，但是符合bootstrape的风格。来看看普通的select的样式</p><hr><p><img src="http://img.blog.csdn.net/20170317140653612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>bootstrape下的select和普通select在bootstrape风格对比</p><p><img src="http://img.blog.csdn.net/20170317140812523?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p><img src="http://img.blog.csdn.net/20170317140840363?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li>首先我们肯定得引入jQuery和bootstrape的相关js和css，在此基础上我们引入两个东西</li></ul><pre><code>bootstrap-select.min.cssbootstrap-select.min.jscomponents-bootstrap-select.min.js</code></pre><h2 id="页面书写"><a href="#页面书写" class="headerlink" title="页面书写"></a>页面书写</h2><p><img src="http://img.blog.csdn.net/20170317141607898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>其中class属性必须包含bs-select ,且select属性中含有一下属性</li></ul><pre><code>data-live-search（必须）data-size=&quot;6&quot;（可选）id（必须）</code></pre><ul><li><p>data-live-search 是用于搜索的，本章搜索没实现，以后再详细设计，但是这个属性必须有。源码里根据他选择搜索的。</p></li><li><p>data-size 是设置数字，意思就是下拉框内容超过几条是开始出现滚动条。</p></li><li><p>id用于识别这个下拉框的</p></li></ul><h2 id="Ajax请求加载select数据"><a href="#Ajax请求加载select数据" class="headerlink" title="Ajax请求加载select数据"></a>Ajax请求加载select数据</h2><ul><li>项目中的select多数情况下都是动态数据加载的，那么下一步开始讨论动态数据的加载问题。首先肯定是发送请求。然后在ajax请求成功后的回调地方处理我们的动态数据加载问题。</li></ul><pre><code>//调用公共插值方法createSelectDate(siteDate,&quot;site_id&quot;);</code></pre><h1 id="createSelectDate"><a href="#createSelectDate" class="headerlink" title="createSelectDate"></a>createSelectDate</h1><ul><li>这个方法我们需要传入两个参数，第一个是我们需要加载的数据，第二个使我们的数据加载在select的id</li></ul><ul><li>在来看看经过处理后我们的select</li></ul><p><img src="http://img.blog.csdn.net/20170317143657925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>仔细观察发现ul  是页面显示的数据，select是我们真正的数据，所以我们只需要向这两个地方填充数据就行了。</li></ul><p><img src="http://img.blog.csdn.net/20170317144334334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20170317144348693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>向select加入数据很简单，通过ID加入，<br><img src="http://img.blog.csdn.net/20170317144608803?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>关键是如何获取新的select即ul,经过实践通过以下方法就行。</li></ul><pre><code>var $selectUl = $($($(&quot;button[data-id=&#39;&quot;+select_id+&quot;&#39;]&quot;).parent().children().get(1)).children().get(1));</code></pre><ul><li>然后向新的对象添加内容</li></ul><pre><code>$newSelect.append(&quot;&lt;li data-original-index=&quot;+(index+1)+&quot; class&gt;&lt;a tabindex=&#39;0&#39; class style data-tokens=&#39;null&#39; role=&#39;option&#39; aria-disabled=&#39;false&#39; aria-selected=&#39;false&#39;&gt;&lt;span class=&#39;text&#39;&gt;&quot;+value.site_name+&quot;&lt;/span&gt;&lt;span class=&#39;fa fa-check check-mark&#39;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&quot;);</code></pre><h2 id="清空select选中值"><a href="#清空select选中值" class="headerlink" title="清空select选中值"></a>清空select选中值</h2><ul><li>用了这个之后我们会遇到问题，我们无法清空新select的内容，这就很尴尬。研究半天决定强行删除</li></ul><pre><code>$(&quot;button[role=&#39;button&#39;][data-id=&#39;&quot;+select_id+&quot;&#39;]&quot;).attr(&quot;title&quot;,&quot;请选择...&quot;);//selected active    $(&quot;button[role=&#39;button&#39;][data-id=&#39;&quot;+select_id+&quot;&#39;] span:first&quot;).text(&quot;请选择...&quot;);</code></pre><p>最后我们只需要调用相应的方法就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看看上面的效果是bootstrape使用的效果。虽然不是很好看，但是符合bootstrape的风格。来看看普通的select的样式&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jquery验证大全</title>
    <link href="https://zxhtom.oschina.io/zxh/20170310.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170310.html</id>
    <published>2017-03-10T14:15:00.000Z</published>
    <updated>2018-01-18T13:15:10.060Z</updated>
    
    <content type="html"><![CDATA[<p>jQuery验证及限制<br><a id="more"></a></p><h1 id="jQuery验证及限制"><a href="#jQuery验证及限制" class="headerlink" title="jQuery验证及限制"></a>jQuery验证及限制</h1><h2 id="绑定键盘监听事件"><a href="#绑定键盘监听事件" class="headerlink" title="绑定键盘监听事件"></a>绑定键盘监听事件</h2><pre><code>    $(document).on(&quot;keypress&quot;, &quot;.txt-valid-len&quot;, function (e)     {        return (this.value.length &lt; $(this).attr(&quot;maxlength&quot;));    });</code></pre><h2 id="输入框设置"><a href="#输入框设置" class="headerlink" title="输入框设置"></a>输入框设置</h2><ul><li>然后我们只需要在input中添加txt-valid-len这个class属性。并且加入maxlength属性指定长度就可以了。</li></ul><pre><code>&lt;input type=&quot;text&quot; id=&quot;user_name&quot; name=&quot;name&quot; class=&quot;form-control txt-valid-len&quot; maxlength=&quot;11&quot; /&gt;</code></pre><ul><li>上面的代码的意思就是这个输入框长度限制在11位，超过11位就不显示了。如果想在超过11位进行提示。可以扩展上面的监听事件。</li></ul><hr><h1 id="jquery表单提交验证"><a href="#jquery表单提交验证" class="headerlink" title="jquery表单提交验证"></a>jquery表单提交验证</h1><ul><li>在开发中我们前台经常需要在与后台交互前进行相关数据的验证。这样可以减少服务端的压力。下面我们来看看jquery给我们提供的表单验证的方法。</li></ul><h2 id="引入脚本文件"><a href="#引入脚本文件" class="headerlink" title="引入脚本文件"></a>引入脚本文件</h2><pre><code>jquery.min.jsjquery.validate.js</code></pre><ul><li><p>这两个js在官网的jQuery中都是包含的，直接下载引入就行了。</p></li><li><p>有了这两个js我们还需要页面上的form表单。表单就是我们平常的表单。</p></li></ul><pre><code>&lt;form id=&quot;myform&quot; method=&quot;post&quot; action=&quot;#&quot;&gt;      &lt;p&gt;          &lt;label for=&quot;myname&quot;&gt;用户名：&lt;/label&gt;          &lt;!-- id和name最好同时写上 --&gt;          &lt;input  id=&quot;myname&quot; name=&quot;myname&quot; /&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label for=&quot;age&quot;&gt;年龄：&lt;/label&gt;          &lt;input id=&quot;age&quot; name=&quot;age&quot; /&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label for=&quot;email&quot;&gt;E-Mail：&lt;/label&gt;          &lt;input id=&quot;email&quot; name=&quot;email&quot; /&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label for=&quot;password&quot;&gt;登陆密码：&lt;/label&gt;          &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; /&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label for=&quot;confirm_password&quot;&gt;确认密码：&lt;/label&gt;          &lt;input  name=&quot;confirm_password&quot; type=&quot;password&quot; /&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;立即注册&quot; /&gt;      &lt;/p&gt;&lt;/form&gt;</code></pre><h2 id="自定义js实现表单验证-利用jQuery提供内置方法"><a href="#自定义js实现表单验证-利用jQuery提供内置方法" class="headerlink" title="自定义js实现表单验证(利用jQuery提供内置方法)"></a>自定义js实现表单验证(利用jQuery提供内置方法)</h2><ul><li>首先我们通过jQuery提供的选择器找到我们需要验证的表单</li></ul><pre><code>$(&quot;#myform&quot;).validate();</code></pre><ul><li>就这样我们就完成了表单验证。当然啦，到这里只是架子打好了。下面我们开始在validate中填写我们的验证规则了。</li></ul><pre><code>$(&quot;#myform&quot;).validate({        debug: true, //调试模式取消submit的默认提交功能           //errorClass: &quot;label.error&quot;, //默认为错误的样式类为：error           focusInvalid: false, //当为false时，验证无效时，没有焦点响应          onkeyup: false,           submitHandler: function(form){   //表单提交句柄,为一回调函数，带一个参数：form               alert(&quot;提交表单&quot;);               form.submit();   //提交表单           },           rules:{            myname:{                required:function(element){                    if( $(&quot;#age&quot;).val() &lt; 13){                        return true;                    }                    else{                        return false;                    }                }            },            email:{                required:true,                email:true            },            password:{                required:true,                rangelength:[3,10]            },            confirm_password:{                equalTo:&quot;input[name=password]&quot;            }                            },        messages:{            myname:{                required:&quot;必填&quot;            },            email:{                required:&quot;&lt;span style=&#39;color:red;&#39;&gt;只允许输入整数。&lt;/span&gt;&quot;,                email:&quot;E-Mail格式不正确&quot;            },            password:{                required: &quot;不能为空&quot;,                rangelength: $.validator.format(&quot;密码最小长度:{0}, 最大长度:{1}。&quot;)            },            confirm_password:{                equalTo:&quot;两次密码输入不一致&quot;            }                                            }    });</code></pre><ul><li>其中的rules就是我们验证规则内容。其中的myname,email…是我们form需要验证的控件的name属性值(并不是ID属性值)，还有我们的提示信息可以做的花哨一点加入样式</li></ul><pre><code>&lt;span style=&#39;color:red;&#39;&gt;只允许输入整数。&lt;/span&gt;</code></pre><ul><li>至于这些验证规则我们可以在jquery-validate.js中找到。里面messages属性的提示信息我们都是可以用来做验证的.</li></ul><h3 id="动态决定验证规则"><a href="#动态决定验证规则" class="headerlink" title="动态决定验证规则"></a>动态决定验证规则</h3><ul><li>上面的myname的required的验证是根据id=age的input框的值得变化决定的，就是说你输入的年龄小于13岁myname是需要验证的。大于则反之。如果你想做的像更美化我们可以在年龄input中绑定一个失去焦点的时间(blur)，在输入完年龄我们就立马去验证myname的input框的规则，通过调用<pre><code>$(&quot;#myname&quot;).valid();</code></pre></li><li>就会去按照我们的规则去验证myname这个字段的input的值。</li></ul><h3 id="通过远程进行验证"><a href="#通过远程进行验证" class="headerlink" title="通过远程进行验证"></a>通过远程进行验证</h3><h4 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h4><ul><li>对上面的进行如下的修改，其中remote就是我们的远程请求，该请求返回的true,则验证通过，false反之。</li></ul><pre><code>$(&quot;#myform&quot;).validate({    rules: {      email: {        required: true,      email: true,      remote: {          type:&quot;post&quot;,          dataType: &quot;json&quot;,          contentType : &quot;application/json&quot;,          url:&quot;/adminManage/email.bsh&quot;      }      }    }  });</code></pre><h4 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h4><ul><li>这的注意的是remote这里的请求格式有些要求，这个url返回的数据必须是json格式的。但是后台只能返回string或者boolean类型的数据。如果返回的是string内容的json，那么string是true则验证通过，若果不是true则验证提示就是你返回的string内容。如果是boolean，是true则验证通过，false验证失败。</li></ul><pre><code>@RequestMapping(&quot;/email.bsh&quot;)    @ResponseBody    public Object email(HttpServletRequest request,HttpServletResponse response)     {        return &quot;已经存在&quot;;    }</code></pre><ul><li>前台提示已经存在，会覆盖前台默认的提示内容</li></ul><pre><code>@RequestMapping(&quot;/email.bsh&quot;)@ResponseBodypublic Object email(HttpServletRequest request,HttpServletResponse response) {    return &quot;true&quot;;}</code></pre><ul><li>验证通过</li></ul><pre><code>@RequestMapping(&quot;/email.bsh&quot;)@ResponseBodypublic Object email(HttpServletRequest request,HttpServletResponse response) {    return true;}</code></pre><ul><li><p>验证通过</p><pre><code>@RequestMapping(&quot;/email.bsh&quot;)@ResponseBodypublic Object email(HttpServletRequest request,HttpServletResponse response) {return false;}</code></pre></li><li>验证失败，前台将提示默认的信息</li></ul><hr><p><a href="http://koalaxyq.iteye.com/blog/557521" target="_blank" rel="noopener">参考网址</a></p><h2 id="验证提示信息的显示位置"><a href="#验证提示信息的显示位置" class="headerlink" title="验证提示信息的显示位置"></a>验证提示信息的显示位置</h2><ul><li>在上面一节我们详细介绍了验证的规则及提示实现。那么提示信息的位置有时候也是很重要的，我们控制的好的话界面会很美观的。</li></ul><pre><code>var validator = $(&quot;#myform&quot;).validate({          debug: true,       //调试模式取消submit的默认提交功能          errorClass: &quot;haha&quot;,//默认为错误的样式类为：error          focusInvalid: false,          onkeyup: false,          submitHandler: function(form){   //表单提交句柄,为一回调函数，带一个参数：form              alert(&quot;提交表单&quot;);              //form.submit();   提交表单          },          rules: {           //定义验证规则,其中属性名为表单的name属性              username: {                  required: true,                  minlength: 2,                  remote: &quot;uservalid.jsp&quot;  //传说当中的ajax验证              },              firstpwd: {                  required: true,                  //minlength: 6                  rangelength: [6,8]              },              secondpwd: {                  required: true,                  equalTo: &quot;#password&quot;              },              sex: {                  required: true              },              age: {                  required: true,                  range: [0,120]              },              email: {                  required: true,                  email: true              },              purl: {                  required: true,                  url: true              },              afile: {                  required: true,                  accept: &quot;xls,doc,rar,zip&quot;              }          },          messages: {       //自定义验证消息              username: {                  required: &quot;用户名是必需的！&quot;,                  minlength: $.format(&quot;用户名至少要{0}个字符！&quot;),                  remote: $.format(&quot;{0}已经被占用&quot;)              },              firstpwd: {                  required: &quot;密码是必需的！&quot;,                  rangelength: $.format(&quot;密码要在{0}-{1}个字符之间！&quot;)              },              secondpwd: {                  required: &quot;密码验证是必需的！&quot;,                    equalTo: &quot;密码验证需要与密码一致&quot;              },              sex: {                  required: &quot;性别是必需的&quot;              },              age: {                  required: &quot;年龄是必需的&quot;,                  range: &quot;年龄必须介于{0}-{1}之间&quot;              },              email: {                  required: &quot;邮箱是必需的！&quot;,                  email: &quot;请输入正确的邮箱地址（例如 myemail@163.com）&quot;              },              purl: {                  required: &quot;个人主页是必需的&quot;,                  url: &quot;请输入正确的url格式,如 http://www.domainname.com&quot;              },              afile: {                  required: &quot;附件是必需的！&quot;,                  accept: &quot;只接收xls,doc,rar,zip文件&quot;              }          },          errorPlacement: function(error, element) {  //验证消息放置的地方              error.appendTo( element.parent(&quot;td&quot;).next(&quot;td&quot;) );          },          highlight: function(element, errorClass) {  //针对验证的表单设置高亮              $(element).addClass(errorClass);          },          success: function(label) {                        label.addClass(&quot;valid&quot;).text(&quot;Ok!&quot;)                }            /*,         errorContainer: &quot;#error_con&quot;,               //验证消息集中放置的容器         errorLabelContainer: &quot;#error_con ul&quot;,       //存放消息无序列表的容器         wrapper: &quot;li&quot;,                              //将验证消息用无序列表包围         validClass: &quot;valid&quot;,                        //通过验证的样式类         errorElement: &quot;em&quot;,                         //验证标签的名称，默认为：label         success: &quot;valid&quot;                            //验证通过的样式类         */      });</code></pre><h2 id="重构规则"><a href="#重构规则" class="headerlink" title="重构规则"></a>重构规则</h2><p>不论什么时候，当你的表单中的多个字段含有相同的验证规则及验证消息，重构规则可以减少很多重复。使用 addMethod 和 addClassRules 将非常有效果。<br>假使已经重构了如下规则： </p><pre><code>// alias required to cRequired with new message  $.validator.addMethod(&quot;cRequired&quot;, $.validator.methods.required,    &quot;Customer name required&quot;);  // alias minlength, too  $.validator.addMethod(&quot;cMinlength&quot;, $.validator.methods.minlength,     // leverage parameter replacement for minlength, {0} gets replaced with 2    $.format(&quot;Customer name must have at least {0} characters&quot;));  // combine them both, including the parameter for minlength  $.validator.addClassRules(&quot;customer&quot;, { cRequired: true, cMinlength: 2 }); &lt;input name=&quot;customer1&quot; class=&quot;customer&quot; /&gt;  &lt;input name=&quot;customer2&quot; class=&quot;customer&quot; /&gt;  &lt;input name=&quot;customer3&quot; class=&quot;customer&quot; /&gt;</code></pre><h3 id="adMethod"><a href="#adMethod" class="headerlink" title="adMethod"></a>adMethod</h3><p>addMethod( name, method, [message] )<br>返回：undefined</p><p>参数 name     类型：String<br>要添加的方法名，用于标识和引用，必须是一个有效的javascript标识符。</p><p>参数 method     类型：Callback    方法的实现部分，返回true如果表单元素通过验证。</p><p>参数 message(Optional)     类型：String, Function    该方法的默认验证消息。可以用 jQuery.validator.format(value) 方法创建。如果未定义该参数，则使用本地已存在的验证消息，另外，必须为指定的表单元素定义验证消息。</p><p>说明：添加一个用户自定义的验证方法。它由方法名（必须是一个合法的javascript标识符）、基于javascript的函数及默认的验证消息组成。</p><p>addClassRules( name, rules )<br>返回：undefined</p><p>参数 name     类型：String    要添加的样式规则名。</p><p>参数 rules     类型：Options    规则选项。</p><p>说明：添加一个复合的样式验证方法。对于将多个联合使用的规则重构进单个样式中非常有用。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jQuery验证及限制&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 注解的使用</title>
    <link href="https://zxhtom.oschina.io/zxh/20170302.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170302.html</id>
    <published>2017-03-02T02:44:00.000Z</published>
    <updated>2018-01-18T13:15:10.059Z</updated>
    
    <content type="html"><![CDATA[<p>spring开源框架，里面全是通过注解实现的<br><a id="more"></a></p><blockquote><p>spring开源框架，里面全是通过注解实现的，我们使用在使用的时候也尝到不少好处，所以就抽空看看Java给我们提供的注解机制的使用。</p></blockquote><hr><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><ul><li>注解就是类似于注释一样，起到对类、方法、字段等的说明作用。Annotation(注解)是在jdk1.5之后才引入的概念。所以你要想实现注解你的jdk必须1.5以上。他可以用于创建文档，跟踪代码的依赖性。甚至也可以执行基本的编译语法检查。注解的格式是以@开头的，@interface形式的类名申请。上面说了，注解你就可以理解为注释，因为注解是不会影响到代码的语义的。注解有三种存在方式，一种是存在源码中，一种是在编译中，一种是在运行期间有效。</li></ul><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul><li>编写文档：通过代码里标识的元数据生成文档。</li></ul><hr><ul><li>代码分析：通过代码里标识的元数据对代码进行分析。</li></ul><hr><ul><li>编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查</li></ul><hr><h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><ul><li>在Java中我们初学者可能不知道什么是注解，但是我们肯定都是永富哦注解的，下面来看看我们在哪里用过他们吧，</li></ul><font size="5">Override</font><ul><li>java.lang.Override是一个标记类型注解，它被用作标注方法.他说明了该方法是继承了父类的方法，就是重写了父类中同名方法。如果我们在一个方法上面使用的@override，但是实际上父类根本没有这个方法，就是说我们这个方法没有重载父类的方法。这个时候我们在编译时就会报相应的编译错误。</li></ul><font size="5">SuppressWarnings</font><ul><li><p>我对这个注解的理解就是通过它告诉编译器忽视我下面可能出现的警告。实际上里面有很多参数，不同参数设置不同的警告</p><ul><li>deprecation，使用了过时的类或方法时的警告</li><li>unchecked，执行了未检查的转换时的警告</li><li>fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告</li><li>path，在类路径、源文件路径等中有不存在的路径时的警告</li><li>serial，当在可序列化的类上缺少serialVersionUID 定义时的警告</li><li>finally ，任何 finally 子句不能正常完成时的警告</li><li>all，关于以上所有情况的警告</li></ul></li></ul><font size="5">Deprecated</font><ul><li>这个注解我实际没有接触过，这个我在网上搜了一下，人家的解释为</li></ul><blockquote><p>它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数，使用@Deprecated的示例代码示例如下：<br><img src="http://img.blog.csdn.net/20170227172148792?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></blockquote><ul><li>在我们平时编写代码用到jdk中的方法，有的时候回遇到某个方法过时了，但是可以用，那个方法就是通过这个注解实现的，简单说就是提示开发者方法过时，尽量避免使用过时方法。</li></ul><h2 id="jdk提供了开发注解的方法"><a href="#jdk提供了开发注解的方法" class="headerlink" title="jdk提供了开发注解的方法"></a>jdk提供了开发注解的方法</h2><ul><li>有了上面的介绍我们多多少少对注解有了了解，既然Java已经有了注解的概念那么我们如何开发自己的注解呢。在java.lang.annotation这个包里jdk放置了关于注解的注解，就是通过里面的注解类我们可以开发自己的注解。下面先来认识一下注解的注解吧。</li></ul><p><img src="http://img.blog.csdn.net/20170227173034372?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>通过观察源码，其中annotation 、annotationFormatError、annotationTypeMismatchExcetion、IncompleteAnnotationException这四个类有事异常类又是基本类页游格式化的，这些类我们开发注解时我们不会遇到的，都是jdk里逻辑。我们真正使用的是剩下的几个类。</li></ul><font size="5">ElementType</font><ul><li><p>这个类是个枚举，这里枚举的字段就是给Target类中使用的。具体在Target中说明</p><font size="5">RetentionPolicy</font></li><li><p>这个类是个枚举，这里枚举的字段就是给Retention类中使用的。具体在Retention中说明</p><font size="5">Documented</font></li></ul><pre><code>/** * Indicates that annotations with a type are to be documented by javadoc * and similar tools by default.  This type should be used to annotate the * declarations of types whose annotations affect the use of annotated * elements by their clients.  If a type declaration is annotated with * Documented, its annotations become part of the public API * of the annotated elements. * * @author  Joshua Bloch * @since 1.5 */</code></pre><ul><li>这是官网的jdk上对documented类的描述，这段描述的大致意思是该类的申明是用在<font color="red">生成Java文档上的注解</font>，也就是说这个注解上就可以生成文档说明，并且这个也是默认的实用工具。这种注解应该在客户端上被注入。与此同时他们的方法也成为公共的API.</li></ul><font size="5">Target </font><pre><code>/** * Indicates the kinds of program element to which an annotation type * is applicable.  If a Target meta-annotation is not present on an * annotation type declaration, the declared type may be used on any * program element.  If such a meta-annotation is present, the compiler * will enforce the specified usage restriction. * * For example, this meta-annotation indicates that the declared type is * itself a meta-annotation type.  It can only be used on annotation type * declarations: * &lt;pre&gt; *    &amp;#064;Target(ElementType.ANNOTATION_TYPE) *    public &amp;#064;interface MetaAnnotationType { *        ... *    } * &lt;/pre&gt; * This meta-annotation indicates that the declared type is intended solely * for use as a member type in complex annotation type declarations.  It * cannot be used to annotate anything directly: * &lt;pre&gt; *    &amp;#064;Target({}) *    public &amp;#064;interface MemberType { *        ... *    } * &lt;/pre&gt; * It is a compile-time error for a single ElementType constant to * appear more than once in a Target annotation.  For example, the * following meta-annotation is illegal: * &lt;pre&gt; *    &amp;#064;Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD}) *    public &amp;#064;interface Bogus { *        ... *    } * &lt;/pre&gt; */</code></pre><ul><li><p>同样上面仍然是Java JDK官网的说明，首先是说如果target指定的类型元素不存在的话，那么通过target指定的注解将可以用在任何地方，如果target指定元素，则该注解必须只能用在指定的元素上，target指定的元素是通过ElementType这个枚举类指定的，里面的枚举就是target可以指定的值。官网上的列子是Target(ElementType.ANNOTATION_TYPE)表明这个注解只能用在注解本省上面。还有一种属性不在ElementType枚举中，就是<code>target（{}）</code>，就是通过{}的注解是用来在负责注解上的成员变量，他不能用在其他的地方。</p></li><li><p>ElementType.CONSTRUCTOR:用于描述构造器</p></li><li><p>ElementType.FIELD:成员变量、对象、属性（包括enum实例）</p></li><li><p>ElementType.LOCAL_VARIABLE:用于描述局部变量</p></li><li><p>ElementType.METHOD:用于描述方法</p></li><li><p>ElementType.PACKAGE:用于描述包</p></li><li><p>ElementType.PARAMETER:用于描述参数</p></li><li><p>ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p></li></ul><font size="5">Retention </font><pre><code>/** * Indicates how long annotations with the annotated type are to * be retained.  If no Retention annotation is present on * an annotation type declaration, the retention policy defaults to * {@code RetentionPolicy.CLASS}. * * &lt;p&gt;A Retention meta-annotation has effect only if the * meta-annotated type is used directly for annotation.  It has no * effect if the meta-annotated type is used as a member type in * another annotation type. * * @author  Joshua Bloch * @since 1.5 */</code></pre><ul><li><p>这个类的属性是通过RetentionPolicy这个枚举类列举属性的，这个主要的作用是指定我们的<font color="red">注解存在的时间或者说是存在的时刻</font>。这个属性只有直接用在原注释类型的注解上才有效。如果用在其他注解的成员变量上就没有效果了。</p><ul><li><p>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</p></li><li><p>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</p></li><li><p>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p></li></ul></li></ul><font size="5">Inherited </font><pre><code>/** * Indicates that an annotation type is automatically inherited.  If * an Inherited meta-annotation is present on an annotation type * declaration, and the user queries the annotation type on a class * declaration, and the class declaration has no annotation for this type, * then the class&#39;s superclass will automatically be queried for the * annotation type.  This process will be repeated until an annotation for this * type is found, or the top of the class hierarchy (Object) * is reached.  If no superclass has an annotation for this type, then * the query will indicate that the class in question has no such annotation. * * &lt;p&gt;Note that this meta-annotation type has no effect if the annotated * type is used to annotate anything other than a class.  Note also * that this meta-annotation only causes annotations to be inherited * from superclasses; annotations on implemented interfaces have no * effect. * * @author  Joshua Bloch * @since 1.5 */</code></pre><ul><li>一句话总结就是<font color="red">是否允许子类继承该注解</font></li></ul><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><ul><li>上面说了这么多，那么下面我们开始开发自己的注解吧。</li></ul><h2 id="构造器注解"><a href="#构造器注解" class="headerlink" title="构造器注解"></a>构造器注解</h2><pre><code>/** * 该注解用于doc文档 * 该注解用于类的构造函数的注解 * 该注解尽在运行期间有效 * @author xinhua * */@Documented@Target(ElementType.CONSTRUCTOR)@Retention(RetentionPolicy.RUNTIME)public @interface ConstructorAnno{    String decs() default &quot;我是描述构造函数的注解&quot;;}</code></pre><h2 id="字段注解"><a href="#字段注解" class="headerlink" title="字段注解"></a>字段注解</h2><pre><code>/** * 该注解用于生成doc文档 * 该注解用于在类的字段属性上的注解 * 该注解尽在运行期间有效 * @author xinhua * */@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface FieldAnno{    String desc() default &quot;我是描述字段的注解&quot;;}</code></pre><h2 id="局部变量注解"><a href="#局部变量注解" class="headerlink" title="局部变量注解"></a>局部变量注解</h2><pre><code>/** * 该注解用于生成doc文档 * 该注解用于在局部变量上的注解 * 该注解尽在运行期间有效 * @author xinhua * */@Documented@Target(ElementType.LOCAL_VARIABLE)@Retention(RetentionPolicy.RUNTIME)public @interface LocalAnno{    String desc() default &quot;我是描述一个局部变量的注解&quot;;}</code></pre><h2 id="方法注解"><a href="#方法注解" class="headerlink" title="方法注解"></a>方法注解</h2><pre><code>/** * 这个注解用于生成doc文档 * 这个注解用于类的方法上的注解 * 这个注解尽在运行期间有效 * @author xinhua * */@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MethodAnno{    //默认提交时间  2017-2-28    String time() default &quot;2017-2-28&quot;;    //默认  男    true 男  false 女     boolean sex() default true;}</code></pre><h2 id="包注解"><a href="#包注解" class="headerlink" title="包注解"></a>包注解</h2><pre><code>/** * 该注解用于生成doc文档 * 该注解用于在包的注解 * 该注解尽在运行期间有效 * @author xinhua * */@Documented@Target(ElementType.PACKAGE)@Retention(RetentionPolicy.RUNTIME)public @interface PackageAnno{    String desc() default &quot;我是描述包的注解&quot;;}</code></pre><h2 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h2><pre><code>/** * 该注解用于doc文档的生成 * 该注解用于类的参数中 * 该注解尽在运行期间有效 * @author xinhua * */@Documented@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface StuInfo{    String value() default &quot;&quot;;}</code></pre><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><pre><code>/** * 该注解用于生活曾doc文档 * 该注解用于在类的注解 * 该注解尽在运行期间有效 * @author xinhua * */@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TypeAnno{    String desc() default &quot;我是描述类型的注解&quot;;}</code></pre><h2 id="加入测试的实体类"><a href="#加入测试的实体类" class="headerlink" title="加入测试的实体类"></a>加入测试的实体类</h2><pre><code>/** * 测试所有类型的注解的作用 * @author xinhua * */public @TypeAnno(desc=&quot;我是普通类&quot;)class User{    @FieldAnno    private String UID;    @FieldAnno(desc=&quot;我是UserName的&quot;)    private String userName;    @ConstructorAnno    public User(){    }    @MethodAnno(time=&quot;2015-12-8&quot; , sex=false)    public void doHomeWork(@StuInfo(value=&quot;211311084&quot;) String UID, @StuInfo(value=&quot;张新华&quot;)String UserName){         @LocalAnno(desc=&quot;flag的局部变量&quot;)boolean flag;    }}</code></pre><h2 id="加入测试的接口类"><a href="#加入测试的接口类" class="headerlink" title="加入测试的接口类"></a>加入测试的接口类</h2><pre><code>public interface UserImp{    public void DoHouseWork(@StuInfo(value=&quot;我是小学生&quot;)String stuType,@StuInfo(value=&quot;我在大扫除&quot;)String things);}</code></pre><h2 id="测试注解"><a href="#测试注解" class="headerlink" title="测试注解"></a>测试注解</h2><pre><code>/** * 开始通过反射获取注解内容 * @author xinhua * */public class Junit{    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException    {        Class&lt;?&gt; userClass = Class.forName(&quot;tom.change.annotation.User&quot;);        //实例化        Object userObject = userClass.newInstance();        //1--获取最外层的就是类的注解  TypeAnno        System.out.println(&quot;.......................类注解.......................&quot;);        TypeAnno typeAnno= userClass.getAnnotation(TypeAnno.class);        System.out.println(typeAnno.desc());        //2--获取字段注解 首先获取通过反射获取类中的属性字段        System.out.println(&quot;.......................字段注解.......................&quot;);        Field[] fields = userClass.getDeclaredFields();        for (Field field : fields)        {            FieldAnno fieldAnno = field.getAnnotation(FieldAnno.class);            System.out.println(fieldAnno.desc());        }        //3-- 方法的注解        System.out.println(&quot;.......................方法注解.......................&quot;);        Method method = userClass.getMethod(&quot;doHomeWork&quot;, String.class,String.class);        MethodAnno methodAnno = method.getAnnotation(MethodAnno.class);        System.out.println(methodAnno.time()+&quot;@@@&quot;+methodAnno.sex());        //4-- 参数的注解  动态代理方式实现参数        System.out.println(&quot;.......................参数注解.......................&quot;);        UserImp userImp=getMethodParameter(UserImp.class);        userImp.DoHouseWork(&quot;张新华&quot;, &quot;--》扫地&quot;);        //5--局部变量注解         System.out.println(&quot;.......................局部变量注解.......................&quot;);        //赞未获得到    }    public static&lt;T&gt; T getMethodParameter(Class&lt;T&gt; target){        return (T)Proxy.newProxyInstance(target.getClassLoader(), new Class&lt;?&gt;[]{target}, new InvocationHandler()        {            @Override            public Object invoke(Object proxy, Method method, Object[] args)                    throws Throwable            {                Annotation[][] parameterAnnotations = method.getParameterAnnotations();                for (int i=0;i&lt;parameterAnnotations.length;i++)                {                    Annotation[] annotations=parameterAnnotations[i];                    StuInfo stuInfo =(StuInfo) annotations[0];                    System.out.println(stuInfo.value()+&quot;@@@&quot;+args[i]);                }                return null;            }        });    }}</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://img.blog.csdn.net/20170228180341320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;spring开源框架，里面全是通过注解实现的&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Javaweb表格加载---DataTable</title>
    <link href="https://zxhtom.oschina.io/zxh/20170227.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170227.html</id>
    <published>2017-02-27T11:43:00.000Z</published>
    <updated>2018-01-18T13:15:10.052Z</updated>
    
    <content type="html"><![CDATA[<p>Datatables是一款jquery表格插件<br><a id="more"></a></p><blockquote><p>Datatables是一款jquery表格插件。它是一个高度灵活的工具，可以将任何HTML表格添加高级的交互功能。 使用 jQuery Datatable 构造数据列表，并且增加或者隐藏相应的列，已达到数据显示要求。同时， jQuery Datatable 强大的功能支持：排序，分页，搜索等。 </p></blockquote><h2 id="datatable引入"><a href="#datatable引入" class="headerlink" title="datatable引入"></a>datatable引入</h2><ul><li>css : //cdn.datatables.net/1.10.13/css/jquery.dataTables.min.css</li><li><p>js : //cdn.datatables.net/1.10.13/js/jquery.dataTables.min.js</p></li><li><p>这里申明一下，引入这上面js前提是引入jquery，因为这是基于jquery开发的</p></li></ul><h2 id="表格的创建"><a href="#表格的创建" class="headerlink" title="表格的创建"></a>表格的创建</h2><ul><li>环境准备好之后，我们需要提供一个table的样板。就是给一个table 并命名一个ID，下面是我项目中class样式，你可以不引入只需要一个id</li></ul><pre><code>&lt;table class=&quot;table table-striped table-hover table-bordered&quot; id=&quot;adminTable&quot;&gt;&lt;/table&gt;</code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><pre><code>var  adminTable = $(&#39;#adminTable&#39;).DataTable({});</code></pre><ul><li><p>最后我们只需要在js中向上面那样就行了。只不过想要实现我们想象中的table我们需要对adminTable指定相应的参数。首先需要的就是请求地址的指定</p></li><li><p>sAjaxSource： 指定我们的请求路径</p></li><li><p>lengthMenu： 表格中每页的大小，就是下面的效果<br><img src="http://img.blog.csdn.net/20170227113010073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>pageLength：当前默认每页显示的数量</p></li><li><p>oLanguage：这里是一些语言的设置，提示语言的设置，默认是英文的，。</p></li></ul><pre><code>&quot;sProcessing&quot; : &quot;正在加载数据...&quot;,                    &quot;sSearch&quot; : &quot;搜索:&quot;,                    &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;,                    &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;,                    &quot;sInfo&quot; : &quot;第  _START_ 条到第  _END_ 条记录,一共  _TOTAL_ 条记录&quot;,                    &quot;sInfoEmpty&quot; : &quot;0条记录&quot;,                    &quot;oPaginate&quot; :                     {                        &quot;sPrevious&quot; : &quot;上一页 &quot;,                        &quot;sNext&quot; : &quot; 下一页&quot;,                    }</code></pre><ul><li>还有一些额外的设置，`”bSort” : true,<pre><code>       &quot;bProcessing&quot; : true,       &quot;bServerSide&quot; : true,       &quot;async&quot; : false,`</code></pre></li></ul><ul><li>最后数据显示才是重点。这个放在下面讲解</li></ul><h2 id="数据匹配显示"><a href="#数据匹配显示" class="headerlink" title="数据匹配显示"></a>数据匹配显示</h2><ul><li>上面我们已经将表格的请求通过sAjaxSource这个属性指定好了，那么至于数据是如何显示在正确的位置的呢，主要是通过<code>aoColumns</code>这个属性匹配的。首先我们看看我们后台发回来的数据长啥样子</li></ul><p><img src="http://img.blog.csdn.net/20170227113618613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>aaDataa是我们的数据，一看就知道是个list，aaData下表就是所在索引，每个索引里面又有1-7的索引，1-7就是相当于我们表格的7列，所以我们前台table就是遍历aaData将1-7附在对应的列上，datatable也很简单，就是按照顺序赋值的的，所以我们按顺序写列名就行了</li></ul><pre><code>[                        {                            &quot;sTitle&quot; : &quot;id&quot;,                            &quot;bSortable&quot; : false                        },                        {                            &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;adminChooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;,                            &quot;bSortable&quot; : false,                            &quot;sClass&quot; : &quot;text-center&quot;,                            &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol)                             {                                var value = oData[0];                                var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;testCheckbox&quot; onclick=&quot;recordMainId(this)&quot; value=&quot;&#39;+value+&#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;;                                $(nTd).html(content);                            }                        }, {                            &quot;sTitle&quot; : &quot;用户名&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;姓名&quot;,                            &quot;bSortable&quot; : true,                            &quot;bAutoWidth&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;授权人&quot;,                            &quot;bSortable&quot; : false,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;已分配角色&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;管辖站点&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;创建时间&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;操作&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        } ]</code></pre><ul><li>至于每列的设置，大家看名称应该知道是啥意思。但是我们的列并不是仅仅显示数据的。比如有的是要加超链接。有的并不是仅仅显示原始数据，需要进行加工处理的。这里我们需要一个加工函数，上面也提到了。</li></ul><h2 id="列数据二次加工"><a href="#列数据二次加工" class="headerlink" title="列数据二次加工"></a>列数据二次加工</h2><pre><code>fnCreatedCell</code></pre><ul><li>方法就是多数据进行二次加工。</li></ul><pre><code>&quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol)                             {                                var value = oData[0];                                var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;testCheckbox&quot; onclick=&quot;recordMainId(this)&quot; value=&quot;&#39;+value+&#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;;                                $(nTd).html(content);                            }</code></pre><ul><li>其中值得一说的里面参数就是oData，oData就是所在行的所有列数据的集合数组。很有用的。比如你想去改行的第一列数据，直接oData[0]就取到了。在做修改删除很有用。</li></ul><ul><li>但是dataTable还通过另外一种方式对数据进行二次处理。就是通过<code>aoColumnDefs</code>这个属性来指定具体列的数据加工。</li></ul><pre><code>[                        {                            &quot;bSearchable&quot; : true,                            &quot;bVisible&quot; : false,                            &quot;aTargets&quot; : [ 0 ]                        },                        {                            &quot;aTargets&quot; : [ 3 ],                            &quot;mRender&quot; : function(data,type, full)                             {                                var value=full[0];                                return &quot;&lt;a href=&#39;&#39; onclick=&#39;showUserInfo(\&quot;&quot;+value+&quot;\&quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data+ &quot;&lt;/a&gt;&quot;;                            }                        },                        {                            &quot;aTargets&quot; : [ 4 ],                            &quot;mRender&quot; : function(data,type, full)                             {                                if(data==null)                                {                                    data=&quot;@@@&quot;                                }                                var arr = data.split(&quot;@@@&quot;);                                return &quot;&lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39; onclick=&#39;showUserInfo(\&quot;&quot;+ arr[0]+ &quot;\&quot;)&#39; &gt;&quot;+ arr[1]+ &quot;&lt;/a&gt;&quot;;                            }                        },                        {                            &quot;aTargets&quot; : [ 8 ],                            &quot;mRender&quot; : function(data,type, full) {                                return &quot;&lt;a href=&#39;javascript;;&#39; onclick=&#39; return adminUpdate(this)&#39; site=&#39;&quot;+ full[6]+ &quot;&#39; id=&#39;&quot;+ full[0]+ &quot;&#39; name=&#39;&quot;+ full[2]+ &quot;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#myModalUpdate&#39;&gt;修改&lt;/a&gt;     &lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#deleteModal&#39; onclick=&#39;return adminDelete(this)&#39; id=&#39;&quot;+full[0]+&quot;&#39; role=&#39;&quot;+ full[5]+ &quot;&#39;&gt;删除&lt;/a&gt;&quot;;                            }                        } ]</code></pre><ul><li><p>这种方法缺陷就是需要我们指定列号，但是实际开发中我们的列号可能是会因为项目需求而改变的，所以这个方法不是很好，但是也能实现同样的效果。然后通过<code>mRender</code>指定函数时间，里面的full和oData是一个数据效果。</p></li><li><p>到这里数据显示及一些CURD操作基本就实现了。但是有的时候我们需要将表格加载数据是携带参数查询，这个时候我们除了在指定的请求上加，还有一种方法是在数据回调是处理的。通过<code>fnServerData</code>属性，我们可以加条件参数传入后台。</p></li></ul><pre><code>// 服务器端，数据回调处理                  &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback)                 {                    aoData.push({                        &quot;name&quot; : &quot;user_name&quot;,                        &quot;value&quot; : $(&#39;#user_name&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;real_name&quot;,                        &quot;value&quot; : $(&#39;#real_name&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;create_user_name&quot;,                        &quot;value&quot; : $(                                &#39;#create_user_name&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;site_id&quot;,                        &quot;value&quot; : $(&#39;#site_id&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;fromTime&quot;,                        &quot;value&quot; : $(&#39;#fromTime&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;toTime&quot;,                        &quot;value&quot; : $(&#39;#toTime&#39;).val()                    });                    $.ajax({                        &quot;type&quot; : &quot;POST&quot;,                        &quot;url&quot; : sSource,                        &quot;dataType&quot; : &quot;json&quot;,                        &quot;contentType&quot; : &quot;application/json&quot;,                        &quot;data&quot; : JSON.stringify(aoData),                        &quot;success&quot; : function(data)                         {                            fnCallback(data);                        }                    });                }</code></pre><ul><li>条件参数通过aoData.push方法加入。到这里前台table已经显示完了。我们在看看后台数据处理逻辑。</li></ul><h2 id="后台参数接收"><a href="#后台参数接收" class="headerlink" title="后台参数接收"></a>后台参数接收</h2><ul><li>前台我们指定的请求我们在后台对应的请求中加入如下参数。</li></ul><p><img src="http://img.blog.csdn.net/20170227114922949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>前台中的aoData.push进来的参数及datatable自身关于分页等等的信息数据全是放在dataTableParams这个变量中。我们只需要将他转换成map就可以传入数据库操作了。</li></ul><p>转map代码：</p><pre><code>HashMap&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;();        for (DataTableParam dataTableParam : dataTableParams)         {            paramsMap.put(dataTableParam.getName(), dataTableParam.getValue());        }</code></pre><ul><li>下面的操作我就不在细致说了，下面就是传入数据sql的操作了。</li></ul><h2 id="表格刷新"><a href="#表格刷新" class="headerlink" title="表格刷新"></a>表格刷新</h2><ul><li>在实际中我们都需要不刷新页面只刷新页面中某个空间。datatable基于此需求专门提供了刷新表格的方法。在实际开发中我们改变了表中数据最后我们调用刷新的方法就行了</li></ul><pre><code>adminTable.draw();</code></pre><h2 id="使用dataTable常见问题汇总"><a href="#使用dataTable常见问题汇总" class="headerlink" title="使用dataTable常见问题汇总"></a>使用dataTable常见问题汇总</h2><p><img src="http://img.blog.csdn.net/20170227115556405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>这个问题基本上就是数据不匹配，这是因为我在前台<code>aoColumns</code>中指定了7列，但是我们后台只穿回来6列的原因，只要少于7列都是这种错误。修改方法：去后台添加完整数据。<font color="red">就算某列时空也要加入，加入空字符串代替，因为前台是按顺序的加载数据的，所以没数据也要用空字符串占替位置。</font></li></ul><font color="blue">dataTable发展的版本很多，不同的版本里面的参数名可能不太一样，需要注意一下，有的版本加载table的请求地址是通过ajax属性来实现的。有的就是sAjaxSource属性实现的，只是名称不一样了而已。</font><h2 id="完整DataTable加载样本"><a href="#完整DataTable加载样本" class="headerlink" title="完整DataTable加载样本"></a>完整DataTable加载样本</h2><pre><code>var adminTable= $(&#39;#adminTable&#39;).DataTable(            {                &quot;bSort&quot; : true,                &quot;bProcessing&quot; : true,                &quot;bServerSide&quot; : true,                &quot;async&quot; : false,                //&quot;retrieve&quot; : true,//保证只有一个table实例                  &quot;bStateSave&quot; : false,                &quot;sAjaxSource&quot; : jQuery.getBasePath()                        + &quot;/adminManage/tableDisplay.bsh&quot;,                &quot;sDom&quot; : &#39;&lt;&quot;top&quot;l&lt;&quot;clear&quot;&gt;&gt;rt&lt;&quot;bottom&quot;ip&lt;&quot;clear&quot;&gt;&gt;&#39;,                &quot;lengthMenu&quot; : [ 10, 25, 75, 100 ],                &quot;pageLength&quot; : 10,                &quot;oLanguage&quot; :                 {                    &quot;sProcessing&quot; : &quot;正在加载数据...&quot;,                    &quot;sSearch&quot; : &quot;搜索:&quot;,                    &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;,                    &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;,                    &quot;sInfo&quot; : &quot;第  _START_ 条到第  _END_ 条记录,一共  _TOTAL_ 条记录&quot;,                    &quot;sInfoEmpty&quot; : &quot;0条记录&quot;,                    &quot;oPaginate&quot; :                     {                        &quot;sPrevious&quot; : &quot;上一页 &quot;,                        &quot;sNext&quot; : &quot; 下一页&quot;,                    }                },                &quot;aoColumnDefs&quot; : [                        {                            &quot;bSearchable&quot; : true,                            &quot;bVisible&quot; : false,                            &quot;aTargets&quot; : [ 0 ]                        },                        {                            &quot;aTargets&quot; : [ 3 ],                            &quot;mRender&quot; : function(data,type, full)                             {                                var value=full[0];                                return &quot;&lt;a href=&#39;&#39; onclick=&#39;showUserInfo(\&quot;&quot;+value+&quot;\&quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data+ &quot;&lt;/a&gt;&quot;;                            }                        },                        {                            &quot;aTargets&quot; : [ 4 ],                            &quot;mRender&quot; : function(data,type, full)                             {                                if(data==null)                                {                                    data=&quot;@@@&quot;                                }                                var arr = data.split(&quot;@@@&quot;);                                return &quot;&lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39; onclick=&#39;showUserInfo(\&quot;&quot;+ arr[0]+ &quot;\&quot;)&#39; &gt;&quot;+ arr[1]+ &quot;&lt;/a&gt;&quot;;                            }                        },                        {                            &quot;aTargets&quot; : [ 8 ],                            &quot;mRender&quot; : function(data,type, full) {                                return &quot;&lt;a href=&#39;javascript;;&#39; onclick=&#39; return adminUpdate(this)&#39; site=&#39;&quot;+ full[6]+ &quot;&#39; id=&#39;&quot;+ full[0]+ &quot;&#39; name=&#39;&quot;+ full[2]+ &quot;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#myModalUpdate&#39;&gt;修改&lt;/a&gt;     &lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#deleteModal&#39; onclick=&#39;return adminDelete(this)&#39; id=&#39;&quot;+full[0]+&quot;&#39; role=&#39;&quot;+ full[5]+ &quot;&#39;&gt;删除&lt;/a&gt;&quot;;                            }                        } ],                &quot;aoColumns&quot; : [                        {                            &quot;sTitle&quot; : &quot;id&quot;,                            &quot;bSortable&quot; : false                        },                        {                            &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;adminChooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;,                            &quot;bSortable&quot; : false,                            &quot;sClass&quot; : &quot;text-center&quot;,                            &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol)                             {                                var value = oData[0];                                var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;testCheckbox&quot; onclick=&quot;recordMainId(this)&quot; value=&quot;&#39;+value+&#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;;                                $(nTd).html(content);                            }                        }, {                            &quot;sTitle&quot; : &quot;用户名&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;姓名&quot;,                            &quot;bSortable&quot; : true,                            &quot;bAutoWidth&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;授权人&quot;,                            &quot;bSortable&quot; : false,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;已分配角色&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;管辖站点&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;创建时间&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        }, {                            &quot;sTitle&quot; : &quot;操作&quot;,                            &quot;bSortable&quot; : true,                            &quot;sClass&quot; : &quot;text-center&quot;                        } ],                // 服务器端，数据回调处理                  &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback)                 {                    aoData.push({                        &quot;name&quot; : &quot;user_name&quot;,                        &quot;value&quot; : $(&#39;#user_name&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;real_name&quot;,                        &quot;value&quot; : $(&#39;#real_name&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;create_user_name&quot;,                        &quot;value&quot; : $(                                &#39;#create_user_name&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;site_id&quot;,                        &quot;value&quot; : $(&#39;#site_id&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;fromTime&quot;,                        &quot;value&quot; : $(&#39;#fromTime&#39;).val()                    });                    aoData.push({                        &quot;name&quot; : &quot;toTime&quot;,                        &quot;value&quot; : $(&#39;#toTime&#39;).val()                    });                    $.ajax({                        &quot;type&quot; : &quot;POST&quot;,                        &quot;url&quot; : sSource,                        &quot;dataType&quot; : &quot;json&quot;,                        &quot;contentType&quot; : &quot;application/json&quot;,                        &quot;data&quot; : JSON.stringify(aoData),                        &quot;success&quot; : function(data)                         {                            fnCallback(data);                        }                    });                }            });}function initSelectTable() {    UserDataTable = $(&#39;#selectUserTable&#39;).DataTable(    {        &quot;bSort&quot; : true,        &quot;bProcessing&quot; : true,        &quot;bServerSide&quot; : true,        &quot;bStateSave&quot; : false,        /* &quot;sScrollX&quot;: &quot;100%&quot;,        &quot;sScrollXInner&quot;: &quot;100%&quot;,        &quot;bScrollCollapse&quot;: true, */        &quot;bAutoWidth&quot; : false,        &quot;sAjaxSource&quot; : jQuery.getBasePath()+ &quot;/userManage/getUserTable.bsh&quot;,        &quot;sDom&quot; : &#39;&lt;&quot;top&quot;l&lt;&quot;clear&quot;&gt;&gt;rt&lt;&quot;bottom&quot;ip&lt;&quot;clear&quot;&gt;&gt;&#39;,        &quot;lengthMenu&quot; : [ 3, 20, 30 ],        &quot;pageLength&quot; : 3,        &quot;oLanguage&quot; : {        &quot;sProcessing&quot; : &quot;正在加载数据...&quot;,        &quot;sSearch&quot; : &quot;搜索:&quot;,        &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;,        &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;,        &quot;sInfo&quot; : &quot;第  _START_ 条到第  _END_ 条记录,一共  _TOTAL_ 条记录&quot;,        &quot;sInfoEmpty&quot; : &quot;0条记录&quot;,        &quot;oPaginate&quot; :         {            &quot;sPrevious&quot; : &quot;上一页 &quot;,            &quot;sNext&quot; : &quot; 下一页&quot;,        }    },    &quot;aoColumnDefs&quot; : [        {            &quot;bSearchable&quot; : true,            &quot;bVisible&quot; : false,            &quot;aTargets&quot; : [ 0 ]        },        {            &quot;aTargets&quot; : [ 1 ],            &quot;mRender&quot; : function(data,type, full)             {                return &quot;&lt;a href=&#39;&#39; onclick=&#39;viewUser(&quot;+ full[0]+ &quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data + &quot;&lt;/a&gt;&quot;;            }        },        {            &quot;aTargets&quot;:[2],            &quot;mRender&quot;:function(data,type,full)            {              return &quot;&lt;a href=&#39;&#39; onclick=&#39;showUserInfo(\&quot;&quot;+full[0]+&quot;\&quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+data+&quot;&lt;/a&gt;&quot;;            }         },        {            &quot;aTargets&quot; : [ 3 ],            &quot;mRender&quot; : function(data,type, full)             {                if(data==&quot;1&quot;)                {                    return &quot;已认证&quot;;                }                else if(data==&quot;2&quot;)                {                       return &quot;未认证&quot;;                }                else if(data==&quot;3&quot;)                {                       return &quot;待认证&quot;;                }                else if(data==&quot;4&quot;)                {                       return &quot;已驳回&quot;;                }            }        },        {            &quot;aTargets&quot; : [ 4 ],            &quot;mRender&quot; : function(data,type, full)             {                if (data &gt; 0)                 {                    return &quot;关闭&quot;;                }                 else                 {                    return &quot;启用&quot;;                }            }        } ],    &quot;aoColumns&quot; : [        {            &quot;sTitle&quot; : &quot;id&quot;,            &quot;bSortable&quot; : false        },        {            &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;chooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;,            &quot;bSortable&quot; : false,            &quot;sClass&quot; : &quot;text-center&quot;,            &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol)                             {                                var value = oData[0]+&quot;@@@&quot;+oData[2];                                var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;userCheckbox&quot; onchange=&quot;recordUserId(this)&quot; name=&quot;&#39;+ oData[2]+ &#39;&quot; value=&quot;&#39;+ value+ &#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;;                                $(nTd).html(content);                            }        },         {            &quot;sTitle&quot; : &quot;用户名&quot;,            &quot;bSortable&quot; : true,            &quot;sWidth&quot; : &quot;120px&quot;,            &quot;sClass&quot; : &quot;text-center&quot;        },         {            &quot;sTitle&quot; : &quot;实名认证&quot;,            &quot;sWidth&quot; : &quot;90px&quot;,            &quot;bSortable&quot; : true,            &quot;sClass&quot; : &quot;text-center&quot;        },         {            &quot;sTitle&quot; : &quot;状态&quot;,            &quot;sWidth&quot; : &quot;90px&quot;,            &quot;bSortable&quot; : false,            &quot;sClass&quot; : &quot;text-center&quot;        },         {            &quot;sTitle&quot; : &quot;所属站点&quot;,            &quot;bSortable&quot; : false,            &quot;sWidth&quot; : &quot;180px&quot;,            &quot;bAutoWidth&quot; : true,            &quot;sClass&quot; : &quot;text-center&quot;        } ],    // 服务器端，数据回调处理      &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback)     {        aoData.push({&quot;name&quot; : &quot;userName&quot;,&quot;value&quot; : $(&quot;#selectUserName&quot;).val()});        aoData.push({&quot;name&quot;:&quot;site&quot;,&quot;value&quot;:$(&quot;#site&quot;).val()});        /*aoData.push({&quot;name&quot;:&quot;end&quot;,&quot;value&quot;:$(&quot;#end&quot;).val()});        aoData.push({&quot;name&quot;:&quot;realName&quot;,&quot;value&quot;:$(&quot;#realName&quot;).val()});        aoData.push({&quot;name&quot;:&quot;status&quot;,&quot;value&quot;:$(&quot;#status&quot;).val()});        aoData.push({&quot;name&quot;:&quot;site&quot;,&quot;value&quot;:$(&quot;#site&quot;).val()}) */        $.ajax({            &quot;type&quot; : &quot;POST&quot;,            &quot;url&quot; : sSource,            &quot;dataType&quot; : &quot;json&quot;,            &quot;contentType&quot; : &quot;application/json&quot;,            &quot;data&quot; : JSON.stringify(aoData),            &quot;success&quot; : function(data)             {                fnCallback(data);            }        });    }    });            }function initRoleTable() {    RoleDataTable = $(&#39;#selectRoleTable&#39;).DataTable(    {        &quot;bSort&quot; : true,        &quot;bProcessing&quot; : true,        &quot;bServerSide&quot; : true,        &quot;bStateSave&quot; : false,        /* &quot;sScrollX&quot;: &quot;100%&quot;,        &quot;sScrollXInner&quot;: &quot;100%&quot;,        &quot;bScrollCollapse&quot;: true, */        &quot;bAutoWidth&quot; : false,        &quot;sAjaxSource&quot; : jQuery.getBasePath()+ &quot;/adminManage/roleList.bsh&quot;,        &quot;sDom&quot; : &#39;&lt;&quot;top&quot;l&lt;&quot;clear&quot;&gt;&gt;rt&lt;&quot;bottom&quot;ip&lt;&quot;clear&quot;&gt;&gt;&#39;,        &quot;lengthMenu&quot; : [ 3, 20, 30 ],        &quot;pageLength&quot; : 3,        &quot;oLanguage&quot; : {        &quot;sProcessing&quot; : &quot;正在加载数据...&quot;,        &quot;sSearch&quot; : &quot;搜索:&quot;,        &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;,        &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;,        &quot;sInfo&quot; : &quot;第  _START_ 条到第  _END_ 条记录,一共  _TOTAL_ 条记录&quot;,        &quot;sInfoEmpty&quot; : &quot;0条记录&quot;,        &quot;oPaginate&quot; :         {            &quot;sPrevious&quot; : &quot;上一页 &quot;,            &quot;sNext&quot; : &quot; 下一页&quot;,        }    },    &quot;aoColumnDefs&quot; : [    {        &quot;bSearchable&quot; : true,        &quot;bVisible&quot; : false,        &quot;aTargets&quot; : [ 0 ]    },    {        &quot;aTargets&quot; : [ 1 ],        &quot;mRender&quot; : function(data,type, full)         {            return &quot;&lt;a href=&#39;&#39; onclick=&#39;viewUser(&quot;+ full[0]+ &quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data + &quot;&lt;/a&gt;&quot;;        }    } ],    &quot;aoColumns&quot; : [    {        &quot;sTitle&quot; : &quot;id&quot;,        &quot;bSortable&quot; : false    },    {        &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;roleChooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;,        &quot;bSortable&quot; : false,        &quot;sWidth&quot; : &quot;70px&quot;,        &quot;sClass&quot; : &quot;text-center&quot;,        &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol)         {            var value = oData[0]+&quot;@@@&quot;+oData[2];            var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;roleCheckbox&quot; onchange=&quot;recordRoleId(this)&quot; name=&quot;&#39;+ oData[2]+ &#39;&quot; value=&quot;&#39;+ value+ &#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;;            $(nTd).html(content);        }    },     {        &quot;sTitle&quot; : &quot;用户名&quot;,        &quot;bSortable&quot; : true,        &quot;sWidth&quot; : &quot;120px&quot;,        &quot;sClass&quot; : &quot;text-center&quot;    },     {        &quot;sTitle&quot; : &quot;创建时间&quot;,        &quot;bSortable&quot; : false,        &quot;sWidth&quot; : &quot;180px&quot;,        &quot;bAutoWidth&quot; : true,        &quot;sClass&quot; : &quot;text-center&quot;    } ],    // 服务器端，数据回调处理      &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback)     {        aoData.push({&quot;name&quot; : &quot;sname&quot;,&quot;value&quot; : $(&#39;#selectRoleName&#39;).val()});        /*aoData.push({&quot;name&quot;:&quot;start&quot;,&quot;value&quot;:$(&quot;#start&quot;).val()});        aoData.push({&quot;name&quot;:&quot;end&quot;,&quot;value&quot;:$(&quot;#end&quot;).val()});        aoData.push({&quot;name&quot;:&quot;realName&quot;,&quot;value&quot;:$(&quot;#realName&quot;).val()});        aoData.push({&quot;name&quot;:&quot;status&quot;,&quot;value&quot;:$(&quot;#status&quot;).val()});        aoData.push({&quot;name&quot;:&quot;site&quot;,&quot;value&quot;:$(&quot;#site&quot;).val()}) */        $.ajax({            &quot;type&quot; : &quot;POST&quot;,            &quot;url&quot; : sSource,            &quot;dataType&quot; : &quot;json&quot;,            &quot;contentType&quot; : &quot;application/json&quot;,            &quot;data&quot; : JSON.stringify(aoData),            &quot;success&quot; : function(data)             {                fnCallback(data);            }        });    }    });</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datatables是一款jquery表格插件&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微信开发--开发模式简单配置</title>
    <link href="https://zxhtom.oschina.io/zxh/20170215.html"/>
    <id>https://zxhtom.oschina.io/zxh/20170215.html</id>
    <published>2017-02-15T14:14:00.000Z</published>
    <updated>2018-01-18T13:15:10.063Z</updated>
    
    <content type="html"><![CDATA[<p>微信用户量很多，那么我们如何开始一个属于自己的微信小程序呢<br><a id="more"></a></p><blockquote><p>微信用户量很多，那么我们如何开始一个属于自己的微信小程序呢，因为自己不是高微信的。最近研究了一下微信，只是先微信的一个小功能。那么下面开始微信开发的搭建。这里如何申请微信公众号自己去官网申请就行了。最后登录该公众号。下面从我公众号开始讲</p></blockquote><h2 id="开启开发者模式"><a href="#开启开发者模式" class="headerlink" title="开启开发者模式"></a>开启开发者模式</h2><ul><li>点击左侧菜单的基本配置</li></ul><p><img src="http://img.blog.csdn.net/20170215103140846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>然后是做微信开发我们得有一个属于自己的服务器，方便在上面编写代码。这里我用新浪云作为自己的服务器。<br><a href="http://sae.sina.com.cn/" target="_blank" rel="noopener">新浪云服务注册地址</a></li></ul><h2 id="新浪云申请"><a href="#新浪云申请" class="headerlink" title="新浪云申请"></a>新浪云申请</h2><ul><li>进入新浪云后选择控制台sae</li></ul><p><img src="http://img.blog.csdn.net/20170215103919161?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>然后点击创建新应用 按钮 后弹出选择服务器的界面，我们选择标准版的，因为是免费的。</li></ul><p><img src="http://img.blog.csdn.net/20170215104059584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>至于里面的二级域名这就是看个人喜好设置的了。设置好之后我们回到父页面，就是点击创建新应用的那个界面就会看到我们创建的应用了，我这里是我实现创立好的。</li></ul><p><img src="http://img.blog.csdn.net/20170215104242550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="微信开发者配置"><a href="#微信开发者配置" class="headerlink" title="微信开发者配置"></a>微信开发者配置</h2><ul><li>通过上面我们就已经有了服务器了，下面我们来填写微信的相关配置</li></ul><p><img src="http://img.blog.csdn.net/20170215104434880?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li><p>上面的url就填写我们的新建的新浪云应用的地址，至于token随便你自己填写，只不过你得记住，因为在新浪云服务器里写代码的时候需要用到。</p></li><li><p>然后点击确定你的微信公众号就成为了开发者模式了。下面我们开始在服务器上实现我们的功能</p></li></ul><h2 id="微信服务器的代码编写"><a href="#微信服务器的代码编写" class="headerlink" title="微信服务器的代码编写"></a>微信服务器的代码编写</h2><ul><li>点击我们的应用的连接进入应用界面</li></ul><p><img src="http://img.blog.csdn.net/20170215104744229?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>选择左侧菜单树种的应用后再点击代码管理，在右侧就可以看到应用的编辑代码超链接了，点击超链接</li></ul><p><img src="http://img.blog.csdn.net/20170215104921981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>这里我们可以选择我们index.php进行代码的修改，或者是实现。直接将下面的代码赋值到你的服务器里</li></ul><pre><code>&lt;?php/*    新华工作室    http://www.cnblogs.com/txw1958/    CopyRight 2014 All Rights Reserved*/define(&quot;TOKEN&quot;, &quot;与微信配置中的token对应&quot;);$wechatObj = new wechatCallbackapiTest();if (!isset($_GET[&#39;echostr&#39;])) {    $wechatObj-&gt;responseMsg();}else{    $wechatObj-&gt;valid();}class wechatCallbackapiTest{    //验证签名    public function valid()    {        $echoStr = $_GET[&quot;echostr&quot;];        $signature = $_GET[&quot;signature&quot;];        $timestamp = $_GET[&quot;timestamp&quot;];        $nonce = $_GET[&quot;nonce&quot;];        $token = TOKEN;        $tmpArr = array($token, $timestamp, $nonce);        sort($tmpArr);        $tmpStr = implode($tmpArr);        $tmpStr = sha1($tmpStr);        if($tmpStr == $signature){            header(&#39;content-type:text&#39;);            echo $echoStr;            exit;        }    }    //响应消息    public function responseMsg()    {        $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;];        if (!empty($postStr)){            $this-&gt;logger(&quot;R &quot;.$postStr);            $postObj = simplexml_load_string($postStr, &#39;SimpleXMLElement&#39;, LIBXML_NOCDATA);            $RX_TYPE = trim($postObj-&gt;MsgType);            //消息类型分离            switch ($RX_TYPE)            {                case &quot;event&quot;:                    $result = $this-&gt;receiveEvent($postObj);                    break;                case &quot;text&quot;:                    $result = $this-&gt;receiveText($postObj);                    break;                default:                    $result = &quot;unknown msg type: &quot;.$RX_TYPE;                    break;            }            $this-&gt;logger(&quot;T &quot;.$result);            echo $result;        }else {            echo &quot;&quot;;            exit;        }    }    //接收事件消息    private function receiveEvent($object)    {        $content = &quot;&quot;;        switch ($object-&gt;Event)        {            case &quot;subscribe&quot;:                $content = &quot;欢迎关注新华工作室 &quot;;                $content .= (!empty($object-&gt;EventKey))?(&quot;\n来自二维码场景 &quot;.str_replace(&quot;qrscene_&quot;,&quot;&quot;,$object-&gt;EventKey)):&quot;&quot;;                break;            case &quot;unsubscribe&quot;:                $content = &quot;取消关注&quot;;                break;            case &quot;SCAN&quot;:                $content = &quot;扫描场景 &quot;.$object-&gt;EventKey;                break;            case &quot;CLICK&quot;:                switch ($object-&gt;EventKey)                {                    case &quot;COMPANY&quot;:                        $content = array();                        $content[] = array(&quot;Title&quot;=&gt;&quot;多图文1标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;);                        break;                    default:                        $content = &quot;点击菜单：&quot;.$object-&gt;EventKey;                        break;                }                break;            case &quot;LOCATION&quot;:                $content = &quot;上传位置：纬度 &quot;.$object-&gt;Latitude.&quot;;经度 &quot;.$object-&gt;Longitude;                break;            case &quot;VIEW&quot;:                $content = &quot;跳转链接 &quot;.$object-&gt;EventKey;                break;            case &quot;MASSSENDJOBFINISH&quot;:                $content = &quot;消息ID：&quot;.$object-&gt;MsgID.&quot;，结果：&quot;.$object-&gt;Status.&quot;，粉丝数：&quot;.$object-&gt;TotalCount.&quot;，过滤：&quot;.$object-&gt;FilterCount.&quot;，发送成功：&quot;.$object-&gt;SentCount.&quot;，发送失败：&quot;.$object-&gt;ErrorCount;                break;            default:                $content = &quot;receive a new event: &quot;.$object-&gt;Event;                break;        }        if(is_array($content)){            if (isset($content[0])){                $result = $this-&gt;transmitNews($object, $content);            }else if (isset($content[&#39;MusicUrl&#39;])){                $result = $this-&gt;transmitMusic($object, $content);            }        }else{            $result = $this-&gt;transmitText($object, $content);        }        return $result;    }    //接收文本消息    private function receiveText($object)    {        $keyword = trim($object-&gt;Content);        //多客服人工回复模式        if (strstr($keyword, &quot;您好&quot;) || strstr($keyword, &quot;你好&quot;) || strstr($keyword, &quot;在吗&quot;)){            $result = $this-&gt;transmitService($object);        }        //自动回复模式        else{            if (strstr($keyword, &quot;文本&quot;)){                $content = &quot;这是个文本消息&quot;;            }else if (strstr($keyword, &quot;单图文&quot;)){                $content = array();                $content[] = array(&quot;Title&quot;=&gt;&quot;单图文标题&quot;,  &quot;Description&quot;=&gt;&quot;单图文内容&quot;, &quot;PicUrl&quot;=&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;);            }else if (strstr($keyword, &quot;图文&quot;) || strstr($keyword, &quot;多图文&quot;)){                $content = array();                $content[] = array(&quot;Title&quot;=&gt;&quot;多图文1标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;);                $content[] = array(&quot;Title&quot;=&gt;&quot;多图文2标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://d.hiphotos.bdimg.com/wisegame/pic/item/f3529822720e0cf3ac9f1ada0846f21fbe09aaa3.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;);                $content[] = array(&quot;Title&quot;=&gt;&quot;多图文3标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://g.hiphotos.bdimg.com/wisegame/pic/item/18cb0a46f21fbe090d338acc6a600c338644adfd.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;);            }else if (strstr($keyword, &quot;音乐&quot;)){                $content = array();                $content = array(&quot;Title&quot;=&gt;&quot;最炫民族风&quot;, &quot;Description&quot;=&gt;&quot;歌手：凤凰传奇&quot;, &quot;MusicUrl&quot;=&gt;&quot;http://121.199.4.61/music/zxmzf.mp3&quot;, &quot;HQMusicUrl&quot;=&gt;&quot;http://121.199.4.61/music/zxmzf.mp3&quot;);            }else{                $content = date(&quot;Y-m-d H:i:s&quot;,time()).&quot;\n&quot;.&quot;ID&quot;.$object-&gt;FromUserName.&quot;\n技术支持 新华工作室&quot;;            }            if(is_array($content)){                if (isset($content[0][&#39;PicUrl&#39;])){                    $result = $this-&gt;transmitNews($object, $content);                }else if (isset($content[&#39;MusicUrl&#39;])){                    $result = $this-&gt;transmitMusic($object, $content);                }            }else{                $result = $this-&gt;transmitText($object, $content);            }        }        return $result;    }    //回复文本消息    private function transmitText($object, $content)    {        $xmlTpl = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;/xml&gt;&quot;;        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content);        return $result;    }    //回复语音消息    private function transmitVoice($object, $voiceArray)    {        $itemTpl = &quot;&lt;Voice&gt;    &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt;&lt;/Voice&gt;&quot;;        $item_str = sprintf($itemTpl, $voiceArray[&#39;MediaId&#39;]);        $xmlTpl = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt;$item_str&lt;/xml&gt;&quot;;        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());        return $result;    }    //回复图文消息    private function transmitNews($object, $newsArray)    {        if(!is_array($newsArray)){            return;        }        $itemTpl = &quot;    &lt;item&gt;        &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;        &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;        &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt;        &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt;    &lt;/item&gt;&quot;;        $item_str = &quot;&quot;;        foreach ($newsArray as $item){            $item_str .= sprintf($itemTpl, $item[&#39;Title&#39;], $item[&#39;Description&#39;], $item[&#39;PicUrl&#39;], $item[&#39;Url&#39;]);        }        $xmlTpl = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;&lt;ArticleCount&gt;%s&lt;/ArticleCount&gt;&lt;Articles&gt;$item_str&lt;/Articles&gt;&lt;/xml&gt;&quot;;        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), count($newsArray));        return $result;    }    //回复音乐消息    private function transmitMusic($object, $musicArray)    {        $itemTpl = &quot;&lt;Music&gt;    &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;    &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;    &lt;MusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/MusicUrl&gt;    &lt;HQMusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/HQMusicUrl&gt;&lt;/Music&gt;&quot;;        $item_str = sprintf($itemTpl, $musicArray[&#39;Title&#39;], $musicArray[&#39;Description&#39;], $musicArray[&#39;MusicUrl&#39;], $musicArray[&#39;HQMusicUrl&#39;]);        $xmlTpl = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[music]]&gt;&lt;/MsgType&gt;$item_str&lt;/xml&gt;&quot;;        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());        return $result;    }    //回复多客服消息    private function transmitService($object)    {        $xmlTpl = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[transfer_customer_service]]&gt;&lt;/MsgType&gt;&lt;/xml&gt;&quot;;        $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time());        return $result;    }    //日志记录    private function logger($log_content)    {        if(isset($_SERVER[&#39;HTTP_APPNAME&#39;])){   //SAE            sae_set_display_errors(false);            sae_debug($log_content);            sae_set_display_errors(true);        }else if($_SERVER[&#39;REMOTE_ADDR&#39;] != &quot;127.0.0.1&quot;){ //LOCAL            $max_size = 10000;            $log_filename = &quot;log.xml&quot;;            if(file_exists($log_filename) and (abs(filesize($log_filename)) &gt; $max_size)){unlink($log_filename);}            file_put_contents($log_filename, date(&#39;H:i:s&#39;).&quot; &quot;.$log_content.&quot;\r\n&quot;, FILE_APPEND);        }    }}?&gt;</code></pre><ul><li><font face="楷体" size="5" color="red">token一定要和微信配置中的相同</font></li><li><p>然后让我们看看效果吧</p></li></ul><p><img src="http://img.blog.csdn.net/20170215132626415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzEzMjA1MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信用户量很多，那么我们如何开始一个属于自己的微信小程序呢&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://zxhtom.oschina.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://zxhtom.oschina.io/tags/java/"/>
    
  </entry>
  
</feed>
