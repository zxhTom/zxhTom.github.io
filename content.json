[{"title":"A*寻路解析(源码+图例解析)","date":"2018-01-15T03:24:00.000Z","path":"zxh/20180115.html","text":"[TOC] A*算法，A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法。算法中的距离估算值与实际值越接近，最终搜索速度越快。 基本概念 首先在大学我们遇到最多的算法Dijkstra、Floyd、广度搜索、深度搜索。关于这些算法我们以后再慢慢的研究，今天的重点在A*算法上。A*算法是一种启发式算法。与上述几种算法不同的是A*算法在考虑起始节点的同时还会考虑到目标节点的代价。 在A*算法中我们给每个节点都定义一些属性。最基本的就是下文提到的三基数-这里的三基数是我自己定义的一个名词。什么叫启发式就是在探索路径的时候既要选择里起始点最近也要考虑到里目标节点的消费问题。 三基值 上面的一些概念可能会使你很模糊，这里我们直接看定义。 &gt; F=G+H : 表示一个节点的总消费值；换句话说就是离起始节点和目标节点距离的总和 G : 表示该从其实节点到该节点的消费值； H : 表示从该节点到目标节点的消费值；(这里注意一下，这里的消费值其实是一个预估值，因为我们无法判断到目标节点的具体路径，这个H值得获取本文会提供三种方法，其中使用最广泛的是曼哈顿距离) 图1 三基值计算常规约定 在方格地图中我们约定横向或者纵向单位消费为10 在方格地图中斜向单位消费为14 在墙（墙、河流等不可经过的节点统称）角我们是不可以斜着穿越的，这是常识。实际中我们每个移动的物体都是有自己的空间的，如下图这样S–&gt;E的过程S’已经占用了Q（墙）的领域了。 图2 在非墙角地方根据自己需求可以设定可穿越，也可以设定不可穿越。本文设定是可穿越的。 图3 G值计算 三基数在上面定义中我们已经列出了其计算公式，可能有的人看的不是很明白。我们这里详细解释一下 首先我们先看三基值中的G值，G表示该从其实节点到该节点的消费值，这句话的意思从开始节点移动到当前节点需要的实际的消费，这里是需要考虑到不可经过的节点的。如下图S表示起始点，E表示目标节点,N表示当前节点，黑色的表示墙(不可经过的节点集合)。我们规定在墙角是无法斜着穿过去，在其他地方是可以斜着经过的。有了这个约定，我们可以算出图3中 S—&gt;N1 消费10， S—&gt;N2消费14，因为从S到N2不是处于墙角。 途中N3—&gt;N4就是明显的墙角。所以N3—&gt;N4消费是20。 H值计算方式 H值和G值作用相反，H值是预估到目标节点的消费值。 首先G是针对其实点的，而H值是针对目标节点的 其次G值是真实值，而H值是预估值 最后G值得计算是允许斜线行走的，但是H值计算只能横向和纵向的结合 下图(图4中从N2—&gt;E点的H=40+10),其中40部分已经穿墙了。这里因为是预估值所以不考虑墙的存在。到这里我们基本的定义已经结束了 图4 集合列表 在我们A*寻路的过程中，我们需要用到两个集合，一个我们成为开放集合(OpenList),另外一个我们称之为闭合集合(ClosedList)。 举个例子我们去超市购物，我们都会推个手推车，把喜欢的东西放进购物车里。最后结算的时候或者是中途我们会选择价格更实惠的东西替代我们已经选择的同等产品 在A*中我们也是这样，openList就相当于购物车，我们会将见到的喜欢的物品加入购物车，但是加入购物车并不一定最后会买，在A*中，我们会将节点周围可用的节点加入openList，但是并不一定最后需要。在openList添加的过程我们会慢慢用’更实惠’的节点代替已经选择的相同的节点。在超市最后放到我们自己的包里才是最后我们要带回家的东西。在A*算法中加到closedList中才是我们最后的东西。 寻路解析 本小节图片来源以下文章。其中思想参考源以下文章 http://blog.csdn.net/zgwangbo/article/details/52078338 http://blog.csdn.net/hitwhylz/article/details/23089415 经过上面的介绍我们了解了A*中我们一些约定的定义，理解上面这些定义的基础上我们下面的流程会很易懂。 初始地图 如图5,地图上蓝色方格表示墙，关于墙的定义上面已经解释过了。左边青色的表示S(起始节点)，右边的红色节点表示我们的目标节点。小圆点表示从S到E的最有路径之一。从图5我们可以看出我们在墙角没有斜走，而在其他路段上我们选择斜着走了。下面介绍节点就以图5中的坐标为准。比如起始节点我们就称之为(2,3)。 蓝色方格表示不可经过方格 青色的边框的方格表示已经加入openList 高亮显示的边框表示添加在closedList 青色表示其实节点 红色表示目标节点 递归寻走 首先我们常规的寻路是不可能出现首尾相同的情况。但是项目中得处理这种情况，如果其实节点和目标节点是地图上的统一节点，那么我们的路径就是当前节点。 选择当前节点周围可用的节点，如果不在openList集合中则分别计算三基数的值并且加入到openList集合中,计算三基数的同事将待加入openList的节点的父节点设置为当前节点。 如果已经存在openList集合中且结合中的G值大于当前节点(周围节点之一)的G值，则将当前节点更新到openList集合中。否则不加入也不更新。 周围节点选择完之后我们就把该节点(起始节点)加入closedList中，然后从openList中选择F值最小的节点，在继续重复上面三步骤。 图示流程 按照图5中我们可以获得起始节点(2,3)的周围节点列表如图6。并逐个分析是否该加入openList中。 图6 通过比较我们发现目前周围的八个节点全部有效且全不在openList中，那么我们就全部加入并计算三基数的值，并设置他们的父节点为(2,3)。如图7 图7 从图7中我们可以看出在起始节点(2,3)周围(3,3)这个节点的F值此时在openList中最小，所以此时我们将(2,3)移除openList并将(2,3)加入到closedList中。此时(2,3)由高亮方格显示表示加入closedList集合， (2,3)节点就算是结束了他的使命了，加入了closedList集合中的节点我们将不会再去考虑，我们可以认为加入到closedList集合中的点已经成墙了。那么下面我们从openList中选取F值最小(3,3)为新的起始节点，开始重复上面的流程，但是我们发现(3,3)的右上、正右、右下都是墙，还有正左(2,3)在closedList集合中。这四点我们是不用考虑的。那么只剩下(2,2),(3,2),(2,4),(3,4)这四个点。但是这四个点恰巧有全部在openList中。依照上面的流程我们得以此比较这四个点和openList集合中对应的点的G值谁大谁小。就一个原则谁小留谁。由图8我们可以知道，新获得的这四个点的G值均大于openlist里对应的点的G值，所以我们这里放弃这四个点。他们没有被我们喜欢，我们抛弃这些点。这一轮结束我们将(3,3)加入到closedList集合中。如果新节点G值小于对应的openList中的点的G值得话，我们就要更新openList集合中的对应的那个点。所谓的更新就是将新节点替换原来那个节点。注意此时新节点和openList对应的那个点出了三基数不同，还有父节点也不同了。 这里需要解释下为什么新节点的G值都会加10呢，那是因为我们最起始的节点是(2,3)，而此时的起始节点是(3,3),比如我们算(2,2)G值得时候实际上是(2,3)—&gt;(3,3)—&gt;(2,2)整个过程的G值。所以是10+14。 图8 由图9我们能够看到此时我们openList中最小F值应该是(3,4)，下面的步骤就是一直重复。 图9 直到我们的目标节点成为起始节点就表示循环结束，这个时候我们通过我们的目标节点在closedlist总通过父节点就能反向回去获得整条路径了。 不足之处 关键在于估价函数h(n)的选取：估价值h(n)&lt;= n到目标节点的距离实际值，这种情况下，搜索的点数多，搜索范围大，效率低。但能得到最优解。并且如果h(n)=d(n)，即距离估计h(n)等于最短距离，那么搜索将严格沿着最短路径进行， 此时的搜索效率是最高的。如果 估价值&gt;实际值,搜索的点数少，搜索范围小，效率高，但不能保证得到最优解 源码源码下载点我 [//]: A译文： http://blog.csdn.net/coutamg/article/details/53923717[//]:其他最小路径算法：https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html [//]:启发式算法：https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://zxhtom.oschina.io/tags/算法/"}]},{"title":"java String类中formatter给我们的好处","date":"2018-01-05T10:00:30.000Z","path":"zxh/20180105.html","text":"javaweb开发中我们经常需要对结果进行格式化整理。有的时候我们需要按照一定的格式返回数据给前台才能达到我们预定的效果。java string类中给我们提供的格式化(format)的方法。 格式化标准// %[argument_index$][flags][width][.precision][t]conversion private static final String formatSpecifier = &quot;%(\\\\d+\\\\$)?([-#+ 0,(\\\\&lt;]*)?(\\\\d+)?(\\\\.\\\\d+)?([tT])?([a-zA-Z%])&quot;; 查看jdk源码我们可以看到，源码是通过正则表达式捕获我们的格式化语句。我们格式化语句(下文称为占位符)完整格式即为这个正则表达式所匹配的。换句话说就是上面注释部分的格式 完整占位符： java %[argument_index$][flags][width][.precision][t]conversion 通过formatSpecifier我们可以看出占位符可以不按照标准占位符来。最简便的一种占位符%（[a-zA-Z]）,所以针对不同数据类型的格式化，占位符的格式将有所裁剪。其中.precision这个占位符是针对浮点数转换类型而言的。其他转换类型不能使用该占位符。否则会报java.util.IllegalFormatPrecisionException错(非法精度)。 % ， 占位符开始的符号(同时也是占位符中的转义字符)。 [argument_index$] ，位置索引从1开始计算，用于指定对索引相应的实参进行格式化并替换掉该占位符。 [flags] ，用于增强格式化能力，可同时使用多个 [flags] ，但某些标识是不能同时使用的。 [width] ，用于设置格式化后的字符串最小长度，若使用 [最小宽度] 而无设置 [标识] ，那么当字符串长度小于最小宽度时，则以左边补空格的方式凑够最小宽度。 [•precision] ，对于浮点数类型格式化使用，设置保留小数点后多少位。 [t] , 时间格式 conversion ，用于指定格式化的样式，和限制对应入参的数据类型。 格式化整数%[argument_index$][flags][width]conversion 这里的占位符和上述的标准占位符一样。唯一需要解释的就是flags(可用标识)和conversion(转换类型)。 flags: - :在最小宽度内左对齐,不可以与0标识一起使用。 0 :若内容长度不足最小宽度，则在左边用0来填充。 # :对8进制和16进制，8进制前添加一个0,16进制前添加0x。 + :结果总包含一个+或-号。 空格 :正数前加空格，负数前加-号。 , :只用与十进制，每3位数字间用,分隔。 ( :若结果为负数，则用括号括住，且不显示符号。 conversion: d :十进制 o :八进制 x或X :十六进制 n :平台独立的换行符, 也可通过System.getProperty(“line.separator”)获取。 String.format(&quot;%n&quot;,&quot;234&quot;)，实际就是一个换行符 b :布尔类型，只要实参为非false的布尔类型，均格式化为字符串true，否则为字符串false。 examples: 其中 十进制、八进制、十六进制都是整数可以互相使用，只有#适合八进制或者十六进制 System.out.println(&quot;实现左对齐：&quot;); System.out.println(String.format(&quot;%1$-9d&quot;, 1245)); System.out.println(&quot;实现用0填充：&quot;); System.out.println(String.format(&quot;%1$09d&quot;, 1245)); System.out.println(&quot;实现用+/-填充：&quot;); System.out.println(String.format(&quot;%1$+9d&quot;, 1245)); System.out.println(&quot;实现用空格填充：&quot;); System.out.println(String.format(&quot;%1$ 9d&quot;, 1245)); System.out.println(String.format(&quot;%1$ 9d&quot;, -1245)); System.out.println(&quot;实现用,填充：&quot;); System.out.println(String.format(&quot;%1$,9d&quot;, 1245)); System.out.println(&quot;实现用(填充：&quot;); System.out.println(String.format(&quot;%1$(9d&quot;, -1245)); System.out.println(&quot;实现结合使用：&quot;); System.out.println(String.format(&quot;%1$0(9d&quot;, -1245)); 格式化浮点数%[argument_index$][flags][width][.precision]conversion 这里的占位符和上述的标准占位符一样。唯一需要解释的就是flags(可用标识)和conversion(转换类型)。 flags: - :在最小宽度内左对齐,不可以与0标识一起使用。 0 :若内容长度不足最小宽度，则在左边用0来填充。 + :结果总包含一个+或-号。 空格 :正数前加空格，负数前加-号。 , :只用与十进制，每3位数字间用,分隔。 ( :若结果为负数，则用括号括住，且不显示符号。 conversion: e或E :结果被格式化为用计算机科学记数法表示的十进制数 f :结果被格式化为十进制普通表示方式 g或G :根据具体情况，自动选择用普通表示方式还是科学计数法方式， a或A :结果被格式化为带有效位数和指数的十六进制浮点数 notes: 在浮点数中，如果精度(precision)没有指定的情况下，默认精度(precision)为6 conversion=e,保留小数点后precision位 conversion=f,保留小数点后precision位 conversion=g,保留precision位有效数字 conversion=a,保留小数点后precision位 examples: System.out.println(String.format(&quot;%20.9a&quot;, 1223d)); System.out.println(String.format(&quot;%20.9e&quot;, 1223d)); System.out.println(String.format(&quot;%20.9f&quot;, 1223d)); System.out.println(String.format(&quot;%20.9g&quot;, 12123d)); 格式化字符%[argument_index$][flags][width]conversion flags: - :在最小宽度内左对齐,不可以与0标识一起使用。 conversion s ：字符串 c :字符类型，实参必须为char或int、short等可转换为char类型的数据类型，否则抛IllegalFormatConversionException异常。 格式化日期%[argument_index$][flags][width]conversion flags: - :在最小宽度内左对齐,不可以与0标识一起使用。 conversion:以下转换字符用来格式化时间：‘H’ 24 小时制的小时，被格式化为必要时带前导零的两位数，即 00 - 23。‘I’ 12 小时制的小时，被格式化为必要时带前导零的两位数，即 01 - 12。‘k’ 24 小时制的小时，即 0 - 23。‘l’ 12 小时制的小时，即 1 - 12。‘M’ 小时中的分钟，被格式化为必要时带前导零的两位数，即 00 - 59。‘S’ 分钟中的秒，被格式化为必要时带前导零的两位数，即 00 - 60 （”60” 是支持闰秒所需的一个特殊值）。‘L’ 秒中的毫秒，被格式化为必要时带前导零的三位数，即 000 - 999。‘N’ 秒中的毫微秒，被格式化为必要时带前导零的九位数，即 000000000 - 999999999。‘p’ 特定于语言环境的 上午或下午 标记以小写形式表示，例如 “am” 或 “pm”。使用转换前缀 ‘T’ 可以强行将此输出转换为大写形式。‘z’ 相对于 GMT 的 RFC 822 格式的数字时区偏移量，例如 -0800。‘Z’ 表示时区缩写形式的字符串。Formatter 的语言环境将取代参数的语言环境（如果有）。‘s’ 自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的秒数，即 Long.MIN_VALUE/1000 与 Long.MAX_VALUE/1000 之间的差值。‘Q’ 自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的毫秒数，即 Long.MIN_VALUE 与 Long.MAX_VALUE 之间的差值。 以下转换字符用来格式化日期：‘B’ 特定于语言环境的月份全称，例如 “January” 和 “February”。‘b’ 特定于语言环境的月份简称，例如 “Jan” 和 “Feb”。‘h’ 与 ‘b’ 相同。‘A’ 特定于语言环境的星期几全称，例如 “Sunday” 和 “Monday”‘a’ 特定于语言环境的星期几简称，例如 “Sun” 和 “Mon”‘C’ 除以 100 的四位数表示的年份，被格式化为必要时带前导零的两位数，即 00 - 99‘Y’ 年份，被格式化为必要时带前导零的四位数（至少），例如，0092 等于格里高利历的 92 CE。‘y’ 年份的最后两位数，被格式化为必要时带前导零的两位数，即 00 - 99。‘j’ 一年中的天数，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 001 - 366。‘m’ 月份，被格式化为必要时带前导零的两位数，即 01 - 13。‘d’ 一个月中的天数，被格式化为必要时带前导零两位数，即 01 - 31‘e’ 一个月中的天数，被格式化为两位数，即 1 - 31。 式化常见的日期/时间组合。:‘R’ 24 小时制的时间，被格式化为 “%tH:%tM”‘T’ 24 小时制的时间，被格式化为 “%tH:%tM:%tS”。‘r’ 12 小时制的时间，被格式化为 “%tI:%tM:%tS %Tp”。上午或下午标记 (‘%Tp’) 的位置可能与语言环境有关。‘D’ 日期，被格式化为 “%tm/%td/%ty”。‘F’ ISO 8601 格式的完整日期，被格式化为 “%tY-%tm-%td”。‘c’ 日期和时间，被格式化为 “%ta %tb %td %tT %tZ %tY”，例如 “Sun Jul 20 16:17:00 EDT 1969”。 格式化百分数%[argument_index$][flags][width]conversion 这里百分数其实就是我们一个固定格式，这里需要注意的是%是占位符的开始符号，所以我们用%需要用%%来表达原来的意思 System.out.println(String.format(&quot;%1$02d%%&quot;, 30));这个就是输出30%。 版权 转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © 烟花散尽13141 以上参考： https://www.cnblogs.com/xytop/articles/1277125.html https://www.cnblogs.com/fsjohnhuang/p/4094777.html","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"},{"name":"formatter","slug":"formatter","permalink":"https://zxhtom.oschina.io/tags/formatter/"}]},{"title":"mybatis关联","date":"2017-12-18T10:00:30.000Z","path":"zxh/20171218.html","text":"[TOC] web项目开发中目前很多企业都是在SSM框架基础上开发。其中的M指的的mybatis(ibatis).mybatis里指的一说的是规避了传统的jdbc等的繁琐。在mybatis中我们可以只用关注sql本身。而不用太在意之个执行过程。大大简化了我们平时的开发。mybatis深究的话会有很多要说的。今天我们只来看看mybatis中提供了映射中的关联标签。 数据准备数据结构下表stage_order中的stage_list是有stage表中ID组成的一个字符串，之间由逗号相隔。比如stage_list=1,2,3表示该stage_order中关联着ID为1或2或3的stage。我们得分别取查询stageID=1或2或3的stage进行实体映射展示。下一节我们看看实体的构造 实体准备基本实体(对应stage_order单表) 在下面的实体中出现的注解我们不需要在意，这是swagger框架的注解，在本章节中不需要理解。换句话说我们可以吧注解删掉。不会影响我们的功能的。 @ApiModel(description = &quot;阶段顺序表&quot;) @Table(name = &quot;STAGE_ORDER&quot;) public class StageOrder { @Id @ApiModelProperty(&quot;阶段顺序ID&quot;) @NotNull(message = &quot;阶段顺序ID不可为空(NULL)&quot;) private Long stageOrderId; @ApiModelProperty(&quot;路口编号&quot;) @NotNull(message = &quot;路口编号不可为空(NULL)&quot;) private Long intersectionId; @ApiModelProperty(&quot;相序名称&quot;) @NotBlank(message = &quot;相序名称不可为空白&quot;) @ByteLength(max = 30, message = &quot;相序名称长度不能超过{max}&quot;) private String orderName; @ApiModelProperty(&quot;阶段列表&quot;) @NotBlank(message = &quot;阶段列表不可为空白&quot;) @ByteLength(max = 200, message = &quot;阶段列表长度不能超过{max}&quot;) private String stageList; public Long getStageOrderId() { return stageOrderId; } public void setStageOrderId(Long stageOrderId) { this.stageOrderId = stageOrderId; } public Long getIntersectionId() { return intersectionId; } public void setIntersectionId(Long intersectionId) { this.intersectionId = intersectionId; } public String getOrderName() { return orderName; } public void setOrderName(String orderName) { this.orderName = orderName == null ? null : orderName.trim(); } public String getStageList() { return stageList; } public void setStageList(String stageList) { this.stageList = stageList == null ? null : stageList.trim(); } } 扩展实体public class StageOrderDto extends StageOrder { /** * 相位列表 */ private List&lt;Stage&gt; stageInfoList; public List&lt;Stage&gt; getStageInfoList() { return stageInfoList; } public void setStageInfoList(List&lt;Stage&gt; stageInfoList) { this.stageInfoList = stageInfoList; } } 基本映射一对一 有了上面的实体和对应的Table，那么我们如何在mybatis中将Table和实体关联呢。看如下在mapper.xml中的配置 &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.jsits.xk.dto.StageOrderDto&quot;&gt; &lt;id column=&quot;STAGE_ORDER_ID&quot; jdbcType=&quot;NUMERIC&quot; property=&quot;stageOrderId&quot;/&gt; &lt;result column=&quot;INTERSECTION_ID&quot; jdbcType=&quot;NUMERIC&quot; property=&quot;intersectionId&quot;/&gt; &lt;result column=&quot;ORDER_NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderName&quot;/&gt; &lt;result column=&quot;STAGE_LIST&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;stageList&quot;/&gt; &lt;association column=&quot;STAGE_LIST&quot; property=&quot;stageInfoList&quot; select=&quot;selectStageInfos&quot;/&gt; &lt;/resultMap&gt; 但是我们会发现resultMap中stageInfoList这个在跟数据库怎么对应呢？还有association是什么？assocaition中select又是什么？为什么assocaition中的column和上面一样？我想对于刚接触的朋友来说心里一定会有这些疑问。 上面已经说了resultmap是用来衔接实体去数据库表的桥梁。resultMap中ID属性就是一个唯一性的作用。一般只需要在当前xml中唯一就行了。因为在每个xml中有namespace,来确定当前的mapper.xml的唯一性。 resultMap字标签id 和result都是用来映射单列值到type对应的实体或者map中属性。在使用上ID是对应数据库中主键使用的。数据库中会有联合主键，在resultMap中就用两个ID标签对应就行了。还有一点ID也是用来做唯一标识的。当和其他对象进行比较的时候这个时候ID就有作用了。这里和数据库一样主键就是代表一条数据。这里也是同样的作用。在mybatis中有缓存机制。就是通过这个ID实现的。比如mybatis这个时候需要缓存这个对象。则以ID为key ，对象的json化为值存储到缓存中。 一对多 这里一对多就用到了上面的BaseResultMap这个resultMap了。上面我们的讲的ID和result就是我们平时简单单表查询中的一对一关系处理。但是association就是用来关联查询的。association中文翻译就是联想的意思。在mybatis中association的作用就是在查询到STAGE_LIST这个字段的时候默认会将STAGE_LIST的值传到selectStageInfos这个查询语句中查询。传递进去是按照上面的写法我们不能用#{stage_list}取，得通过#{id}获取。这里是默认的必须用#{id}.但是一个健全的框架不会这么死板的。下面我们在介绍如何动态传递。 association严格上来说应该是用于selectStageInfos查询获取的也是一个基本类型数据。但是在我们上面的需求描述中我们知道STAGE_LIST,对应到stage表中其实回事多条数据。所以我们在StageOrderDto中stageInfoList也是用list集合来承载的。这个时候用association不会出错。mybatis底层却不同，底层实际上是转换成了collection标签来实现的。应为collection对应的是集合的映射处理。所以追求完美的程序员在级联查询是如果级联出的是集合就用collection标签。但是两种情况用association都是可以的。 查询应用 说了这么多，下面我们通过两个查询看看查询的实现代码 &lt;select id=&quot;selectStageOrderDtoListByIntersectionId&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from stage_order where INTERSECTION_ID=#{intersectionId} &lt;/select&gt; &lt;select id=&quot;selectStageInfos&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.jsits.xk.model.Stage&quot;&gt; select &lt;include refid=&quot;Stage_Column_List&quot;/&gt; from stage where stage_id in (#{id}) &lt;/select&gt; 当我们调用selectStageOrderDtoListByIntersectionId通过intersectionId查询到数据的时候，会在通过查询到的STAGE_LIST作为条件调用selectStageInfos这个查询语句的。在selectStageInfos中的#{id}就是selectStageOrderDtoListByIntersectionId查询到的STAGE_LIST。 复杂映射 但是我们平时企业开发中光这样的查询有时候并不能满足我们的需求。常见复杂的查询有： 多重级联和联合主键查询 多重映射 多重查询说白了就是多用几次级联(association或collection)，对就是这个简单。这个可能有的人没有过甚至没想过。下面贴段实际的代码。因为下面代码在联合主键章节也需要用到。 &lt;sql id=&quot;Program_Column_List&quot;&gt; PHASE_LIST,PROGRAM_ID,PROGRAM_NAME,INTERSECTION_ID,STAGE_ID,STAGE_NAME,STAGE_SEQ,GREEN,RED_YELLOW,YELLOW,ALL_RED,MIN_GREEN,MAX_GREEN &lt;/sql&gt; &lt;resultMap id=&quot;weekProgramResultMap&quot; type=&quot;com.jsits.xk.dto.WeekPlanProgramDto&quot;&gt; &lt;result column=&quot;PLAN_ID&quot; property=&quot;planId&quot; /&gt; &lt;result column=&quot;PLAN_NAME&quot; property=&quot;planName&quot; /&gt; &lt;association column=&quot;{intersectionId=INTERSECTION_ID,dayPlanNo=PLAN_ID}&quot; property=&quot;dayPlanList&quot; select=&quot;selectDayPlanInfosByPlanNo&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;dayPlanResultMap&quot; type=&quot;com.jsits.xk.dto.DayPlanAndProgramListDto&quot;&gt; &lt;result property=&quot;timeDuration&quot; column=&quot;time_duration&quot; /&gt; &lt;result property=&quot;programId&quot; column=&quot;program_id&quot; /&gt; &lt;result property=&quot;stageOrderId&quot; column=&quot;stage_order_id&quot; /&gt; &lt;result property=&quot;dayPlanId&quot; column=&quot;day_plan_id&quot; /&gt; &lt;result property=&quot;phaseList&quot; column=&quot;phase_list&quot; /&gt; &lt;result property=&quot;programName&quot; column=&quot;program_name&quot; /&gt; &lt;result property=&quot;stageOrderName&quot; column=&quot;order_name&quot; /&gt; &lt;result property=&quot;controlModeId&quot; column=&quot;control_mode_id&quot; /&gt; &lt;result property=&quot;controlModeName&quot; column=&quot;control_mode_name&quot; /&gt; &lt;result property=&quot;cycle&quot; column=&quot;cycle&quot; /&gt; &lt;association column=&quot;program_id&quot; property=&quot;programList&quot; select=&quot;selectProgramInfosByProgramId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectProgramInfosByProgramId&quot; parameterType=&quot;long&quot; resultType=&quot;com.jsits.xk.model.Program&quot;&gt; select &lt;include refid=&quot;Program_Column_List&quot; /&gt; from program where program_id=#{id} &lt;/select&gt; &lt;select id=&quot;selectDayPlanInfosByPlanNo&quot; parameterType=&quot;java.util.HashMap&quot; resultMap=&quot;dayPlanResultMap&quot; &gt; select * from (select dp.day_plan_id, trim(REGEXP_REPLACE(to_char(dp.time_duration,&#39;0000&#39;),&#39;([[:digit:]]{2})([[:digit:]]{2})&#39;,&#39;\\1:\\2&#39;)) as time_duration, pg.program_id, pg.program_name, so.order_name, so.stage_order_id, cm.control_mode_id, cm.control_mode_name, &#39;120&#39; as cycle from day_plan dp left join control_mode cm on dp.control_mode_id=cm.control_mode_id left join program pg on dp.program_id=pg.program_id left join stage_order so on dp.stage_order_id=so.stage_order_id where dp.day_plan_no=#{dayPlanNo} and dp.intersection_id=#{intersectionId} ) group by (day_plan_id,time_duration,program_id,program_name,order_name,stage_order_id,control_mode_id,control_mode_name,cycle) order by time_duration asc &lt;/select&gt; &lt;select id=&quot;selectWeekInfosByIntersectionId&quot; parameterType=&quot;long&quot; resultMap=&quot;weekProgramResultMap&quot;&gt; select #{intersectionId} as intersection_id,week.plan_name,week.plan_id from ( select &#39;星期一&#39; as plan_name,intersection_id,monday as plan_id from week_plan union select &#39;星期二&#39; as plan_name,intersection_id,tuesday as plan_id from week_plan union select &#39;星期三&#39; as plan_name,intersection_id,wendesday as plan_id from week_plan union select &#39;星期四&#39; as plan_name,intersection_id,thursday as plan_id from week_plan union select &#39;星期五&#39; as plan_name,intersection_id,friday as plan_id from week_plan union select &#39;星期六&#39; as plan_name,intersection_id,saturday as plan_id from week_plan union select &#39;星期日&#39; as plan_name,intersection_id,sunday as plan_id from week_plan )week left join day_plan dp on dp.day_plan_no=week.plan_id where week.intersection_id=#{intersectionId} group by week.plan_id,week.plan_name,week.intersection_id order by week.plan_id &lt;/select&gt; 联合主键查询 在我们很多时候数据库中的主键并不是一个字段，而是通过两个甚至多个字段组合成主键。我们习惯上称之为联合主键。在多重映射中的代码中我们可以看到weekProgramResultMap中级联selectDayPlanInfosByPlanNo这个sql查询。但是有意思的是column中并不是我们熟悉的一个字段。而是通过花括号做首尾，中间加入多个字段组成的一个字符串。这个就是我们本章节引入的概念—联合主键级联查询。column属性值我们分析一下可以看出intersectionId=INTERSECTION_ID和dayPlanNo=PLAN_ID组成的。我们可以看成是两个map，等号前是key等号后是value。key就是我们在新的select中引用的key，及#{key}方式获取。value就是原来的select查询获得的数据。也是通过value来查询新的数据的。这里就解决了我们上面基本映射章节说必须用#{id}的局限性。所以在上面中如何我们不想用#{id},那么需要修改column的传入风格{stageId=stage_list}就可以用#{stageId} 简单说明 工作遇到的需求，mybatis还有很多神操作。以后有机会更新。在mybatis中映射并不是仅仅字段这么简单。还有点逗风格的引用。这些以后看时间在更新。 常用标签格言 人生贵知心，定交无暮早。 —— 袁中道","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zxhtom.oschina.io/tags/mybatis/"}]},{"title":"内网穿透好帮手","date":"2017-11-11T09:48:30.000Z","path":"zxh/20171111.html","text":"[TOC]IT程序员经常会用到服务器，但是为了一个功能不值得买一个阿里云服务器，通过ngrok可以实现本地转外网穿透 作为一个 Web 开发者，我如何让其他非局域网的人可以体验或者协助调试我的网站呢？当我在开发支付宝、微信这类应用时，如何能直接连接到我的本地环境呢？Ngrok 为你提供了一个解决方案，它能帮助你把你本地运行的服务映射到一个公网地址，这样你就相当于部署到了互联网上。例如我本地跑了一个 http://127.0.0.1:8080 这样的一个 Web 服务，当我通过 ngrok demo 8080 运行 Ngrok 之后，任何想访问我网站的人就可以通过 http://demo.ngrok.io 来访问我的网站了。 ngrox介绍 网上介绍很多，ngrox就是一个反向代理。简单的说我们可以将外部的请求映射到本地来。通俗的将就是讲本地对外公布了。 ngrox使用 首先到ngrok官网上下载ngrok ngrok软件。 下载后解压我们可以看到只有一个ngrok客户端。 双击ngrok.exe会弹出cmd窗口 在上面的也可以通过ngrok -help命令获得以下提示信息。其中examples中是告诉我们平时使用的映射命令。有了客户端我们就可以进行我们的内外网映射了。但是在映射之前我们还需要注册一个账号用来使用这个客户端 注册账号 在ngrok注册登录页面可以先注册一个账号并登陆。登录后页面展示两条命令就是我们本地操作该两条命令就可以映射了。 这里提供一个免费的账号：6vYfEsgm4TRSqoYfkywws_36L3cE5cUz24x9KjMaovX 映射内网 注册账号之后上一步其实已经官网提示如何映射了。如果我们注册的账号的free版本的。那么很遗憾只能通过ngrok http 端口号这个命令来映射了。而且映射的地址形式都是这样的http://XXXX.ngrok.io，其中XXXX是随机生成的字符串。 使用映射个性化域名1 上面我们虽然已经将内网映射到外网了，但是每种不足的是我们的外网地址里面有一部分是随机字符串，考虑到不好记忆我们。我们可以采用下面命令ngrok http -subdomain=zxh 8080 但是由于上面账号是free版本的。所以读者应该会遇到下面的问题这里我们只能按照上面提示去升级 使用映射个性化域名2 这步骤对于了解Linux可能会很轻松。因为ngrok采用的go语言编写的。我们既然无法使用个性地址又不想花钱升级，那么作为程序员我们就重新编译源码待更新","tags":[{"name":"ngrok","slug":"ngrok","permalink":"https://zxhtom.oschina.io/tags/ngrok/"}]},{"title":"Sublime Text3激活及个性化配置","date":"2017-11-03T15:22:30.000Z","path":"zxh/20171103.html","text":"[TOC]在我们的开发过程中，选择正确的开发工具会让我们事半功倍。作为后端开发我们熟悉的myeclipse和itellij idea这些工具我也介绍曾介绍过关于他们的安装及破解。但是我们并不能仅仅使用后端。前端开发工具也是有很多的。今天让我们来破解和配置sublime text这个前端神器。 软件激活激活码(build 3143) —– BEGIN LICENSE —– TwitterInc 200 User License EA7E-890007 1D77F72E 390CDD93 4DCBA022 FAF60790 61AA12C0 A37081C5 D0316412 4584D136 94D7F7D4 95BC8C1C 527DA828 560BB037 D1EDDD8C AE7B379F 50C9D69D B35179EF 2FE898C4 8E4277A8 555CE714 E1FB0E43 D5D52613 C3D12E98 BC49967F 7652EED2 9D2D2E61 67610860 6D338B72 5CF95C69 E36B85CC 84991F19 7575D828 470A92AB —— END LICENSE —— 激活步骤我们安装好软件之后，在Help–&gt;Register Licence中贴入我们上面的激活码。这里申明一下本人激活时2017年11月03日。离得久远的激活可能会因为用此激活码的人太多导致失效的。所以最好越早激活越好 风格设置设置主题风格Adaptive.sublime-theme这个主题挺好的，个人喜欢全屏黑，可能程序员的个性吧。我们在Preferences中选择Theme后选择这个主题就可以了。其他的主题读者可以根据自己的喜好设置安装配置。 设置左侧风格如果选择了Adaptive.sublime-theme我们左侧就会同步主题。如果其他主题没有同步的，我们还可以选择Afterglow.sublime-theme这个主题，然后在对应的主题的user配置文件中进行配置 { &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.tmTheme&quot;, &quot;font_face&quot;: &quot;YaHei Consolas Hybrid&quot;, &quot;font_options&quot;: [ &quot;no_bold&quot;, &quot;no_italic&quot;, &quot;no_antialias&quot;, &quot;gray_antialias&quot; ], &quot;font_size&quot;: 13, &quot;ignored_packages&quot;: [ &quot;Markdown&quot;, &quot;Vintage&quot; ], &quot;tab_height&quot;: 12, &quot;theme&quot;: &quot;Afterglow.sublime-theme&quot; } 设置markdown浏览器预览 通过sublime text3我们如果使用markdown来写博客的。肯定会装关于markdown的插件的 Markdown Editing // Markdown编辑和语法高亮支持 Markdown Preview // Markdown导出html预览支持 LiveReload // Markdown刷新浏览器中的Html 这里我们安装了Markdown Editing 插件后我选择的是打开md格式文件用MultiMarkdown格式打开，所以在Editing对应的MultiMarkdown设置了&quot;draw_centered&quot;: false，让md文章靠左排版。然后我们还是需要设置Markdown Preview 中设置如下 &quot;browser&quot;: &quot;chrome&quot;, &quot;enable_autoreload&quot;: true, &quot;enable_highlight&quot;: true 其中browser就是你希望那个浏览器打开md文章预览。浏览器对应名称在preview的默认配置文件中有解释。enable_autoreload就是设置是否自动加载md格式成html。但是浏览器中的不会改变。如果想做到实时刷新我们还需要最后一个插件LiveReload。 安装完成LiveReload后需要重启sublime text3. 按下Ctrl+Shift+p 输入 LiveReload: Enable/disable plug-ins, 回车. 然后选择 Simple Reload with delay (400ms), 也可以选择 Simple Reload. 这个命令运行一次就可以了，无需每打开一个文件就运行一次. 至此以后改变md格式只要保存后400ms。浏览器自动刷新 设置字体编码安装ConverToUTF8插件 sublime text基本命令简单介绍Ctrl+Shift+P : 召唤命令输入窗口。后面得命令都是在这里执行 ip : 安装插件rp : 移除插件mp : 预览md文件(前提装了markdown preview) 也可以设置快捷键","tags":[{"name":"前端","slug":"前端","permalink":"https://zxhtom.oschina.io/tags/前端/"},{"name":"sublime text3","slug":"sublime-text3","permalink":"https://zxhtom.oschina.io/tags/sublime-text3/"}]},{"title":"log4j2的使用介绍","date":"2017-10-30T05:49:50.000Z","path":"zxh/20171030.html","text":"一张图带你了解log4j2使用 环境准备 log4j-api-2.3.jar log4j-core-2.3.jar log4j-web-2.3.jar (在web项目中需要引入的jar包。这里做了数据的初始化) 数据初始化 我们知道在web项目的入口在web.xml中。所以我们得加入log4j的监听器和过滤器 &lt;listener&gt; &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.logging.log4j.web.Log4jServletFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt; &lt;/filter-mapping&gt; 到这里我们log4j就已经配置成功了。但是在实际开发中发现没有上面的监听器和过滤器也是可以的。由于时间问题没有研究原因。大概网上查阅了一下好像是log4j源码中有默认的配置。我们上面没有指定具体的配置文件的地址在哪，log4j就会读取jar中默认的配置。系统中选择的默认配置文件有以下几种： classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件. classpath下的名为log4j2-test.xml的文件. classpath下名为log4j2.json 或者log4j2.jsn的文件. classpath下名为log4j2.xml的文件. log4j2配置详解 logger等级 共有8个等级 按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF. All:最低等级的，用于打开所有日志记录. Trace:是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出. Debug:指出细粒度信息事件对调试应用程序是非常有帮助的. Info:消息在粗粒度级别上突出强调应用程序的运行过程. Warn:输出警告及warn以下级别的日志. Error:输出错误信息日志. Fatal:输出每个严重的错误事件将会导致应用程序的退出的日志. OFF:最高等级的，用于关闭所有日志记录. 举例 像上面那样我们已经配置了很多Logger了。每个Logger都有自己的名字。我们在代码中这样使用private static final Logger bossRequestTeletextLogger = LogManager.getLogger(&quot;bossRequestTeletextLogger&quot;);意思就是bossRequestTeletxtLogger将使用我们最后一个Logger，该Logger等级是info等级的。存储采用的是teletextLoggerFile存储到文件中的。","tags":[{"name":"log4j2","slug":"log4j2","permalink":"https://zxhtom.oschina.io/tags/log4j2/"}]},{"title":"pdf.js跨域加载文件","date":"2017-10-29T02:12:30.000Z","path":"zxh/20171029.html","text":"pdf.js一个基于Html的工具类，熟悉pdf.js的朋友们很清楚，pdf.js帮助我们做了很多事。尤其金融类网站会产生很多的报表。需要在线预览。pdf.js绝对是我们的首选 本地预览在pdf.js的官网上下载的demo中我们就可以直接进行预览。官网的案列在web文件夹下的view.html。这里我整理了一个pdf.js精简版的。 这两个demo里面加载的是本地文件。这里没什么说的。其中demo2的效果如下。代码也很简单： pdfjs 为我们做了其他的操作，。我们通过pdfjs只需要将本地文件当做参数传递给viewer.html就可以了。 远程加载(跨域) 通过上面我们很轻松在实际项目中实现pdf的预览。但是这样的预览存在一个问题。我们分布式项目中往往资源服务和业务服务不在同一台服务器上。这个时候我们在对文件进行预览就时跨域操作了。遇到这个问题我想当然的将上面的a.pdf 换成了我们远程pdf地址了。 首先看看我们的远程文件是否正常 然后再看看我们的代码修改是否正常 所有的就绪后，我很高兴的刷新了demo2的页面并进行了操作。但是令人很失望。报错了 报错大概的意思就是文件没找到。为什么没找到是因为我们的文件是远程文件。pdf.js跨域了。在网上找了很多答案。有的说是在web.xml配置放置跨域的操作。测试无效。还有的说请求头修改成跨域的但是没说明白。没有实现。最终我发小在viewer.html中获取file文件参数的原因是需要通过该文件获取文件的文件流从而获取数据对viewer.html记性渲染。所以我换了一下思路。 既然是获取文件流为什么一开始不直接传递文件流。基于这个想法。我开始实现获取远程地址的文件流。果然让我找到了方法。我们先通过httpclient爬虫获取远程的文件流。 public InputStream getYCFile(String urlPath) { InputStream inputStream = null; try { try { String strUrl = urlPath.trim(); URL url=new URL(strUrl); //打开请求连接 URLConnection connection = url.openConnection(); HttpURLConnection httpURLConnection=(HttpURLConnection) connection; httpURLConnection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); // 取得输入流，并使用Reader读取 inputStream = httpURLConnection.getInputStream(); return inputStream; } catch (IOException e) { System.out.println(e.getMessage()); inputStream = null; } } catch (Exception e) { System.out.println(e.getMessage()); inputStream = null; } return inputStream; } 就通过这个方法我们只要传递的地址是正确的，我就可以将该远程文件的文件流返回给你。 基于这个方法我们只需要在springmvc中在前台请求到后台的时候调用该方法就可以获取文件流。在通过response将文件流返回到前台。 前台： &lt;iframe src=&quot;../test/js/pdfjs/web/viewer.html?file=&lt;%=basePath%&gt;source/http://192.168.1.184:8080/manage/spirng.pdf&quot; width=&quot;100%&quot; height=&quot;750&quot;&gt;&lt;/iframe&gt; 最终我们看看远程的效果。是不是我们可以预览远程的了。其中的好处无疑减轻服务器压力了。 因为在SSM项目集成的。里面有好多的配置没有细说。有不清楚了，可以扫描左侧二维码加群找我。源码下载","tags":[{"name":"spring","slug":"spring","permalink":"https://zxhtom.oschina.io/tags/spring/"}]},{"title":"hexo 简单介绍","date":"2017-10-28T04:12:30.000Z","path":"zxh/20171028.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zxhtom.oschina.io/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zxhtom.oschina.io/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://zxhtom.oschina.io/tags/前端/"}]},{"title":"设计模式(一)----工厂模式","date":"2017-06-11T06:34:00.000Z","path":"zxh/20170611.html","text":"基本的业务逻辑的编写并不是难事 基本的业务逻辑的编写并不是难事，作为一个合格的程序员能够编写出易扩展，可维护，高内聚，低耦合的代码才是真正的能力。所以从今天开始会陆陆续续的研究一下设计模式。设计模式并不是针对编程语言，而是考察的编程的思想。 设计模式中最简单的应该就是工厂模式了，在我们企业项目中工厂模式和单例模式也是应用最多的模式了。今天我们就简单的介绍一下工厂模式。都是个人总结，不喜勿喷！！！ 描述 工厂模式就是简化了对象的构建。正常情况下我们在Java中是通过new来构建对象，但是有的对象可能需要设置一些默认值等等的额外操作。这个时候为了简化用户的操作我们引入了工厂模式的设计思想。工厂模式就是将构建对象的过程封装在工厂类中，我们需要具体的工厂类中的对象我们就可以通过工厂来获取了。提高了使用的灵活性。 优点 通过上面的描述我们能够轻松的发现工厂模式带来的好处。有了工厂模式我们构建对象不需要关注对象构建的过程，我们需要的对象只需要想工厂发出生产对象的指令就可以了。抛弃构建的复杂过程，增加代码的阅读性。 情景再现 工业时代到来之前我们的生产都是人工的，换句话说就是我们需要什么，我们需要自己动手去完成。而有了工厂之后就摆脱了自己的双手。比如说你现在是一家服装厂的老板，夏天来临你需要购进一批夏季服装。相信现在的你不可能自己动手去做衣服，都是通过跟服装厂联系，告诉服装厂你需要衣服的款式，一段时间后你就获得了这些你指定的衣服。至于这些衣服是如何实现的你根本不用关心。服装厂在这里就是我们工厂模式的工厂。 分类 工厂模式又细分为三种：简单工厂模式+工厂方法模式+抽象工厂模式 简单工厂模式: 简单工厂模式是我们上面的情景再现的情况，简单工厂就是说所有的细节都是依靠一个工厂统一完成，这种模式下工厂的压力特别大。 工厂方法模式:工厂方法模式在上面情景的基础上将工厂进行了更改优化，之前工厂是一个工厂生产一年四季的衣服，现在抽象一个工厂类，在有四个工厂是该抽象工厂的具体实现类，这四个工厂具体分别负责生产春夏秋冬衣服。这样仍然是工厂模式，只不过相对简单工厂模式已经减轻了工厂的压力了。 抽象工厂模式:抽象工厂模式在抽象方法模式的基础上有进行了强化，抽象方法中是一个具体工厂的实现类负责生产一种类型的衣服，而在抽象工厂模式下一个具体的工厂的实现类可以生产多个类别的衣服。这样更加的减轻服装厂的压力了。 代码实现这里我们就实现简单工厂模式的代码，其他两种的模式知识在简单工厂模式的基础上进行工厂类的强化 服装抽象类(Clothes) package zhangxinhua.JavaDesignDetails.工厂模式.features; public abstract class Clothes { //袖口的数量 private int wristband=2; //领口的数量 private int neckline=1; //穿衣方式 public void hold() { System.out.println(&quot;我的穿衣方式是从领口&quot;); } public int getWristband() { return wristband; } public void setWristband(int wristband) { this.wristband = wristband; } public int getNeckline() { return neckline; } public void setNeckline(int neckline) { this.neckline = neckline; } } 具体服装类一(AutumnCloth) package zhangxinhua.JavaDesignDetails.工厂模式.special; import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes; public class AutumnCloth extends Clothes { @Override public void hold() { System.out.println(&quot;我是秋装，我要倒着穿&quot;); } } 具体服装类二(SpringCloth) package zhangxinhua.JavaDesignDetails.工厂模式.special; import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes; public class SpringCloth extends Clothes { @Override public void hold() { System.out.println(&quot;我是春装，我要从领口穿衣&quot;); } } 具体服装类三(SummerCloth) package zhangxinhua.JavaDesignDetails.工厂模式.special; import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes; public class SummerCloth extends Clothes { @Override public void hold() { System.out.println(&quot;我是夏装，我要从怀口穿&quot;); } } 工厂类(Clothfactory) package zhangxinhua.JavaDesignDetails.工厂模式.简单工厂模式.factory; import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes; import zhangxinhua.JavaDesignDetails.工厂模式.special.AutumnCloth; import zhangxinhua.JavaDesignDetails.工厂模式.special.SpringCloth; import zhangxinhua.JavaDesignDetails.工厂模式.special.SummerCloth; public class ClothFactory { public static Clothes createClothes(String type) throws Exception { Clothes clothes=null; switch (type) { case &quot;spring&quot;: clothes=new SpringCloth(); break; case &quot;summer&quot;: clothes=new SummerCloth(); break; case &quot;autumn&quot;: clothes=new AutumnCloth(); break; default: throw new Exception(&quot;目前不支持你指定的类型&quot;); } return clothes; } } 客户端调用(client) package zhangxinhua.JavaDesignDetails.工厂模式.简单工厂模式.client; import zhangxinhua.JavaDesignDetails.工厂模式.features.Clothes; import zhangxinhua.JavaDesignDetails.工厂模式.简单工厂模式.factory.ClothFactory; public class client { public static void main(String[] args) throws Exception { System.out.println(&quot;工厂你给我一套春装&quot;); Clothes spring = ClothFactory.createClothes(&quot;spring&quot;); spring.hold(); System.out.println(&quot;********************&quot;); System.out.println(&quot;工厂你给我一套秋装&quot;); Clothes autum = ClothFactory.createClothes(&quot;autumn&quot;); autum.hold(); System.out.println(&quot;********************&quot;); System.out.println(&quot;工厂你给我一套夏装&quot;); Clothes summer = ClothFactory.createClothes(&quot;summer&quot;); summer.hold(); System.out.println(&quot;********************&quot;); } } 效果展示 总结 设计模式的学习是潜移默化，学习设计模式不要急，成长是需要时间的，今天的努力，将来的一天终会回报。 有需要源码的，或者有不理解，欢迎扫描左侧二维码，进群交流讨论。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"简单认识Nginx---负载均衡","date":"2017-04-28T09:48:00.000Z","path":"zxh/20170428.html","text":"中大型项目都会考虑到分布式 中大型项目都会考虑到分布式，前面几篇文章着重介绍了数据处理的技术集群。今天来研究一下关于服务器的负载均衡–Nginx。他除了静态资源的处理外还有可以决定将请求置于那台服务上。 Nginx的安装点我下载 下载好之后我们可以直接点击进行服务开启 友情提醒：nginx的路径不能有汉字 - 或者我们通过cmd命令来开启服务。首先到D:\\Chirs\\Downloads\\nginx-1.11.11\\nginx-1.11.11目录下执行命令nginx - 顺便说一下关闭命令：nginx -s stop - 就这么简单nginx开启了。查看是否开启成功只需要打开浏览器输入127.0.0.1或者localhostNginx的基本命令– - 上面已经提到了启动命令： nginx.exe 重启： nginx.exe -s reload 关闭：nginx.exe -s stop 检测配置合法性：nginx.exe -t友情提醒：尽量在重启的时候用重启命令。有的人喜欢先关闭服务在开启服务。这样做如果修改后的配置是错误的，就会影响到nginx的使用。而如果用重启命令，就算修改后的配置错误了，仅仅影响新修改的功能，之前的服务仍然可以执行。 Nginx与Tomcat实现负载均衡 在现在数万访问量的大数据时代，分布式是我们所必须要考虑的一个因素。那么nginx就可以帮助我们缓解大数据的压力。我们可以通过Nginx的反向代理将请求发送到不同的tomat，这样就大大的缓解了我们服务器的压力了。 准备两个Tomcat 想要实现负载均衡我们就得有多个服务器，这样nginx才能够将请求平均分配在不同的服务上。所以这里为了掩饰效果我们只准备两个服务 器(Tomcat)。配置不同的访问端口就可以了。 nginx.conf首先贴出一段官网的windows的配置文件。下面逐条解释。 #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } #user nobody; ： user属性在windows中不用设置，人家注释写的很清楚 nobody,但是在Linux系统中我们建议写 user nginx(用户) nginx(组) 。 worker_processes 1; ： 工作进程 正常是CPU*2 error_log : nginx 的错误日志记录的文件地址 pid ： 在windows中每个进程在后台都是有一个pid的。 events : 里面设置一些属性比如连接数 worker_connections http ： http就是nginx通过设置的http实现负载均衡的 include mime.types; ： 设定mime类型,类型由mime.type文件定义 default_type application/octet-stream; ： 设置默认的请求类型 log_format ： 日志的输出格式。 日志格式参数解释： $remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； $remote_user：用来记录客户端用户名称； $time_local： 用来记录访问时间与时区； $request： 用来记录请求的url与http协议； $status： 用来记录请求状态；成功是200， $body_bytes_sent ：记录发送给客户端文件主体内容大小； $http_referer：用来记录从那个页面链接访问过来的； $http_user_agent：记录客户浏览器的相关信息； sendfile on; : sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 - `tcp_nopush on;`: 此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 详细 nginx.conf修改– - 上面我们已经详细的介绍了nginx的各个参数的设置了。在配置之前我们先看看nginx初始配置http的location - 通过上面的我们可以看出，当我们访问localhost(server_name):80(listen)的时候，nginx就会自动跳转到html文件夹中的index.html或者是index.htm的页面上了。 - 我们现在要做的就是在访问nginx是随机的跳转到我们指定的Tomcat上。相信大家都知道了，就是修改location的映射路径就行了。但是我们的映射路径是个选择器，所以我们首先构造一个选择器出来upstream mynginxserver { server 192.168.1.183:8888 weight=2; server 192.168.1.183:8080 weight=1; } - 其中weight是权重，就是nginx在随机选择的时候回根据这个权重去选择服务。 - 然后我们将location的映射路径映射到mynginserver上就行了。location / { proxy_pass http://mynginxserver; }注意： proxy_pass 后必须以http://开头。 一切配置好之后我们重启nginx（nginx.exe -s reload）。这个时候我们先分别看看两个Tomcat访问的效果注意看路径的端口是不同的Tomcat1： Tomcat2： 然后我们这个时候在访问nginx的端口：http://192.168.1.183:802/springtests/ 上面的效果就是同一个请求但是请求的页面是两个页面，实际上是请求的两个Tomcat。我们实际运行中会在两个Tomcat上放置完全相同的项目。这样用户体验就是使用的同一个项目，但是我们已经实现了负载均衡了。 负载均衡的几个策略 上面我们已经实现了负载均衡。nginx给我提供了关于负载均衡的策略。 默认策略–轮询： upstream mynginxserver { server 192.168.1.183:8888; server 192.168.1.183:8080; } 通过请求的时间顺序请求不同的Tomcat。如果某一个宕机了，则自动忽略。 最少链接 : 顾名思义就是在选择的时候谁的连接数最少，就选择谁 upstream mynginxserver { least_conn; server 192.168.1.183:8888; server 192.168.1.183:8080; } weight权重： 这种方式也是我上面实现负载均衡采用的方式。默认值是1 。就是在选择具体发送到哪一个Tomcat的时候是根据Tomcat的权重判断的。 upstream mynginxserver { server 192.168.1.183:8888 weight=2; server 192.168.1.183:8080 weight=1; } ip_hash : 这个就是根据当前请求的ip，根据ip算出对应的hash值，然后在根据hash值选择对应的Tomcat。这种效果就是一台客户端至始至终访问的都是同一台Tomcat。这里的session就是一样的。 upstream mynginxserver { ip_hash; server 192.168.1.183:8888 ; server 192.168.1.183:8080 ; } url_hash: 和ip_hash是一个效果 upstream mynginxserver { hash $request_url; server 192.168.1.183:8888; server 192.168.1.183:8080; } fair：根据响应时间来定的。谁的响应时间短，就连谁。 upstream mynginxserver { server 192.168.1.183:8888 ; server 192.168.1.183:8080 ; fair; } nginx地址映射 nginx除了作为服务器的负载均衡外，还有一个亮点就是地址映射。作为资源服务器来使用。在我们的web开发中经常需要上传资源到服务上。我们总不能将资源放在Tomcat上。这样会大大增加Tomcat的压力的。而且这样数据很容易丢失的。nginx就可以解决这个问题。 其实在上面实现负载均衡的时候就已经实现了地址映射。location就是地址映射的桥梁。 location ~ ^/images/(.*) # location ~ ^/images/(.*\\.jpg) #“.”表示任何字符，“*”表示任意数量， #“\\.jpg”表示jpg后缀名的文件 { expires 1s; alias D:/zxh/test/$1; #“$1”表是location后面（）的内容 index index.html index.htm; break; } 上面的location表示在通过server+port+^images^.^的形式就会映射到D:/zxh/test这个文件夹下。比如我在浏览器中访问：http://192.168.1.183:802/images/test.jpg 这个时候nginx就会去访问D:/zxh/test下时候有test.jpg的图片。 以上是在网上参考别人写的整理。不喜勿喷！@","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Windows下的bat原来可以为我们做很多","date":"2017-04-22T05:18:00.000Z","path":"zxh/20170422.html","text":"用了windows系统这么多年了，对bat也不是很了解。最近研究了一下bat的用法。这里就大概列举一下自己的用法** 用了windows系统这么多年了，对bat也不是很了解。最近研究了一下bat的用法。这里就大概列举一下自己的用法 参考网址 基本命令echo echo我们可以理解成程序中的输出，和我们Java的System.out.println是一个效果。 关于echo有两种设置 echo on 和echo off.前者是在此命令之后的命令都会显示输出，后者则不显示后面的执行命令了 @- @ 的功能和echo off的功能一样都是让命令不显示的。唯一的区别的@ 影响的是当前行而echo off影响的是在其后的所有的命令行。 @echo off redis-server.exe redis.conf @pause 例如上面的bat文件的语句最终执行的效果是 echo off 这个命令不显示 因为@ 控制当前行不显示。redis-server.exe redis.conf 这个命令也不显示 。因为echo off之后的命令都不现实。除非遇到echo on在此开启了显示的功能。 call call别人说和start功能一样，但是自己测试call无法使用，取而代之的我用的是start， start和call的作用就是在本bat文件中调用了别的bat文件。如果不用start或者call的话，那么本bat文件将执行完别的bat就不在继续执行本bat的其他语句了。相当于Java中的break了。 pause pause是暂停的意思，就是bat执行完了之后cmd窗口不会关闭而是在pause的地方输出 press any key …. 。他和exit相对。exit是指程序结束后就关闭窗口。正常pause和exit在文件的最后存在。 rem 作为程序员都是知道注释的重要性的。就算是自己写的代码没有良好的注释过一段时间自己都会忘记这段代码的作用。而在bat批处理语言中rem就是起到注释的作用。rem 我是注释 参数传递 Java或者其他语言中都是可以进行参数传递的，这样可以增加各个模块的联系，bat也是可以传递参数的。他的传递参数的方法比较特别，不需要指定参数的类型。只是按参数的顺序来获取的。分别用%0~%9来获取参数。这样也就是说参数只能是9个。其中%0表示的bat方法的本身。%1~%9表示第几个参数。 新建一个method.bat,内容为echo %1。我们新开cmd窗口。首先cd到method.bat所在的文件目录中。执行语句 method.bat helloworld 程序结果 为 helloworld。 特殊命令 上面的一些基础的命令之外还有一些属于高级命令 ，正常情况写我们做逻辑判断的时候经常用到 if goto choice for，这四个使我们经常用到。 if if 就是我们用到的程序判断，根据条件执行不同的语句。其中的基本格式如下 if “%1”==”test” echo test 上面的代码执行的效果就是输入了test的参数就会输出test 结果，输入的可以是“ hello world ” ,在程序中的参数就是带引号的参数。 if [not] exist 判断不存在是执行的语句 if exist 判断存在时存在的语句 if errorlevel num 根据程序的返回值判断 goto goto就是跳转到哪里 基本语法 goto zxh :zxh echo 跳转啦 其中goto去的端点 需要用：开头 choice 这个选择项用的挺多的，因为考虑程序的大众化，我们程序正常会给用户提供选择，这里就需要用到了choice了。 关于choice中有哪些参数，我们可以打开cmd窗口执行 choice /? 上面的一张图片已经解释了choice的选项说明，我们有设么格式的提示选项上面的图片事列已经列出了五种类型的。我们根据不同需求些不同的bat. 其中在/c后面的提示列表的编号我们一次是1,2,3….N。在我们根据errorlevel的值判断的时候必须从高到底比如如下一段代码才有效 @echo off choice /C dme /M &quot;defrag,mem,end&quot; if errorlevel 3 goto end if errorlevel 2 goto mem if errorlevel 1 goto defrag :defrag echo I am defrag goto end :mem echo I am mem goto end :end echo good bye pause for for循环是我们遍历数据用的最多了。我们经常通过for来执行相同理念的操作。 FOR %%variable IN (set) DO command [command-parameters] 上面的for循环其实用Java语言写就是一下代码 for(Object obj in List&lt;Object&gt;){ //执行操作 } 所以上面的variable就是下面的obj set 就是下面的list集合 command是我们的执行操作 command parameters 是我们执行操作的时候用到的参数正常就是variable(obj)","tags":[{"name":"bat语法","slug":"bat语法","permalink":"https://zxhtom.oschina.io/tags/bat语法/"},{"name":"命令","slug":"命令","permalink":"https://zxhtom.oschina.io/tags/命令/"}]},{"title":"Spring 集成Kafka(完整版)","date":"2017-04-16T13:31:00.000Z","path":"zxh/20170416.html","text":"前面的文章我们已经完成了Kafka基于Zookeeper的集群的搭建了 前面的文章我们已经完成了Kafka基于Zookeeper的集群的搭建了。Kafka集群搭建请点我。记过几天的研究已经实现Spring的集成了。本文重点 jar包准备 集成是基于spring-integration-kafka完成的。我这里用的项目是maven。该jar包在maven的位置 &lt;dependency&gt; &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt; &lt;artifactId&gt;spring-integration-kafka&lt;/artifactId&gt; &lt;version&gt;1.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 友情提醒：自己在网上看的教程多引入了kafka_2.10jar包。我的项目报错。建议搭建指引入和kafka相关的上面那个jar包 配置生产者(spring-kafka-producer.xml) 有了jar包我们只需要在spring的配置文件中配置就行了。这里我单独将生产者和消费者进行抽离配置 首先我们配置生产消息的频道(工具类)，这个频道基于queue。最后我们在消息发送也是通过该类实现发送消息的 &lt;int:channel id=&quot;kafkaProducerChannel&quot;&gt; &lt;int:queue /&gt; &lt;/int:channel&gt; 有了频道我们需要将频道和消息分类结合起来 ， outbound-channel-adapter 。顾名思义发送+频道+分类。该类就是设置这三个的联系的。这里我们主要看的是kafka-producer-context-ref。他是生产者消息的来源地 &lt;int-kafka:outbound-channel-adapter id=&quot;kafkaOutboundChannelAdapterTopic&quot; kafka-producer-context-ref=&quot;producerContextTopic&quot; auto-startup=&quot;true&quot; channel=&quot;kafkaProducerChannel&quot; order=&quot;3&quot;&gt; &lt;int:poller fixed-delay=&quot;1000&quot; time-unit=&quot;MILLISECONDS&quot; receive-timeout=&quot;1&quot; task-executor=&quot;taskExecutor&quot; /&gt; &lt;/int-kafka:outbound-channel-adapter&gt; 生产者的类别设置。及消息的编码序列化等操作都是该类设置的首先就是这里的topic。每个topic对应一个类。topic中的broker-list是kafka服务(集群)。key-serializer和key-encoder分别设置序列化和编码。两者只需要设置一个就行。value-class-type是消息的类型。value-serializer和value-encoder和key是一样的解释 &lt;int-kafka:producer-context id=&quot;producerContextTopic&quot; producer-properties=&quot;producerProperties&quot;&gt; &lt;int-kafka:producer-configurations&gt; &lt;!-- 多个topic配置 broker-list kafaka服务 key_serializer value-serializer 就是用了自己的编码格式 value-class-type 指定发送消息的类型--&gt; &lt;int-kafka:producer-configuration broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot; value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot; topic=&quot;testTopic&quot; /&gt; &lt;int-kafka:producer-configuration broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot; value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot; topic=&quot;myTopic&quot; /&gt; &lt;/int-kafka:producer-configurations&gt; &lt;/int-kafka:producer-context&gt; 上面消费者设置的序列化我们需要单独设置一下。我们可以采用spring-integration-kafka提供的序列化类。但是用了那个序列只能传递字符串。我们可以从定义该类实现传递对象(包括字符串)&lt;bean id=&quot;stringSerializer&quot; class=&quot;com.bshinfo.web.base.kafka.producer.MySerializer&quot; /&gt; 完整配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:int=&quot;http://www.springframework.org/schema/integration&quot; xmlns:int-kafka=&quot;http://www.springframework.org/schema/integration/kafka&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/integration/kafka http://www.springframework.org/schema/integration/kafka/spring-integration-kafka.xsd http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt; &lt;!-- 生产者生产信息是键值对内容的格式。默认是 org.apache.kafka.common.serialization.StringSerializer 这里我们重写方法。便于方法传递对象 具体看MySerializer--&gt; &lt;bean id=&quot;stringSerializer&quot; class=&quot;com.bshinfo.web.base.kafka.producer.MySerializer&quot; /&gt; &lt;!-- 这里的Encoder在下面没有用到 删掉也可以 Encoder和Serializer只用设置一个就行了。 consumer.xml中的配置也是一样 --&gt; &lt;!-- &lt;bean id=&quot;kafkaEncoder&quot; class=&quot;org.springframework.integration.kafka.serializer.avro.AvroReflectDatumBackedKafkaEncoder&quot;&gt; &lt;constructor-arg value=&quot;com.kafka.demo.util.ObjectEncoder&quot; /&gt; &lt;/bean&gt; --&gt; &lt;!-- 生产者一些配置属性。不配置按默认执行 --&gt; &lt;bean id=&quot;producerProperties&quot; class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;topic.metadata.refresh.interval.ms&quot;&gt;3600000&lt;/prop&gt; &lt;prop key=&quot;message.send.max.retries&quot;&gt;5&lt;/prop&gt; &lt;!-- &lt;prop key=&quot;serializer.class&quot;&gt;com.kafka.demo.util.ObjectEncoder&lt;/prop&gt; --&gt; &lt;prop key=&quot;request.required.acks&quot;&gt;1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 生产者通过这个频道传送消息 基于queue--&gt; &lt;int:channel id=&quot;kafkaProducerChannel&quot;&gt; &lt;int:queue /&gt; &lt;/int:channel&gt; &lt;!-- 生产者发送消息设置 频道+方法配置 --&gt; &lt;int-kafka:outbound-channel-adapter id=&quot;kafkaOutboundChannelAdapterTopic&quot; kafka-producer-context-ref=&quot;producerContextTopic&quot; auto-startup=&quot;true&quot; channel=&quot;kafkaProducerChannel&quot; order=&quot;3&quot;&gt; &lt;int:poller fixed-delay=&quot;1000&quot; time-unit=&quot;MILLISECONDS&quot; receive-timeout=&quot;1&quot; task-executor=&quot;taskExecutor&quot; /&gt; &lt;/int-kafka:outbound-channel-adapter&gt; &lt;task:executor id=&quot;taskExecutor&quot; pool-size=&quot;5&quot; keep-alive=&quot;120&quot; queue-capacity=&quot;500&quot; /&gt; &lt;!-- 消息发送的主题设置。必须设置了主题才能发送相应主题消息 --&gt; &lt;int-kafka:producer-context id=&quot;producerContextTopic&quot; producer-properties=&quot;producerProperties&quot;&gt; &lt;int-kafka:producer-configurations&gt; &lt;!-- 多个topic配置 broker-list kafaka服务 key_serializer value-serializer 就是用了自己的编码格式 value-class-type 指定发送消息的类型--&gt; &lt;int-kafka:producer-configuration broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot; value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot; topic=&quot;testTopic&quot; /&gt; &lt;int-kafka:producer-configuration broker-list=&quot;192.168.1.130:9091&quot; key-serializer=&quot;stringSerializer&quot; value-class-type=&quot;java.lang.Object&quot; value-serializer=&quot;stringSerializer&quot; topic=&quot;myTopic&quot; /&gt; &lt;/int-kafka:producer-configurations&gt; &lt;/int-kafka:producer-context&gt; &lt;/beans&gt; 最后我们在生产消息的地方注入我们配置文件中的频道就可以发送消息了 消费者配置(spring-kafka-consumer.xml) 上面的配置就可以实现消息的发送了。我们项目中会继续配置接收消息(消费者)。配置和生产者的配置一样。这里就不详细的解释了。代码里解释的很详细了。只不过里面多了配置Zookeeper的集群信息。还有一点因为在生产者我配置的序列化。所以这里为了配置全面这里采用配置的编码了 完整配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:int=&quot;http://www.springframework.org/schema/integration&quot; xmlns:int-kafka=&quot;http://www.springframework.org/schema/integration/kafka&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/integration/kafka http://www.springframework.org/schema/integration/kafka/spring-integration-kafka.xsd http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt; &lt;!-- 接收的频道 也可以理解为接收的工具类 --&gt; &lt;int:channel id=&quot;inputFromKafka&quot;&gt; &lt;int:dispatcher task-executor=&quot;kafkaMessageExecutor&quot; /&gt; &lt;/int:channel&gt; &lt;!-- zookeeper配置 可以配置多个 --&gt; &lt;int-kafka:zookeeper-connect id=&quot;zookeeperConnect&quot; zk-connect=&quot;192.168.1.130:2181,192.168.1.130:2182,192.168.1.130:2183&quot; zk-connection-timeout=&quot;6000&quot; zk-session-timeout=&quot;6000&quot; zk-sync-time=&quot;2000&quot; /&gt; &lt;!-- channel配置 auto-startup=&quot;true&quot; 否则接收不发数据 --&gt; &lt;int-kafka:inbound-channel-adapter id=&quot;kafkaInboundChannelAdapter&quot; kafka-consumer-context-ref=&quot;consumerContext&quot; auto-startup=&quot;true&quot; channel=&quot;inputFromKafka&quot;&gt; &lt;int:poller fixed-delay=&quot;1&quot; time-unit=&quot;MILLISECONDS&quot; /&gt; &lt;/int-kafka:inbound-channel-adapter&gt; &lt;task:executor id=&quot;kafkaMessageExecutor&quot; pool-size=&quot;8&quot; keep-alive=&quot;120&quot; queue-capacity=&quot;500&quot; /&gt; &lt;!-- &lt;bean id=&quot;kafkaDecoder&quot; class=&quot;org.springframework.integration.kafka.serializer.common.StringDecoder&quot; /&gt; --&gt; &lt;bean id=&quot;kafkaDecoder&quot; class=&quot;com.bshinfo.web.base.kafka.consumer.MyDecoder&quot; /&gt; &lt;bean id=&quot;consumerProperties&quot; class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;auto.offset.reset&quot;&gt;smallest&lt;/prop&gt; &lt;prop key=&quot;socket.receive.buffer.bytes&quot;&gt;10485760&lt;/prop&gt; &lt;!-- 10M --&gt; &lt;prop key=&quot;fetch.message.max.bytes&quot;&gt;5242880&lt;/prop&gt; &lt;prop key=&quot;auto.commit.interval.ms&quot;&gt;1000&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 消息接收的BEEN --&gt; &lt;bean id=&quot;kafkaConsumerService&quot; class=&quot;com.bshinfo.web.base.kafka.consumer.ConsumerMessages&quot; /&gt; &lt;!-- 指定接收的方法 --&gt; &lt;int:outbound-channel-adapter channel=&quot;inputFromKafka&quot; ref=&quot;kafkaConsumerService&quot; method=&quot;processMessage&quot; /&gt; &lt;int-kafka:consumer-context id=&quot;consumerContext&quot; consumer-timeout=&quot;1000&quot; zookeeper-connect=&quot;zookeeperConnect&quot; consumer-properties=&quot;consumerProperties&quot;&gt; &lt;int-kafka:consumer-configurations&gt; &lt;int-kafka:consumer-configuration group-id=&quot;default1&quot; value-decoder=&quot;kafkaDecoder&quot; key-decoder=&quot;kafkaDecoder&quot; max-messages=&quot;5000&quot;&gt; &lt;!-- 两个TOPIC配置 --&gt; &lt;int-kafka:topic id=&quot;myTopic&quot; streams=&quot;4&quot; /&gt; &lt;int-kafka:topic id=&quot;testTopic&quot; streams=&quot;4&quot; /&gt; &lt;/int-kafka:consumer-configuration&gt; &lt;/int-kafka:consumer-configurations&gt; &lt;/int-kafka:consumer-context&gt; &lt;/beans&gt; 配置中消费者实现类 package com.bshinfo.web.base.kafka.consumer; import java.util.Collection; import java.util.Iterator; import java.util.Map; import java.util.Set; import net.sf.json.JSONArray; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ConsumerMessages { private static final Logger logger = LoggerFactory.getLogger(ConsumerMessages.class); public void processMessage(Map&lt;String, Map&lt;Integer, Object&gt;&gt; msgs) { logger.info(&quot;================================processMessage===============&quot;); for (Map.Entry&lt;String, Map&lt;Integer, Object&gt;&gt; entry : msgs.entrySet()) { logger.info(&quot;============Topic:&quot; + entry.getKey()); System.err.println(&quot;============Topic:&quot; + entry.getKey()); Map&lt;Integer, Object&gt; messages = entry.getValue(); Set&lt;Integer&gt; keys = messages.keySet(); for (Integer i : keys) { logger.info(&quot;======Partition:&quot; + i); System.err.println(&quot;======Partition:&quot; + i); } Collection&lt;Object&gt; values = messages.values(); for (Iterator&lt;Object&gt; iterator = values.iterator(); iterator.hasNext();) { Object object = iterator.next(); String message = &quot;[&quot;+object.toString()+&quot;]&quot;; logger.info(&quot;=====message:&quot; + message); System.err.println(&quot;=====message:&quot; + message); JSONArray jsonArray = JSONArray.fromObject(object); for (int i=0;i&lt;jsonArray.size();i++) { Object object2 = jsonArray.get(i); System.out.println(object2.toString()); /*JSONObject object2 = (JSONObject) jsonArray.get(i); UserInfo userInfo = (UserInfo) JSONObject.toBean(object2,UserInfo.class); System.out.println(userInfo.getRealName()+&quot;@@@&quot;+userInfo.getUserSex());*/ } } } } } 消费者中转码的工具类 源码下载","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Kafka集群配置---Windows版","date":"2017-04-10T03:06:00.000Z","path":"zxh/20170410.html","text":"Kafka是一种高吞吐量的分布式发布订阅的消息队列系统 Kafka是一种高吞吐量的分布式发布订阅的消息队列系统，Kafka对消息进行保存时是通过tipic进行分组的。今天我们仅实现Kafka集群的配置。理论的抽空在聊 前言 最近研究kafka，发现网上很多关于kafka的介绍都是基于Linux操作系统的。虽然这些服务最后都是配置Linux上的。但是我们平时使用的大多都是Windows系统。所以研究很是吃力。经过借鉴不同的网络文章终于在Windows上实现了kafka的配置。在这里现在的配置是基于Zookeeper 3.4.6 版本的。如果读者在操作希望能和我的版本保持一致。 zookeeper 了解kafka的都知道。kafka是通过Zookeeper实现分布操作的。不管是broker，consumer,还是provide信息都是存储在Zookeeper中的。当broker挂掉都是Zookeeper来进行重新分配选择的。所以实现kafka集群前我们得先实现Zookeeper的集群配置。 首先我们从官网上下载Zookeeper到本地。我这里下载的是Zookeeper-3.4.6.tar.gz版本的。读者可以根据自己情况下载。下载好之后进行文件解压。然后找到conf文件中的zoo_sample.cfg文件。该文件是Zookeeper官网给我们提供的一套样板。我们赋值该文件到同级下并改名为zoo.cfg.如下图 修改配置文件然后我们来看看这个配置文件里面都有些啥 tickTime=2000 服务器之间或客户端与服务端之间维持心跳的时间。就是每隔tickTime就会发送一次心跳。单位毫秒 initLimit=10 这个是配置Zookeeper接收客户端初始化连接最长能忍受initLimit心跳时间间隔。 syncLimit=5 Leader与follow之间发送消息和应答的时间 总时间=syncLimit*tickTime dataDir zookeeper数据保持路径 默认将log日志也保存在dataDir dataLogDir zookeeper log日志保存地址 不设置默认是dataDir clientPort=2181 客户端连接的端口 server.1=192.168.1.130:28881:38881 server.2=192.168.1.130:28882:38882 server.3=192.168.1.130:28883:38883 因为我的集群都是在同一台电脑上配置的，所以这里端口不能一样 知道配置文件里的意思应该就知道如何修改了吧 对于新手我们只需要该以下地方呢。 dataDir+dataLogDir+clientPort 但是下面的server是Zookeeper配置里需要重点讲解的部分上面的格式我们可以简单的总结为 server.num=B:C:D。num：是正整数代表的服务的唯一标识。这个要和后面说道的myid文件保持一致。 B： 标识Zookeeper集群中某一个服务的ip或者域名 192.168.1.130 C：表示server.num这个服务于集群中leader进行信息交流的端口。在kafka中我们leader和follower需要进行数据备份。具体服务就是通过这个地方制定的端口进行通信的。 D：表示万一leader宕机了，我们就通过这个端口来进行再follower中选举新的leader。 大坑预防 网上的很多教程也就介绍到这里。稍微好点就提了一下创建myid文件的事，我当时就纠结在这里。因为我根本不知道穿件的myid的类型。我就随便创建txt文件。结果是错的。这里我们创建myid我有两种方式。还有myid里面的内容就是我们对应的配置文件中server.num中的num。 第一种就是我们通过cmd窗口到我们要创建myid的文件夹下执行如下命令 echo 1 &gt; myid 第二种是我们先创建TXT文件将对应的内容写入。然后txt后缀删掉就可以了。 顺便提一下myid应该放在我们conf/zoo.cfg文件中指定的dataDir 的对应的文件路径下。 服务开启 所谓的集群就是讲上面的Zookeeper复制成多个，将上面提到的几个重要的属性更改掉就行了。 如果你到这一步说明你离成功已经不远了。下面我们只需要开启服务就行了。开启服务在我们解压的bin目录下。 这里我们得有些常识，已sh结尾的是Linux 系统的shell文件。在windows上没有装插件是无法使用的。我们windows认识的就是bat文件。就是上面的cmd结尾才是我们可以用的功能。但是我们还需要进行一下修改。其实这里已经可以了。我们到cmd窗口中通过该命令去执行我们zoo.cfg文件。但是为了方便我们这里讲zoo.cfg配置进我们的zkServer.cmd文件中 好了。配置完成。我们只需要每次点击zkServer.cmd就开启了Zookeeper中的服务了。 友情提醒 上面我们配置的Zookeeper在开启第一个时候回报错。为什么呢。原因就是我们开启了一个服务，。但是我们的配置文件配置的是集群的信息。这个时候就回去寻找其他服务。但是这个时候其他的服务还没有开启呢。所以这个错误是正常。等我们集群中的所有的服务都开启了就不会报错。这里大家不要被吓到。 除此之外，还有一点就是Zookeeper的安装目录(解压目录)是绝对不能包含汉字的。我上面的截图有汉字那是我计算机上设置的。实际的路径是没有汉字的。不要被上面的图片诱导。 当所有的服务都开启了，我们如何查看我们的服务是否开启成功呢。这很简单。我们重新打开一个新的cmd窗口。直接执行jps就可以看到我们的服务了。QuorumPeerMain就是我们的服务主类 Kafka集群配置 上面我们就完成了Zookeeper的集群的配置。实际上Kafka中就自带有Zookeeper的服务。但是为了数据的高可用性。我们最好选择自己搭建Zookeeper集群。这也是官网上的建议。 这里我的Kafka版本选择的是0.8.1.1。建议单价不要选择太高的版本。刚出的版本可能有未知的bug。 同样这里的集群就是讲Kafka复制多个。这里我选择其中一个进行讲解。其他的都是一样的主要就是讲端口改掉就行了。 将官网下载的Kafka解压改名为kafka1（其他的改名数字递增就行。或者自定义别的名字）。找到config/server.properties文件。 server.properties修改 同样的先来了解里面的参数含义吧 broker.id=1 在kafka这个集群中的唯一标识，且只能是正整数 port=9091 该服务监听的端口 host.name=192.168.1.130 broker 绑定的主机名称(IP) 如果不设置将绑定所有的接口。 advertised.host.name=192.168.1.130 broker服务将通知消费者和生产者 换言之，就是消费者和生产者就是通过这个主机(IP)来进行通信的。如果没有设置就默认采用host.name。 num.network.threads=2 broker处理消息的最大线程数，一般情况是CPU的核数 num.io.threads=8 broker处理IO的线程数 一般是num.network.threads的两倍 socket.send.buffer.bytes=1048576 socket发送的缓冲区。socket调优参数SO_SNDBUFF socket.receive.buffer.bytes=1048576 socket接收的缓冲区 socket的调优参数SO_RCVBUF socket.request.max.bytes=104857600 socket请求的最大数量，防止serverOOM。 log.dirs=\\logs kafka数据的存放地址，多个地址的话用逗号隔开。多个目录分布在不同的磁盘上可以提高读写性能 num.partitions=2 每个tipic的默认分区个数，在创建topic时可以重新制定 log.retention.hours=168 数据文件的保留时间 log.retention.minutes也是一个道理。 log.segment.bytes=536870912 topic中的最大文件的大小 -1表示没有文件大小限制 log.segment.bytes 和log.retention.minutes 任意一个达到要求 都会删除该文件 在创建topic时可以重新制定。若没有.则选取该默认值 log.retention.check.interval.ms=60000 文件大小检查的周期时间，是否处罚 log.cleanup.policy中设置的策略 log.cleaner.enable=false 是否开启日志清理 zookeeper.connect=192.168.1.130:num1,192.168.1.130:num2,192.168.1.130:num3 上面我们的Zookeeper集群 zookeeper.connection.timeout.ms=1000000 进群链接时间超时 同样的我们每次赋值kafka服务我们只需该配置文件里的下面两个属性就行了。 broker.id + port 服务启动前的命令准备 同样的我们观察bin目录中我们会发现Kafka针对Linux和windows提供了不同的组件。windows的组件放在了windows的文件夹下了。但是我在实际操作中无法使用里面的命令。报一些错误。这里我的解决办法是将windows里的bat全部复制到外面。就是复制到bin目录下。 上图中指出来的bat原本是在windows文件中。拷贝到bin目录之后我们需要修改一下kafka-run-class.bat文件。因为里面写的相对路径和引入的jar会导致出错。所以我们将里面的这段代码 set ivyPath=%USERPROFILE%\\.ivy2\\cache set snappy=%ivyPath%/org.xerial.snappy/snappy-java/bundles/snappy-java-1.0.5.jar call :concat %snappy% set library=%ivyPath%/org.scala-lang/scala-library/jars/scala-library-2.8.0.jar call :concat %library% set compiler=%ivyPath%/org.scala-lang/scala-compiler/jars/scala-compiler-2.8.0.jar call :concat %compiler% set log4j=%ivyPath%/log4j/log4j/jars/log4j-1.2.15.jar call :concat %log4j% set slf=%ivyPath%/org.slf4j/slf4j-api/jars/slf4j-api-1.6.4.jar call :concat %slf% set zookeeper=%ivyPath%/org.apache.zookeeper/zookeeper/jars/zookeeper-3.3.4.jar call :concat %zookeeper% set jopt=%ivyPath%/net.sf.jopt-simple/jopt-simple/jars/jopt-simple-3.2.jar call :concat %jopt% for %%i in (%BASE_DIR%\\core\\target\\scala-2.8.0\\*.jar) do ( call :concat %%i ) for %%i in (%BASE_DIR%\\core\\lib\\*.jar) do ( call :concat %%i ) for %%i in (%BASE_DIR%\\perf\\target\\scala-2.8.0/kafka*.jar) do ( call :concat %%i ) 替换成 for %%i in (%BASE_DIR%\\libs\\*.jar) do ( call :concat %%i ) 我们仔细观察原来的配置大概意思是引入一些jar包啥的。但是会出现有的时候我们的文件根本没有那个jar。但是又引入了。会经常报错。所以我们改成引入libs下的所有jar.有啥就引入啥。这样就不会报错的。 大坑预防 到这里我原本天真的认为就已经完事了。但是谁知我按照网上的教程继续的时候就出现如下错误 首先第一行提示 set JMX_PORT to default value 9999 这个错误是因为我没有设置这个值。这倒是小事。但是后面报说找不到或无法加载主类kafka.Kafka这就让我费解。在这里我也是卡了一天了。后来在网上找到了一个方法。我不知道这是不是Kafka的bug。反正用这个方法我是解决了这个错误了。 解决办法就是将kafka-run-class.bat文件中 set COMMAND= %JAVA% %KAFKA_OPTS% %KAFKA_JMX_OPTS% -cp %CLASSPATH% %* 修改为 set COMMAND= %JAVA% %KAFKA_OPTS% %KAFKA_JMX_OPTS% -cp &quot;%CLASSPATH%&quot; %* 对比我们发现就是将classpath加上双引号。搞了半天就是系统变量路径没有找到的原因。不过这个问题值得引起我们的注意。我们的kafka寄去你的搭建实在Java 的jdk基础是搭建的。所以前提我们得将jdk等这些配置到环境变量中去。这里的配置网上搜去吧很多。 服务开启 到这一步我们离kafka的成功又不远了。我们新开cmd窗口cd到kafka的bin目录中。 但是在执行开启之前我们需要先执行 Set JMX_PORT=19091(每个服务数字不能一样) 然后在执行 kafka-server-start.bat ..\\config\\server.properties 创建Topic批处理 官网上是没有提供windows版本的topic处理程序的。我们需要自己新建一个bat文件。这个bat文件的内容填写如下 kafka-run-class.bat kafka.admin.TopicCommand %* 消息处理 有了这个批处理我们就可以通过它实现topic的创建。生产者发送消息和消费者的接收消息 创建Topic replication-factor：表示该topic需要在不同的broker中保存 partitions ： 对该top的分区数量 topic ： 该top的名称。建议指定。否则采用默认kafka-topics.bat --create --zookeeper 192.168.1.130:2181 --replication-factor 2 --partitions 3 --topic my-replicated-topic 查看Topic kafka-topics.bat --describe --zookeeper 192.168.1.130:2181 --topic my-replicated-topic 生产topic消息 kafka-console-producer.bat --broker-list 192.168.1.130:9093 --topic my-replicated-topic 消费topic消息 kafka-console-consumer.bat --zookeeper 192.168.1.130:2181 --from-beginning --topic my-replicated-topic 最后在接收发送消息是我们需要重新创建新的cmd窗口。下面看看效果图。最终实现实时接收消息 资源由于大小限制暂时无法上传！后续再上传","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"大话 Spring Session 共享","date":"2017-04-01T01:56:00.000Z","path":"zxh/20170401.html","text":"javaweb中我们项目稍微正规点 javaweb中我们项目稍微正规点，都会用到单点登录这个技术。实现它的方法各家有各界的看法。这几天由于公司项目需求正在研究。下面整理一下最近整理的心得。 简介 在分布式项目中另我们头疼的是多项目之间的数据共享(即Session共享)，经常会出现数据丢失的情况。为了解决这种Bug。前人已经把我们实现了两种解决的办法。今天我在这里一下这两种方式。侧重偏向第二种方法 配tomcat实现session共享资源下载点我下载 配置Tomcat 下载好上面的jar包，把他放在tomcat的lib文件下。 然后修改Tomcat里的conf/context.xml文件 &lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt; &lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot; host=&quot;192.168.1.130&quot; port=&quot;7006&quot; database=&quot;db0&quot; maxInactiveInterval=&quot;60&quot; /&gt; 上面配置的host和port就是我们redis的host和port，所以在此之前我们需要先开启一个redis服务出来。点我查看如何配置redis(本文配置集群，配置单节点一样)点我查看如何配置redis和spring的整合点我查看如何配置redis中你遇到的问题汇总 database就是讲该tomcat与浏览器会话时产生的session存放在redis中的位置 maxInactiveInterval 就是设置缓存的过期时间。但是在实际测试中我发现这个属性并没有发生作用。(你有啥见解欢迎点评) 到这里我们的第一个Tomcat配置完成。下面就是重复上面的步骤多配制几个Tomcat 配置nginx nginx功能丰富，可以作为HTTP服务器，也可以作为反向代理的服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。 nginx的下载官网有现成的，直接下载符合自己电脑的版本傻瓜式安装就行了。(安装或者解压不要出现中文) 找到conf/nginx.conf文件在里面修改设置 listen 802： 我们监听的端口 server_name 192.168.1.130：监听的地址 proxy_pass http://mynginxserver：根据情况跳转最后的连接 在mynginxserver配置多个Tomcat： upstream mynginxserver { server 192.168.1.78:8080 weight=1; server 192.168.1.130:8080 weight=1; } 完成配置 upstream mynginxserver { server 192.168.1.78:8080 weight=1; server 192.168.1.130:8080 weight=1; } server { listen 802; server_name 192.168.1.130; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://mynginxserver; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ /\\.ht { # deny all; #} } 这个时候当我们两个Tomcat都在运行状态我们浏览器中输入 192.168.1.130:802 nginx就会随机选择一个Tomcat来运行了。同时这两个Tomcat的session是共享的。就是说A Tomcat的session B 可以用。就算A 宕机了B也照样按到A的session。 配spring session实现session共享 上面的一种方式我也是在网上案列操作的。在自己的项目中并不适合。因为我的项目中配置的是redis集群(非sentinel).所以在Tomcat里面配置是不行的。解释：第一种方式配置的redis默认是单节点的redis。也就是我们的session会产生sessionID作为redis中key存在我们配置redis节点的库上面。但是如果我们是redis集群的话，集群会将根据key值算出slot值，在根据slot值决定存取在哪一台redis服务商。也就是说在存session前我们根本不知道会存在哪一台redis上。所以这种方法不适合于redis集群。 具体看看我画的思维导图吧： 第二章明显出错了，事实上并没有存储在实现约定的redis上 spring session 配置 说了这么多了，我们下面开始讲解spring中集成的session共享配置。首先如果你是maven项目那么直接引入jar &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt; &lt;version&gt;1.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; 若果你不是maven项目，那么就麻烦你自己去下载这些相关的jar包。 spring-data-redis.jar redis.clients.jar spring-session.jar 同样这里你需要一下几篇文章来配置redis集群点我查看如何配置redis点我查看如何配置redis和spring的整合点我查看如何配置redis中你遇到的问题汇总 spring配置文件配置 有了上面的准备资料后，我们可以在是spring的配置文件中配置spring session了 很简单我们需要引入spring session中的bean &lt;bean class=&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;&gt; 在spring的配置文件中我们只需要配置这一个bean就可以了。下面离将session共享到redis集群上只差一步了。就是在web.xml文件中配置拦截器 &lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 到这里配置完成了，我们可以重启我们的项目运行一下存取session的部分。然后再去redis集群找看看有没有session。在redis中默认的session的key是spring:session:sessions:c0d1fadd-b04a-4244-9525-0f13ea7173bf。其中后面一串id就是我们Tomcat和浏览器会话时差生的sessionid。 问题 在上面我们配置spring session 已经可以实现了session共享了。但是细心的朋友可以发现。session并没有真正意义上的共享。上面我们可以看到session在redis集群中的key包含了Tomcat和浏览器的sessionid。也就是说redis上这个session只能是我的这个Tomcat在该浏览器上才可以访问到。别的Tomcat就算和同一个浏览器交互也是拿不到redis上这个session的。这种效果是你们想要的吗。答案并不是。上面实现的效果我用一幅图描述一下。 也就是说上面我的配置只是将Tomcat的session转移到了redis上。多服务的session仍然是各区各的。这是一个大坑。坑了好久。然后我想了另外一种办法现在可以解决这个局限性。 解决办法 解决上面的问题。这里我提供三种思路。三种思路我都实现了一下。各有利弊。最后决定采用第三种比较靠谱。 1– 重写spring session源码，重写里面讲session存储在redis那部分代码，主要就是为了将redis 中session的key写成固定值。以后我们在去session中取这个固定的key就可以实现session共享了。 2–只重写spring session中我们的session仓库中去的策略，就是在A项目登录后将产生的sessionID传递给B项目。B项目在根据这个sessionid去redis中获取。 上面两中方法需要自定义很多类，整理了自定义的类和配置文件的配置。点我下载 3– 在向session中存值的地方，将sessionid作为value，请求头中的Host和Agent组合最为key存储在redis上。然后我们在spring session去session的方法里在根据Host和Agent组成的key去获取sessionid，然后就可以获取对应的session了。 存取策略重构 这里主要讲解一下第三种的实现步骤。首先我新建一个类用来读取request求情头中的host和agent拼接的key值。 public static Map&lt;String, Object&gt; getInfoFromUrl(HttpServletRequest request) { Map&lt;String, Object&gt; resultMap=new HashMap&lt;String, Object&gt;(); String Agent = request.getHeader(&quot;User-Agent&quot;); String Host = request.getHeader(&quot;Host&quot;); resultMap.put(&quot;agent&quot;, Agent); resultMap.put(&quot;host&quot;, Host); return resultMap; } public static String getKeyFromUrl(HttpServletRequest request) { String result=&quot;&quot;; Map&lt;String, Object&gt; map = getInfoFromUrl(request); Set&lt;String&gt; keySet = map.keySet(); for (String key : keySet) { result+=map.get(key).toString(); } return result; } 然后在我们调用session存值的地方，也就是登录的地方。通过我们项目中的redis操作类将其存储起来。 然后我们修改spring session中的cookie仓库中的去request的sessionid的策略 最后我们在spring的配置中修改是spring session的策略为我么你的cook策略 &lt;bean id=&quot;redisCacheTemplate&quot; class=&quot;com.bshinfo.web.base.cache.RedisCacheTemplate&quot;/&gt; &lt;bean id=&quot;zxh&quot; class=&quot;com.bshinfo.web.base.cache.CookieHttpSessionStrategyTest&quot;&gt; &lt;property name=&quot;redisCacheTemplate&quot; ref=&quot;redisCacheTemplate&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;&gt; &lt;property name=&quot;httpSessionStrategy&quot; ref=&quot;zxh&quot;/&gt; &lt;property name=&quot;maxInactiveIntervalInSeconds&quot; value=&quot;60&quot;/&gt; &lt;/bean&gt; 最后就实现了我们的效果。效果就是A项目在X浏览器上登录后。B项目在X浏览器获取session的用户可以正常获取。否则获取失败。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"通过注解实现通用导出Excel","date":"2017-03-22T09:57:00.000Z","path":"zxh/20170322.html","text":"Javaweb开发中数据的导入导出很常见 Javaweb开发中数据的导入导出很常见，每次我们都需要写很多代码，所以我就在想能不能写一些通用的方法，之前已经在网上 整理过一些通用的方法，最近在网上看到一位牛人封装的更加简介，自己拿过来整理了一下。 配置注解 之前我们了解了Java注解的使用,现在我们正是通过注解的方式来简化javaweb中繁琐的Excel上传和下载两个功能。由于时间有限今天先实现了Excel的下载(Excel 导出)。 上面的就是我们的注解类的简化图。参数的意思分别是指定表头的名字+表头所占列宽度+该列是否明文显示+加密显示的方式+特殊文本的格式 数据实体类 有了上面的注解我们的实体类非常的简单，只是在我们平常建的Javabean的属性字段上加上我们刚才的注解就行了。 其中ExportConfig注解中的属性值我们可以不设置，不设置就是默认的。这里设置完成后就开始写导出了。 Excel导出 现在该如何获取我们的注解呢，之前的文章已经介绍了。我们得首先获得我们的Javabean的字段。 for (Field field : _class.getDeclaredFields()) 可能会出现我们的Javabean的数据并不是完全的查出来了。所以这里我们得先看看这个字段到底有没有值。 property = BeanUtils.getProperty(data.get(0), field.getName()); 在有值得前提下我们在获取字段的注解。 ExportConfig config = field.getAnnotation(ExportConfig.class); 最后我们开始讲注解的信息存在到信息类上ExportItem.java items.add(new ExportItem.$Build() .setField(field.getName()) .setDisplay( &quot;field&quot;.equals(config.value()) ? field .getName() : config.value()) .setWidth(config.width()) .setIsExport(config.isExport()) .setContent(config.blankContent()) .setFieldTypeName(field.getClass().getSimpleName()) .setFormat(config.format()) .create()); ExportItem 类也很简单。里面拷贝了自身的一个类实现了链式操作。这里没什么讲解的。到这里我们的表头显示设置已经完成了。下面自然就是遍历list集合数据了。当然遍历之前先设置表头样式。 ExportItem exportItem = items.get(index); // 首先创建该行指定列的单元格 Cell cell = headRow.createCell(index); sheet.setColumnWidth(index, (short) (exportItem.getWidth() * 35.7)); cell.setCellValue(exportItem.getDisplay()); CellStyle style = handler.getHeadCellStyle(wb); if (style != null) { cell.setCellStyle(style); } 在设置表身的时候我们得先去注解信息类中拿到该列显示的风格(是否是明文)。 if (exportItem.getIsExport()) 在设置了内容之后我们还要根据注解的单元格格式进行样式的设置 setStyleByType(wb,exportItem.getFormat()); Excel输出 fileName += getExcelSuffix(type); _response.setContentType(getContentType(type)); _response.setHeader( &quot;Content-disposition&quot;, &quot;attachment; filename=&quot; + new String(fileName.getBytes(&quot;gbk&quot;), &quot;iso8859-1&quot;)); if (out == null) { out = _response.getOutputStream(); } wb.write(out); out.flush(); out.close(); 所需jarlog4j-1.2.17.jar 日志jar包 servlet-api.jar 正常在web项目中都不需要引入该jar包 poi-3.9.jar 操作表格jar包 pi-ooxml-3.12.jar XSSFWorkbook 处理2007版本及以上的excel 调用代码List&lt;ExcelUser&gt; list = adminManageServiceI.getUsers(ConstantUtil.ADMIN_ID); // 生成Excel并使用浏览器下载 ExcelTool.$Brower(ExcelUser.class, response).toExcel(list, &quot;用户信息&quot;); 效果 源码正在更新，导入导出全部完成在上传源码。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"bootstrape select使用小结","date":"2017-03-18T07:03:00.000Z","path":"zxh/20170318.html","text":"看看上面的效果是bootstrape使用的效果。虽然不是很好看，但是符合bootstrape的风格。来看看普通的select的样式 看看上面的效果是bootstrape使用的效果。虽然不是很好看，但是符合bootstrape的风格。来看看普通的select的样式 bootstrape下的select和普通select在bootstrape风格对比 引入 首先我们肯定得引入jQuery和bootstrape的相关js和css，在此基础上我们引入两个东西 bootstrap-select.min.css bootstrap-select.min.js components-bootstrap-select.min.js 页面书写 其中class属性必须包含bs-select ,且select属性中含有一下属性 data-live-search（必须） data-size=&quot;6&quot;（可选） id（必须） data-live-search 是用于搜索的，本章搜索没实现，以后再详细设计，但是这个属性必须有。源码里根据他选择搜索的。 data-size 是设置数字，意思就是下拉框内容超过几条是开始出现滚动条。 id用于识别这个下拉框的 Ajax请求加载select数据 项目中的select多数情况下都是动态数据加载的，那么下一步开始讨论动态数据的加载问题。首先肯定是发送请求。然后在ajax请求成功后的回调地方处理我们的动态数据加载问题。 //调用公共插值方法 createSelectDate(siteDate,&quot;site_id&quot;); createSelectDate 这个方法我们需要传入两个参数，第一个是我们需要加载的数据，第二个使我们的数据加载在select的id 在来看看经过处理后我们的select 仔细观察发现ul 是页面显示的数据，select是我们真正的数据，所以我们只需要向这两个地方填充数据就行了。 向select加入数据很简单，通过ID加入， 关键是如何获取新的select即ul,经过实践通过以下方法就行。 var $selectUl = $($($(&quot;button[data-id=&#39;&quot;+select_id+&quot;&#39;]&quot;).parent().children().get(1)).children().get(1)); 然后向新的对象添加内容 $newSelect.append(&quot;&lt;li data-original-index=&quot;+(index+1)+&quot; class&gt;&lt;a tabindex=&#39;0&#39; class style data-tokens=&#39;null&#39; role=&#39;option&#39; aria-disabled=&#39;false&#39; aria-selected=&#39;false&#39;&gt;&lt;span class=&#39;text&#39;&gt;&quot;+value.site_name+&quot;&lt;/span&gt;&lt;span class=&#39;fa fa-check check-mark&#39;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&quot;); 清空select选中值 用了这个之后我们会遇到问题，我们无法清空新select的内容，这就很尴尬。研究半天决定强行删除 $(&quot;button[role=&#39;button&#39;][data-id=&#39;&quot;+select_id+&quot;&#39;]&quot;).attr(&quot;title&quot;,&quot;请选择...&quot;);//selected active $(&quot;button[role=&#39;button&#39;][data-id=&#39;&quot;+select_id+&quot;&#39;] span:first&quot;).text(&quot;请选择...&quot;); 最后我们只需要调用相应的方法就行了。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"jquery验证大全","date":"2017-03-10T14:15:00.000Z","path":"zxh/20170310.html","text":"jQuery验证及限制 jQuery验证及限制绑定键盘监听事件 $(document).on(&quot;keypress&quot;, &quot;.txt-valid-len&quot;, function (e) { return (this.value.length &lt; $(this).attr(&quot;maxlength&quot;)); }); 输入框设置 然后我们只需要在input中添加txt-valid-len这个class属性。并且加入maxlength属性指定长度就可以了。 &lt;input type=&quot;text&quot; id=&quot;user_name&quot; name=&quot;name&quot; class=&quot;form-control txt-valid-len&quot; maxlength=&quot;11&quot; /&gt; 上面的代码的意思就是这个输入框长度限制在11位，超过11位就不显示了。如果想在超过11位进行提示。可以扩展上面的监听事件。 jquery表单提交验证 在开发中我们前台经常需要在与后台交互前进行相关数据的验证。这样可以减少服务端的压力。下面我们来看看jquery给我们提供的表单验证的方法。 引入脚本文件jquery.min.js jquery.validate.js 这两个js在官网的jQuery中都是包含的，直接下载引入就行了。 有了这两个js我们还需要页面上的form表单。表单就是我们平常的表单。 &lt;form id=&quot;myform&quot; method=&quot;post&quot; action=&quot;#&quot;&gt; &lt;p&gt; &lt;label for=&quot;myname&quot;&gt;用户名：&lt;/label&gt; &lt;!-- id和name最好同时写上 --&gt; &lt;input id=&quot;myname&quot; name=&quot;myname&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;age&quot;&gt;年龄：&lt;/label&gt; &lt;input id=&quot;age&quot; name=&quot;age&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;email&quot;&gt;E-Mail：&lt;/label&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;password&quot;&gt;登陆密码：&lt;/label&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;确认密码：&lt;/label&gt; &lt;input name=&quot;confirm_password&quot; type=&quot;password&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;立即注册&quot; /&gt; &lt;/p&gt; &lt;/form&gt; 自定义js实现表单验证(利用jQuery提供内置方法) 首先我们通过jQuery提供的选择器找到我们需要验证的表单 $(&quot;#myform&quot;).validate(); 就这样我们就完成了表单验证。当然啦，到这里只是架子打好了。下面我们开始在validate中填写我们的验证规则了。 $(&quot;#myform&quot;).validate({ debug: true, //调试模式取消submit的默认提交功能 //errorClass: &quot;label.error&quot;, //默认为错误的样式类为：error focusInvalid: false, //当为false时，验证无效时，没有焦点响应 onkeyup: false, submitHandler: function(form){ //表单提交句柄,为一回调函数，带一个参数：form alert(&quot;提交表单&quot;); form.submit(); //提交表单 }, rules:{ myname:{ required:function(element){ if( $(&quot;#age&quot;).val() &lt; 13){ return true; } else{ return false; } } }, email:{ required:true, email:true }, password:{ required:true, rangelength:[3,10] }, confirm_password:{ equalTo:&quot;input[name=password]&quot; } }, messages:{ myname:{ required:&quot;必填&quot; }, email:{ required:&quot;&lt;span style=&#39;color:red;&#39;&gt;只允许输入整数。&lt;/span&gt;&quot;, email:&quot;E-Mail格式不正确&quot; }, password:{ required: &quot;不能为空&quot;, rangelength: $.validator.format(&quot;密码最小长度:{0}, 最大长度:{1}。&quot;) }, confirm_password:{ equalTo:&quot;两次密码输入不一致&quot; } } }); 其中的rules就是我们验证规则内容。其中的myname,email…是我们form需要验证的控件的name属性值(并不是ID属性值)，还有我们的提示信息可以做的花哨一点加入样式 &lt;span style=&#39;color:red;&#39;&gt;只允许输入整数。&lt;/span&gt; 至于这些验证规则我们可以在jquery-validate.js中找到。里面messages属性的提示信息我们都是可以用来做验证的. 动态决定验证规则 上面的myname的required的验证是根据id=age的input框的值得变化决定的，就是说你输入的年龄小于13岁myname是需要验证的。大于则反之。如果你想做的像更美化我们可以在年龄input中绑定一个失去焦点的时间(blur)，在输入完年龄我们就立马去验证myname的input框的规则，通过调用$(&quot;#myname&quot;).valid(); 就会去按照我们的规则去验证myname这个字段的input的值。 通过远程进行验证前台 对上面的进行如下的修改，其中remote就是我们的远程请求，该请求返回的true,则验证通过，false反之。 $(&quot;#myform&quot;).validate({ rules: { email: { required: true, email: true, remote: { type:&quot;post&quot;, dataType: &quot;json&quot;, contentType : &quot;application/json&quot;, url:&quot;/adminManage/email.bsh&quot; } } } }); 后台 这的注意的是remote这里的请求格式有些要求，这个url返回的数据必须是json格式的。但是后台只能返回string或者boolean类型的数据。如果返回的是string内容的json，那么string是true则验证通过，若果不是true则验证提示就是你返回的string内容。如果是boolean，是true则验证通过，false验证失败。 @RequestMapping(&quot;/email.bsh&quot;) @ResponseBody public Object email(HttpServletRequest request,HttpServletResponse response) { return &quot;已经存在&quot;; } 前台提示已经存在，会覆盖前台默认的提示内容 @RequestMapping(&quot;/email.bsh&quot;) @ResponseBody public Object email(HttpServletRequest request,HttpServletResponse response) { return &quot;true&quot;; } 验证通过 @RequestMapping(&quot;/email.bsh&quot;) @ResponseBody public Object email(HttpServletRequest request,HttpServletResponse response) { return true; } 验证通过 @RequestMapping(&quot;/email.bsh&quot;) @ResponseBody public Object email(HttpServletRequest request,HttpServletResponse response) { return false; } 验证失败，前台将提示默认的信息 参考网址 验证提示信息的显示位置 在上面一节我们详细介绍了验证的规则及提示实现。那么提示信息的位置有时候也是很重要的，我们控制的好的话界面会很美观的。 var validator = $(&quot;#myform&quot;).validate({ debug: true, //调试模式取消submit的默认提交功能 errorClass: &quot;haha&quot;,//默认为错误的样式类为：error focusInvalid: false, onkeyup: false, submitHandler: function(form){ //表单提交句柄,为一回调函数，带一个参数：form alert(&quot;提交表单&quot;); //form.submit(); 提交表单 }, rules: { //定义验证规则,其中属性名为表单的name属性 username: { required: true, minlength: 2, remote: &quot;uservalid.jsp&quot; //传说当中的ajax验证 }, firstpwd: { required: true, //minlength: 6 rangelength: [6,8] }, secondpwd: { required: true, equalTo: &quot;#password&quot; }, sex: { required: true }, age: { required: true, range: [0,120] }, email: { required: true, email: true }, purl: { required: true, url: true }, afile: { required: true, accept: &quot;xls,doc,rar,zip&quot; } }, messages: { //自定义验证消息 username: { required: &quot;用户名是必需的！&quot;, minlength: $.format(&quot;用户名至少要{0}个字符！&quot;), remote: $.format(&quot;{0}已经被占用&quot;) }, firstpwd: { required: &quot;密码是必需的！&quot;, rangelength: $.format(&quot;密码要在{0}-{1}个字符之间！&quot;) }, secondpwd: { required: &quot;密码验证是必需的！&quot;, equalTo: &quot;密码验证需要与密码一致&quot; }, sex: { required: &quot;性别是必需的&quot; }, age: { required: &quot;年龄是必需的&quot;, range: &quot;年龄必须介于{0}-{1}之间&quot; }, email: { required: &quot;邮箱是必需的！&quot;, email: &quot;请输入正确的邮箱地址（例如 myemail@163.com）&quot; }, purl: { required: &quot;个人主页是必需的&quot;, url: &quot;请输入正确的url格式,如 http://www.domainname.com&quot; }, afile: { required: &quot;附件是必需的！&quot;, accept: &quot;只接收xls,doc,rar,zip文件&quot; } }, errorPlacement: function(error, element) { //验证消息放置的地方 error.appendTo( element.parent(&quot;td&quot;).next(&quot;td&quot;) ); }, highlight: function(element, errorClass) { //针对验证的表单设置高亮 $(element).addClass(errorClass); }, success: function(label) { label.addClass(&quot;valid&quot;).text(&quot;Ok!&quot;) } /*, errorContainer: &quot;#error_con&quot;, //验证消息集中放置的容器 errorLabelContainer: &quot;#error_con ul&quot;, //存放消息无序列表的容器 wrapper: &quot;li&quot;, //将验证消息用无序列表包围 validClass: &quot;valid&quot;, //通过验证的样式类 errorElement: &quot;em&quot;, //验证标签的名称，默认为：label success: &quot;valid&quot; //验证通过的样式类 */ }); 重构规则不论什么时候，当你的表单中的多个字段含有相同的验证规则及验证消息，重构规则可以减少很多重复。使用 addMethod 和 addClassRules 将非常有效果。假使已经重构了如下规则： // alias required to cRequired with new message $.validator.addMethod(&quot;cRequired&quot;, $.validator.methods.required, &quot;Customer name required&quot;); // alias minlength, too $.validator.addMethod(&quot;cMinlength&quot;, $.validator.methods.minlength, // leverage parameter replacement for minlength, {0} gets replaced with 2 $.format(&quot;Customer name must have at least {0} characters&quot;)); // combine them both, including the parameter for minlength $.validator.addClassRules(&quot;customer&quot;, { cRequired: true, cMinlength: 2 }); &lt;input name=&quot;customer1&quot; class=&quot;customer&quot; /&gt; &lt;input name=&quot;customer2&quot; class=&quot;customer&quot; /&gt; &lt;input name=&quot;customer3&quot; class=&quot;customer&quot; /&gt; adMethodaddMethod( name, method, [message] )返回：undefined 参数 name 类型：String要添加的方法名，用于标识和引用，必须是一个有效的javascript标识符。 参数 method 类型：Callback 方法的实现部分，返回true如果表单元素通过验证。 参数 message(Optional) 类型：String, Function 该方法的默认验证消息。可以用 jQuery.validator.format(value) 方法创建。如果未定义该参数，则使用本地已存在的验证消息，另外，必须为指定的表单元素定义验证消息。 说明：添加一个用户自定义的验证方法。它由方法名（必须是一个合法的javascript标识符）、基于javascript的函数及默认的验证消息组成。 addClassRules( name, rules )返回：undefined 参数 name 类型：String 要添加的样式规则名。 参数 rules 类型：Options 规则选项。 说明：添加一个复合的样式验证方法。对于将多个联合使用的规则重构进单个样式中非常有用。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"java 注解的使用","date":"2017-03-02T02:44:00.000Z","path":"zxh/20170302.html","text":"spring开源框架，里面全是通过注解实现的 spring开源框架，里面全是通过注解实现的，我们使用在使用的时候也尝到不少好处，所以就抽空看看Java给我们提供的注解机制的使用。 什么是注解 注解就是类似于注释一样，起到对类、方法、字段等的说明作用。Annotation(注解)是在jdk1.5之后才引入的概念。所以你要想实现注解你的jdk必须1.5以上。他可以用于创建文档，跟踪代码的依赖性。甚至也可以执行基本的编译语法检查。注解的格式是以@开头的，@interface形式的类名申请。上面说了，注解你就可以理解为注释，因为注解是不会影响到代码的语义的。注解有三种存在方式，一种是存在源码中，一种是在编译中，一种是在运行期间有效。 注解的作用 编写文档：通过代码里标识的元数据生成文档。 代码分析：通过代码里标识的元数据对代码进行分析。 编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查 基本注解 在Java中我们初学者可能不知道什么是注解，但是我们肯定都是永富哦注解的，下面来看看我们在哪里用过他们吧， Override java.lang.Override是一个标记类型注解，它被用作标注方法.他说明了该方法是继承了父类的方法，就是重写了父类中同名方法。如果我们在一个方法上面使用的@override，但是实际上父类根本没有这个方法，就是说我们这个方法没有重载父类的方法。这个时候我们在编译时就会报相应的编译错误。 SuppressWarnings 我对这个注解的理解就是通过它告诉编译器忽视我下面可能出现的警告。实际上里面有很多参数，不同参数设置不同的警告 deprecation，使用了过时的类或方法时的警告 unchecked，执行了未检查的转换时的警告 fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告 path，在类路径、源文件路径等中有不存在的路径时的警告 serial，当在可序列化的类上缺少serialVersionUID 定义时的警告 finally ，任何 finally 子句不能正常完成时的警告 all，关于以上所有情况的警告 Deprecated 这个注解我实际没有接触过，这个我在网上搜了一下，人家的解释为 它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数，使用@Deprecated的示例代码示例如下： 在我们平时编写代码用到jdk中的方法，有的时候回遇到某个方法过时了，但是可以用，那个方法就是通过这个注解实现的，简单说就是提示开发者方法过时，尽量避免使用过时方法。 jdk提供了开发注解的方法 有了上面的介绍我们多多少少对注解有了了解，既然Java已经有了注解的概念那么我们如何开发自己的注解呢。在java.lang.annotation这个包里jdk放置了关于注解的注解，就是通过里面的注解类我们可以开发自己的注解。下面先来认识一下注解的注解吧。 通过观察源码，其中annotation 、annotationFormatError、annotationTypeMismatchExcetion、IncompleteAnnotationException这四个类有事异常类又是基本类页游格式化的，这些类我们开发注解时我们不会遇到的，都是jdk里逻辑。我们真正使用的是剩下的几个类。 ElementType 这个类是个枚举，这里枚举的字段就是给Target类中使用的。具体在Target中说明 RetentionPolicy 这个类是个枚举，这里枚举的字段就是给Retention类中使用的。具体在Retention中说明 Documented /** * Indicates that annotations with a type are to be documented by javadoc * and similar tools by default. This type should be used to annotate the * declarations of types whose annotations affect the use of annotated * elements by their clients. If a type declaration is annotated with * Documented, its annotations become part of the public API * of the annotated elements. * * @author Joshua Bloch * @since 1.5 */ 这是官网的jdk上对documented类的描述，这段描述的大致意思是该类的申明是用在生成Java文档上的注解，也就是说这个注解上就可以生成文档说明，并且这个也是默认的实用工具。这种注解应该在客户端上被注入。与此同时他们的方法也成为公共的API. Target /** * Indicates the kinds of program element to which an annotation type * is applicable. If a Target meta-annotation is not present on an * annotation type declaration, the declared type may be used on any * program element. If such a meta-annotation is present, the compiler * will enforce the specified usage restriction. * * For example, this meta-annotation indicates that the declared type is * itself a meta-annotation type. It can only be used on annotation type * declarations: * &lt;pre&gt; * &amp;#064;Target(ElementType.ANNOTATION_TYPE) * public &amp;#064;interface MetaAnnotationType { * ... * } * &lt;/pre&gt; * This meta-annotation indicates that the declared type is intended solely * for use as a member type in complex annotation type declarations. It * cannot be used to annotate anything directly: * &lt;pre&gt; * &amp;#064;Target({}) * public &amp;#064;interface MemberType { * ... * } * &lt;/pre&gt; * It is a compile-time error for a single ElementType constant to * appear more than once in a Target annotation. For example, the * following meta-annotation is illegal: * &lt;pre&gt; * &amp;#064;Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD}) * public &amp;#064;interface Bogus { * ... * } * &lt;/pre&gt; */ 同样上面仍然是Java JDK官网的说明，首先是说如果target指定的类型元素不存在的话，那么通过target指定的注解将可以用在任何地方，如果target指定元素，则该注解必须只能用在指定的元素上，target指定的元素是通过ElementType这个枚举类指定的，里面的枚举就是target可以指定的值。官网上的列子是Target(ElementType.ANNOTATION_TYPE)表明这个注解只能用在注解本省上面。还有一种属性不在ElementType枚举中，就是target（{}），就是通过{}的注解是用来在负责注解上的成员变量，他不能用在其他的地方。 ElementType.CONSTRUCTOR:用于描述构造器 ElementType.FIELD:成员变量、对象、属性（包括enum实例） ElementType.LOCAL_VARIABLE:用于描述局部变量 ElementType.METHOD:用于描述方法 ElementType.PACKAGE:用于描述包 ElementType.PARAMETER:用于描述参数 ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明 Retention /** * Indicates how long annotations with the annotated type are to * be retained. If no Retention annotation is present on * an annotation type declaration, the retention policy defaults to * {@code RetentionPolicy.CLASS}. * * &lt;p&gt;A Retention meta-annotation has effect only if the * meta-annotated type is used directly for annotation. It has no * effect if the meta-annotated type is used as a member type in * another annotation type. * * @author Joshua Bloch * @since 1.5 */ 这个类的属性是通过RetentionPolicy这个枚举类列举属性的，这个主要的作用是指定我们的注解存在的时间或者说是存在的时刻。这个属性只有直接用在原注释类型的注解上才有效。如果用在其他注解的成员变量上就没有效果了。 RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式 RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 Inherited /** * Indicates that an annotation type is automatically inherited. If * an Inherited meta-annotation is present on an annotation type * declaration, and the user queries the annotation type on a class * declaration, and the class declaration has no annotation for this type, * then the class&#39;s superclass will automatically be queried for the * annotation type. This process will be repeated until an annotation for this * type is found, or the top of the class hierarchy (Object) * is reached. If no superclass has an annotation for this type, then * the query will indicate that the class in question has no such annotation. * * &lt;p&gt;Note that this meta-annotation type has no effect if the annotated * type is used to annotate anything other than a class. Note also * that this meta-annotation only causes annotations to be inherited * from superclasses; annotations on implemented interfaces have no * effect. * * @author Joshua Bloch * @since 1.5 */ 一句话总结就是是否允许子类继承该注解 自定义注解 上面说了这么多，那么下面我们开始开发自己的注解吧。 构造器注解/** * 该注解用于doc文档 * 该注解用于类的构造函数的注解 * 该注解尽在运行期间有效 * @author xinhua * */ @Documented @Target(ElementType.CONSTRUCTOR) @Retention(RetentionPolicy.RUNTIME) public @interface ConstructorAnno { String decs() default &quot;我是描述构造函数的注解&quot;; } 字段注解/** * 该注解用于生成doc文档 * 该注解用于在类的字段属性上的注解 * 该注解尽在运行期间有效 * @author xinhua * */ @Documented @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface FieldAnno { String desc() default &quot;我是描述字段的注解&quot;; } 局部变量注解/** * 该注解用于生成doc文档 * 该注解用于在局部变量上的注解 * 该注解尽在运行期间有效 * @author xinhua * */ @Documented @Target(ElementType.LOCAL_VARIABLE) @Retention(RetentionPolicy.RUNTIME) public @interface LocalAnno { String desc() default &quot;我是描述一个局部变量的注解&quot;; } 方法注解/** * 这个注解用于生成doc文档 * 这个注解用于类的方法上的注解 * 这个注解尽在运行期间有效 * @author xinhua * */ @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MethodAnno { //默认提交时间 2017-2-28 String time() default &quot;2017-2-28&quot;; //默认 男 true 男 false 女 boolean sex() default true; } 包注解/** * 该注解用于生成doc文档 * 该注解用于在包的注解 * 该注解尽在运行期间有效 * @author xinhua * */ @Documented @Target(ElementType.PACKAGE) @Retention(RetentionPolicy.RUNTIME) public @interface PackageAnno { String desc() default &quot;我是描述包的注解&quot;; } 参数注解/** * 该注解用于doc文档的生成 * 该注解用于类的参数中 * 该注解尽在运行期间有效 * @author xinhua * */ @Documented @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) public @interface StuInfo { String value() default &quot;&quot;; } 类型注解/** * 该注解用于生活曾doc文档 * 该注解用于在类的注解 * 该注解尽在运行期间有效 * @author xinhua * */ @Documented @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface TypeAnno { String desc() default &quot;我是描述类型的注解&quot;; } 加入测试的实体类/** * 测试所有类型的注解的作用 * @author xinhua * */ public @TypeAnno(desc=&quot;我是普通类&quot;)class User { @FieldAnno private String UID; @FieldAnno(desc=&quot;我是UserName的&quot;) private String userName; @ConstructorAnno public User(){ } @MethodAnno(time=&quot;2015-12-8&quot; , sex=false) public void doHomeWork(@StuInfo(value=&quot;211311084&quot;) String UID, @StuInfo(value=&quot;张新华&quot;)String UserName){ @LocalAnno(desc=&quot;flag的局部变量&quot;)boolean flag; } } 加入测试的接口类public interface UserImp { public void DoHouseWork(@StuInfo(value=&quot;我是小学生&quot;)String stuType,@StuInfo(value=&quot;我在大扫除&quot;)String things); } 测试注解/** * 开始通过反射获取注解内容 * @author xinhua * */ public class Junit { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException { Class&lt;?&gt; userClass = Class.forName(&quot;tom.change.annotation.User&quot;); //实例化 Object userObject = userClass.newInstance(); //1--获取最外层的就是类的注解 TypeAnno System.out.println(&quot;.......................类注解.......................&quot;); TypeAnno typeAnno= userClass.getAnnotation(TypeAnno.class); System.out.println(typeAnno.desc()); //2--获取字段注解 首先获取通过反射获取类中的属性字段 System.out.println(&quot;.......................字段注解.......................&quot;); Field[] fields = userClass.getDeclaredFields(); for (Field field : fields) { FieldAnno fieldAnno = field.getAnnotation(FieldAnno.class); System.out.println(fieldAnno.desc()); } //3-- 方法的注解 System.out.println(&quot;.......................方法注解.......................&quot;); Method method = userClass.getMethod(&quot;doHomeWork&quot;, String.class,String.class); MethodAnno methodAnno = method.getAnnotation(MethodAnno.class); System.out.println(methodAnno.time()+&quot;@@@&quot;+methodAnno.sex()); //4-- 参数的注解 动态代理方式实现参数 System.out.println(&quot;.......................参数注解.......................&quot;); UserImp userImp=getMethodParameter(UserImp.class); userImp.DoHouseWork(&quot;张新华&quot;, &quot;--》扫地&quot;); //5--局部变量注解 System.out.println(&quot;.......................局部变量注解.......................&quot;); //赞未获得到 } public static&lt;T&gt; T getMethodParameter(Class&lt;T&gt; target){ return (T)Proxy.newProxyInstance(target.getClassLoader(), new Class&lt;?&gt;[]{target}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Annotation[][] parameterAnnotations = method.getParameterAnnotations(); for (int i=0;i&lt;parameterAnnotations.length;i++) { Annotation[] annotations=parameterAnnotations[i]; StuInfo stuInfo =(StuInfo) annotations[0]; System.out.println(stuInfo.value()+&quot;@@@&quot;+args[i]); } return null; } }); } } 效果图","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Javaweb表格加载---DataTable","date":"2017-02-27T11:43:00.000Z","path":"zxh/20170227.html","text":"Datatables是一款jquery表格插件 Datatables是一款jquery表格插件。它是一个高度灵活的工具，可以将任何HTML表格添加高级的交互功能。 使用 jQuery Datatable 构造数据列表，并且增加或者隐藏相应的列，已达到数据显示要求。同时， jQuery Datatable 强大的功能支持：排序，分页，搜索等。 datatable引入 css : //cdn.datatables.net/1.10.13/css/jquery.dataTables.min.css js : //cdn.datatables.net/1.10.13/js/jquery.dataTables.min.js 这里申明一下，引入这上面js前提是引入jquery，因为这是基于jquery开发的 表格的创建 环境准备好之后，我们需要提供一个table的样板。就是给一个table 并命名一个ID，下面是我项目中class样式，你可以不引入只需要一个id &lt;table class=&quot;table table-striped table-hover table-bordered&quot; id=&quot;adminTable&quot;&gt; &lt;/table&gt; 参数说明var adminTable = $(&#39;#adminTable&#39;).DataTable({}); 最后我们只需要在js中向上面那样就行了。只不过想要实现我们想象中的table我们需要对adminTable指定相应的参数。首先需要的就是请求地址的指定 sAjaxSource： 指定我们的请求路径 lengthMenu： 表格中每页的大小，就是下面的效果 pageLength：当前默认每页显示的数量 oLanguage：这里是一些语言的设置，提示语言的设置，默认是英文的，。 &quot;sProcessing&quot; : &quot;正在加载数据...&quot;, &quot;sSearch&quot; : &quot;搜索:&quot;, &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;, &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;, &quot;sInfo&quot; : &quot;第 _START_ 条到第 _END_ 条记录,一共 _TOTAL_ 条记录&quot;, &quot;sInfoEmpty&quot; : &quot;0条记录&quot;, &quot;oPaginate&quot; : { &quot;sPrevious&quot; : &quot;上一页 &quot;, &quot;sNext&quot; : &quot; 下一页&quot;, } 还有一些额外的设置，`”bSort” : true, &quot;bProcessing&quot; : true, &quot;bServerSide&quot; : true, &quot;async&quot; : false,` 最后数据显示才是重点。这个放在下面讲解 数据匹配显示 上面我们已经将表格的请求通过sAjaxSource这个属性指定好了，那么至于数据是如何显示在正确的位置的呢，主要是通过aoColumns这个属性匹配的。首先我们看看我们后台发回来的数据长啥样子 aaDataa是我们的数据，一看就知道是个list，aaData下表就是所在索引，每个索引里面又有1-7的索引，1-7就是相当于我们表格的7列，所以我们前台table就是遍历aaData将1-7附在对应的列上，datatable也很简单，就是按照顺序赋值的的，所以我们按顺序写列名就行了 [ { &quot;sTitle&quot; : &quot;id&quot;, &quot;bSortable&quot; : false }, { &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;adminChooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;, &quot;bSortable&quot; : false, &quot;sClass&quot; : &quot;text-center&quot;, &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol) { var value = oData[0]; var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;testCheckbox&quot; onclick=&quot;recordMainId(this)&quot; value=&quot;&#39;+value+&#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;; $(nTd).html(content); } }, { &quot;sTitle&quot; : &quot;用户名&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;姓名&quot;, &quot;bSortable&quot; : true, &quot;bAutoWidth&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;授权人&quot;, &quot;bSortable&quot; : false, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;已分配角色&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;管辖站点&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;创建时间&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;操作&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; } ] 至于每列的设置，大家看名称应该知道是啥意思。但是我们的列并不是仅仅显示数据的。比如有的是要加超链接。有的并不是仅仅显示原始数据，需要进行加工处理的。这里我们需要一个加工函数，上面也提到了。 列数据二次加工fnCreatedCell 方法就是多数据进行二次加工。 &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol) { var value = oData[0]; var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;testCheckbox&quot; onclick=&quot;recordMainId(this)&quot; value=&quot;&#39;+value+&#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;; $(nTd).html(content); } 其中值得一说的里面参数就是oData，oData就是所在行的所有列数据的集合数组。很有用的。比如你想去改行的第一列数据，直接oData[0]就取到了。在做修改删除很有用。 但是dataTable还通过另外一种方式对数据进行二次处理。就是通过aoColumnDefs这个属性来指定具体列的数据加工。 [ { &quot;bSearchable&quot; : true, &quot;bVisible&quot; : false, &quot;aTargets&quot; : [ 0 ] }, { &quot;aTargets&quot; : [ 3 ], &quot;mRender&quot; : function(data,type, full) { var value=full[0]; return &quot;&lt;a href=&#39;&#39; onclick=&#39;showUserInfo(\\&quot;&quot;+value+&quot;\\&quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data+ &quot;&lt;/a&gt;&quot;; } }, { &quot;aTargets&quot; : [ 4 ], &quot;mRender&quot; : function(data,type, full) { if(data==null) { data=&quot;@@@&quot; } var arr = data.split(&quot;@@@&quot;); return &quot;&lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39; onclick=&#39;showUserInfo(\\&quot;&quot;+ arr[0]+ &quot;\\&quot;)&#39; &gt;&quot;+ arr[1]+ &quot;&lt;/a&gt;&quot;; } }, { &quot;aTargets&quot; : [ 8 ], &quot;mRender&quot; : function(data,type, full) { return &quot;&lt;a href=&#39;javascript;;&#39; onclick=&#39; return adminUpdate(this)&#39; site=&#39;&quot;+ full[6]+ &quot;&#39; id=&#39;&quot;+ full[0]+ &quot;&#39; name=&#39;&quot;+ full[2]+ &quot;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#myModalUpdate&#39;&gt;修改&lt;/a&gt; &lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#deleteModal&#39; onclick=&#39;return adminDelete(this)&#39; id=&#39;&quot;+full[0]+&quot;&#39; role=&#39;&quot;+ full[5]+ &quot;&#39;&gt;删除&lt;/a&gt;&quot;; } } ] 这种方法缺陷就是需要我们指定列号，但是实际开发中我们的列号可能是会因为项目需求而改变的，所以这个方法不是很好，但是也能实现同样的效果。然后通过mRender指定函数时间，里面的full和oData是一个数据效果。 到这里数据显示及一些CURD操作基本就实现了。但是有的时候我们需要将表格加载数据是携带参数查询，这个时候我们除了在指定的请求上加，还有一种方法是在数据回调是处理的。通过fnServerData属性，我们可以加条件参数传入后台。 // 服务器端，数据回调处理 &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback) { aoData.push({ &quot;name&quot; : &quot;user_name&quot;, &quot;value&quot; : $(&#39;#user_name&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;real_name&quot;, &quot;value&quot; : $(&#39;#real_name&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;create_user_name&quot;, &quot;value&quot; : $( &#39;#create_user_name&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;site_id&quot;, &quot;value&quot; : $(&#39;#site_id&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;fromTime&quot;, &quot;value&quot; : $(&#39;#fromTime&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;toTime&quot;, &quot;value&quot; : $(&#39;#toTime&#39;).val() }); $.ajax({ &quot;type&quot; : &quot;POST&quot;, &quot;url&quot; : sSource, &quot;dataType&quot; : &quot;json&quot;, &quot;contentType&quot; : &quot;application/json&quot;, &quot;data&quot; : JSON.stringify(aoData), &quot;success&quot; : function(data) { fnCallback(data); } }); } 条件参数通过aoData.push方法加入。到这里前台table已经显示完了。我们在看看后台数据处理逻辑。 后台参数接收 前台我们指定的请求我们在后台对应的请求中加入如下参数。 前台中的aoData.push进来的参数及datatable自身关于分页等等的信息数据全是放在dataTableParams这个变量中。我们只需要将他转换成map就可以传入数据库操作了。 转map代码： HashMap&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); for (DataTableParam dataTableParam : dataTableParams) { paramsMap.put(dataTableParam.getName(), dataTableParam.getValue()); } 下面的操作我就不在细致说了，下面就是传入数据sql的操作了。 表格刷新 在实际中我们都需要不刷新页面只刷新页面中某个空间。datatable基于此需求专门提供了刷新表格的方法。在实际开发中我们改变了表中数据最后我们调用刷新的方法就行了 adminTable.draw(); 使用dataTable常见问题汇总 这个问题基本上就是数据不匹配，这是因为我在前台aoColumns中指定了7列，但是我们后台只穿回来6列的原因，只要少于7列都是这种错误。修改方法：去后台添加完整数据。就算某列时空也要加入，加入空字符串代替，因为前台是按顺序的加载数据的，所以没数据也要用空字符串占替位置。 dataTable发展的版本很多，不同的版本里面的参数名可能不太一样，需要注意一下，有的版本加载table的请求地址是通过ajax属性来实现的。有的就是sAjaxSource属性实现的，只是名称不一样了而已。 完整DataTable加载样本var adminTable= $(&#39;#adminTable&#39;).DataTable( { &quot;bSort&quot; : true, &quot;bProcessing&quot; : true, &quot;bServerSide&quot; : true, &quot;async&quot; : false, //&quot;retrieve&quot; : true,//保证只有一个table实例 &quot;bStateSave&quot; : false, &quot;sAjaxSource&quot; : jQuery.getBasePath() + &quot;/adminManage/tableDisplay.bsh&quot;, &quot;sDom&quot; : &#39;&lt;&quot;top&quot;l&lt;&quot;clear&quot;&gt;&gt;rt&lt;&quot;bottom&quot;ip&lt;&quot;clear&quot;&gt;&gt;&#39;, &quot;lengthMenu&quot; : [ 10, 25, 75, 100 ], &quot;pageLength&quot; : 10, &quot;oLanguage&quot; : { &quot;sProcessing&quot; : &quot;正在加载数据...&quot;, &quot;sSearch&quot; : &quot;搜索:&quot;, &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;, &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;, &quot;sInfo&quot; : &quot;第 _START_ 条到第 _END_ 条记录,一共 _TOTAL_ 条记录&quot;, &quot;sInfoEmpty&quot; : &quot;0条记录&quot;, &quot;oPaginate&quot; : { &quot;sPrevious&quot; : &quot;上一页 &quot;, &quot;sNext&quot; : &quot; 下一页&quot;, } }, &quot;aoColumnDefs&quot; : [ { &quot;bSearchable&quot; : true, &quot;bVisible&quot; : false, &quot;aTargets&quot; : [ 0 ] }, { &quot;aTargets&quot; : [ 3 ], &quot;mRender&quot; : function(data,type, full) { var value=full[0]; return &quot;&lt;a href=&#39;&#39; onclick=&#39;showUserInfo(\\&quot;&quot;+value+&quot;\\&quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data+ &quot;&lt;/a&gt;&quot;; } }, { &quot;aTargets&quot; : [ 4 ], &quot;mRender&quot; : function(data,type, full) { if(data==null) { data=&quot;@@@&quot; } var arr = data.split(&quot;@@@&quot;); return &quot;&lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39; onclick=&#39;showUserInfo(\\&quot;&quot;+ arr[0]+ &quot;\\&quot;)&#39; &gt;&quot;+ arr[1]+ &quot;&lt;/a&gt;&quot;; } }, { &quot;aTargets&quot; : [ 8 ], &quot;mRender&quot; : function(data,type, full) { return &quot;&lt;a href=&#39;javascript;;&#39; onclick=&#39; return adminUpdate(this)&#39; site=&#39;&quot;+ full[6]+ &quot;&#39; id=&#39;&quot;+ full[0]+ &quot;&#39; name=&#39;&quot;+ full[2]+ &quot;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#myModalUpdate&#39;&gt;修改&lt;/a&gt; &lt;a href=&#39;&#39; data-toggle=&#39;modal&#39; data-target=&#39;#deleteModal&#39; onclick=&#39;return adminDelete(this)&#39; id=&#39;&quot;+full[0]+&quot;&#39; role=&#39;&quot;+ full[5]+ &quot;&#39;&gt;删除&lt;/a&gt;&quot;; } } ], &quot;aoColumns&quot; : [ { &quot;sTitle&quot; : &quot;id&quot;, &quot;bSortable&quot; : false }, { &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;adminChooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;, &quot;bSortable&quot; : false, &quot;sClass&quot; : &quot;text-center&quot;, &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol) { var value = oData[0]; var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;testCheckbox&quot; onclick=&quot;recordMainId(this)&quot; value=&quot;&#39;+value+&#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;; $(nTd).html(content); } }, { &quot;sTitle&quot; : &quot;用户名&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;姓名&quot;, &quot;bSortable&quot; : true, &quot;bAutoWidth&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;授权人&quot;, &quot;bSortable&quot; : false, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;已分配角色&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;管辖站点&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;创建时间&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;操作&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; } ], // 服务器端，数据回调处理 &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback) { aoData.push({ &quot;name&quot; : &quot;user_name&quot;, &quot;value&quot; : $(&#39;#user_name&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;real_name&quot;, &quot;value&quot; : $(&#39;#real_name&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;create_user_name&quot;, &quot;value&quot; : $( &#39;#create_user_name&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;site_id&quot;, &quot;value&quot; : $(&#39;#site_id&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;fromTime&quot;, &quot;value&quot; : $(&#39;#fromTime&#39;).val() }); aoData.push({ &quot;name&quot; : &quot;toTime&quot;, &quot;value&quot; : $(&#39;#toTime&#39;).val() }); $.ajax({ &quot;type&quot; : &quot;POST&quot;, &quot;url&quot; : sSource, &quot;dataType&quot; : &quot;json&quot;, &quot;contentType&quot; : &quot;application/json&quot;, &quot;data&quot; : JSON.stringify(aoData), &quot;success&quot; : function(data) { fnCallback(data); } }); } }); } function initSelectTable() { UserDataTable = $(&#39;#selectUserTable&#39;).DataTable( { &quot;bSort&quot; : true, &quot;bProcessing&quot; : true, &quot;bServerSide&quot; : true, &quot;bStateSave&quot; : false, /* &quot;sScrollX&quot;: &quot;100%&quot;, &quot;sScrollXInner&quot;: &quot;100%&quot;, &quot;bScrollCollapse&quot;: true, */ &quot;bAutoWidth&quot; : false, &quot;sAjaxSource&quot; : jQuery.getBasePath()+ &quot;/userManage/getUserTable.bsh&quot;, &quot;sDom&quot; : &#39;&lt;&quot;top&quot;l&lt;&quot;clear&quot;&gt;&gt;rt&lt;&quot;bottom&quot;ip&lt;&quot;clear&quot;&gt;&gt;&#39;, &quot;lengthMenu&quot; : [ 3, 20, 30 ], &quot;pageLength&quot; : 3, &quot;oLanguage&quot; : { &quot;sProcessing&quot; : &quot;正在加载数据...&quot;, &quot;sSearch&quot; : &quot;搜索:&quot;, &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;, &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;, &quot;sInfo&quot; : &quot;第 _START_ 条到第 _END_ 条记录,一共 _TOTAL_ 条记录&quot;, &quot;sInfoEmpty&quot; : &quot;0条记录&quot;, &quot;oPaginate&quot; : { &quot;sPrevious&quot; : &quot;上一页 &quot;, &quot;sNext&quot; : &quot; 下一页&quot;, } }, &quot;aoColumnDefs&quot; : [ { &quot;bSearchable&quot; : true, &quot;bVisible&quot; : false, &quot;aTargets&quot; : [ 0 ] }, { &quot;aTargets&quot; : [ 1 ], &quot;mRender&quot; : function(data,type, full) { return &quot;&lt;a href=&#39;&#39; onclick=&#39;viewUser(&quot;+ full[0]+ &quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data + &quot;&lt;/a&gt;&quot;; } }, { &quot;aTargets&quot;:[2], &quot;mRender&quot;:function(data,type,full) { return &quot;&lt;a href=&#39;&#39; onclick=&#39;showUserInfo(\\&quot;&quot;+full[0]+&quot;\\&quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+data+&quot;&lt;/a&gt;&quot;; } }, { &quot;aTargets&quot; : [ 3 ], &quot;mRender&quot; : function(data,type, full) { if(data==&quot;1&quot;) { return &quot;已认证&quot;; } else if(data==&quot;2&quot;) { return &quot;未认证&quot;; } else if(data==&quot;3&quot;) { return &quot;待认证&quot;; } else if(data==&quot;4&quot;) { return &quot;已驳回&quot;; } } }, { &quot;aTargets&quot; : [ 4 ], &quot;mRender&quot; : function(data,type, full) { if (data &gt; 0) { return &quot;关闭&quot;; } else { return &quot;启用&quot;; } } } ], &quot;aoColumns&quot; : [ { &quot;sTitle&quot; : &quot;id&quot;, &quot;bSortable&quot; : false }, { &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;chooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;, &quot;bSortable&quot; : false, &quot;sClass&quot; : &quot;text-center&quot;, &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol) { var value = oData[0]+&quot;@@@&quot;+oData[2]; var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;userCheckbox&quot; onchange=&quot;recordUserId(this)&quot; name=&quot;&#39;+ oData[2]+ &#39;&quot; value=&quot;&#39;+ value+ &#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;; $(nTd).html(content); } }, { &quot;sTitle&quot; : &quot;用户名&quot;, &quot;bSortable&quot; : true, &quot;sWidth&quot; : &quot;120px&quot;, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;实名认证&quot;, &quot;sWidth&quot; : &quot;90px&quot;, &quot;bSortable&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;状态&quot;, &quot;sWidth&quot; : &quot;90px&quot;, &quot;bSortable&quot; : false, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;所属站点&quot;, &quot;bSortable&quot; : false, &quot;sWidth&quot; : &quot;180px&quot;, &quot;bAutoWidth&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; } ], // 服务器端，数据回调处理 &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback) { aoData.push({&quot;name&quot; : &quot;userName&quot;,&quot;value&quot; : $(&quot;#selectUserName&quot;).val()}); aoData.push({&quot;name&quot;:&quot;site&quot;,&quot;value&quot;:$(&quot;#site&quot;).val()}); /*aoData.push({&quot;name&quot;:&quot;end&quot;,&quot;value&quot;:$(&quot;#end&quot;).val()}); aoData.push({&quot;name&quot;:&quot;realName&quot;,&quot;value&quot;:$(&quot;#realName&quot;).val()}); aoData.push({&quot;name&quot;:&quot;status&quot;,&quot;value&quot;:$(&quot;#status&quot;).val()}); aoData.push({&quot;name&quot;:&quot;site&quot;,&quot;value&quot;:$(&quot;#site&quot;).val()}) */ $.ajax({ &quot;type&quot; : &quot;POST&quot;, &quot;url&quot; : sSource, &quot;dataType&quot; : &quot;json&quot;, &quot;contentType&quot; : &quot;application/json&quot;, &quot;data&quot; : JSON.stringify(aoData), &quot;success&quot; : function(data) { fnCallback(data); } }); } }); } function initRoleTable() { RoleDataTable = $(&#39;#selectRoleTable&#39;).DataTable( { &quot;bSort&quot; : true, &quot;bProcessing&quot; : true, &quot;bServerSide&quot; : true, &quot;bStateSave&quot; : false, /* &quot;sScrollX&quot;: &quot;100%&quot;, &quot;sScrollXInner&quot;: &quot;100%&quot;, &quot;bScrollCollapse&quot;: true, */ &quot;bAutoWidth&quot; : false, &quot;sAjaxSource&quot; : jQuery.getBasePath()+ &quot;/adminManage/roleList.bsh&quot;, &quot;sDom&quot; : &#39;&lt;&quot;top&quot;l&lt;&quot;clear&quot;&gt;&gt;rt&lt;&quot;bottom&quot;ip&lt;&quot;clear&quot;&gt;&gt;&#39;, &quot;lengthMenu&quot; : [ 3, 20, 30 ], &quot;pageLength&quot; : 3, &quot;oLanguage&quot; : { &quot;sProcessing&quot; : &quot;正在加载数据...&quot;, &quot;sSearch&quot; : &quot;搜索:&quot;, &quot;sLengthMenu&quot; : &quot;_MENU_条记录&quot;, &quot;sZeroRecords&quot; : &quot;没有查到记录&quot;, &quot;sInfo&quot; : &quot;第 _START_ 条到第 _END_ 条记录,一共 _TOTAL_ 条记录&quot;, &quot;sInfoEmpty&quot; : &quot;0条记录&quot;, &quot;oPaginate&quot; : { &quot;sPrevious&quot; : &quot;上一页 &quot;, &quot;sNext&quot; : &quot; 下一页&quot;, } }, &quot;aoColumnDefs&quot; : [ { &quot;bSearchable&quot; : true, &quot;bVisible&quot; : false, &quot;aTargets&quot; : [ 0 ] }, { &quot;aTargets&quot; : [ 1 ], &quot;mRender&quot; : function(data,type, full) { return &quot;&lt;a href=&#39;&#39; onclick=&#39;viewUser(&quot;+ full[0]+ &quot;)&#39; data-toggle=&#39;modal&#39; data-target=&#39;#viewModal&#39;&gt;&quot;+ data + &quot;&lt;/a&gt;&quot;; } } ], &quot;aoColumns&quot; : [ { &quot;sTitle&quot; : &quot;id&quot;, &quot;bSortable&quot; : false }, { &quot;sTitle&quot; : &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkAll&quot; onclick=&quot;roleChooseOrNoChoose(this)&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;, &quot;bSortable&quot; : false, &quot;sWidth&quot; : &quot;70px&quot;, &quot;sClass&quot; : &quot;text-center&quot;, &quot;fnCreatedCell&quot; : function(nTd, sData, oData,iRow, iCol) { var value = oData[0]+&quot;@@@&quot;+oData[2]; var content = &#39;&lt;label class=&quot;mt-checkbox mt-checkbox-single mt-checkbox-outline&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;roleCheckbox&quot; onchange=&quot;recordRoleId(this)&quot; name=&quot;&#39;+ oData[2]+ &#39;&quot; value=&quot;&#39;+ value+ &#39;&quot; /&gt;&lt;span&gt;&lt;/span&gt;&lt;/label&gt;&#39;; $(nTd).html(content); } }, { &quot;sTitle&quot; : &quot;用户名&quot;, &quot;bSortable&quot; : true, &quot;sWidth&quot; : &quot;120px&quot;, &quot;sClass&quot; : &quot;text-center&quot; }, { &quot;sTitle&quot; : &quot;创建时间&quot;, &quot;bSortable&quot; : false, &quot;sWidth&quot; : &quot;180px&quot;, &quot;bAutoWidth&quot; : true, &quot;sClass&quot; : &quot;text-center&quot; } ], // 服务器端，数据回调处理 &quot;fnServerData&quot; : function retrieveData(sSource, aoData, fnCallback) { aoData.push({&quot;name&quot; : &quot;sname&quot;,&quot;value&quot; : $(&#39;#selectRoleName&#39;).val()}); /*aoData.push({&quot;name&quot;:&quot;start&quot;,&quot;value&quot;:$(&quot;#start&quot;).val()}); aoData.push({&quot;name&quot;:&quot;end&quot;,&quot;value&quot;:$(&quot;#end&quot;).val()}); aoData.push({&quot;name&quot;:&quot;realName&quot;,&quot;value&quot;:$(&quot;#realName&quot;).val()}); aoData.push({&quot;name&quot;:&quot;status&quot;,&quot;value&quot;:$(&quot;#status&quot;).val()}); aoData.push({&quot;name&quot;:&quot;site&quot;,&quot;value&quot;:$(&quot;#site&quot;).val()}) */ $.ajax({ &quot;type&quot; : &quot;POST&quot;, &quot;url&quot; : sSource, &quot;dataType&quot; : &quot;json&quot;, &quot;contentType&quot; : &quot;application/json&quot;, &quot;data&quot; : JSON.stringify(aoData), &quot;success&quot; : function(data) { fnCallback(data); } }); } });","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"微信开发--开发模式简单配置","date":"2017-02-15T14:14:00.000Z","path":"zxh/20170215.html","text":"微信用户量很多，那么我们如何开始一个属于自己的微信小程序呢 微信用户量很多，那么我们如何开始一个属于自己的微信小程序呢，因为自己不是高微信的。最近研究了一下微信，只是先微信的一个小功能。那么下面开始微信开发的搭建。这里如何申请微信公众号自己去官网申请就行了。最后登录该公众号。下面从我公众号开始讲 开启开发者模式 点击左侧菜单的基本配置 然后是做微信开发我们得有一个属于自己的服务器，方便在上面编写代码。这里我用新浪云作为自己的服务器。新浪云服务注册地址 新浪云申请 进入新浪云后选择控制台sae 然后点击创建新应用 按钮 后弹出选择服务器的界面，我们选择标准版的，因为是免费的。 至于里面的二级域名这就是看个人喜好设置的了。设置好之后我们回到父页面，就是点击创建新应用的那个界面就会看到我们创建的应用了，我这里是我实现创立好的。 微信开发者配置 通过上面我们就已经有了服务器了，下面我们来填写微信的相关配置 上面的url就填写我们的新建的新浪云应用的地址，至于token随便你自己填写，只不过你得记住，因为在新浪云服务器里写代码的时候需要用到。 然后点击确定你的微信公众号就成为了开发者模式了。下面我们开始在服务器上实现我们的功能 微信服务器的代码编写 点击我们的应用的连接进入应用界面 选择左侧菜单树种的应用后再点击代码管理，在右侧就可以看到应用的编辑代码超链接了，点击超链接 这里我们可以选择我们index.php进行代码的修改，或者是实现。直接将下面的代码赋值到你的服务器里 &lt;?php /* 新华工作室 http://www.cnblogs.com/txw1958/ CopyRight 2014 All Rights Reserved */ define(&quot;TOKEN&quot;, &quot;与微信配置中的token对应&quot;); $wechatObj = new wechatCallbackapiTest(); if (!isset($_GET[&#39;echostr&#39;])) { $wechatObj-&gt;responseMsg(); }else{ $wechatObj-&gt;valid(); } class wechatCallbackapiTest { //验证签名 public function valid() { $echoStr = $_GET[&quot;echostr&quot;]; $signature = $_GET[&quot;signature&quot;]; $timestamp = $_GET[&quot;timestamp&quot;]; $nonce = $_GET[&quot;nonce&quot;]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature){ header(&#39;content-type:text&#39;); echo $echoStr; exit; } } //响应消息 public function responseMsg() { $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;]; if (!empty($postStr)){ $this-&gt;logger(&quot;R &quot;.$postStr); $postObj = simplexml_load_string($postStr, &#39;SimpleXMLElement&#39;, LIBXML_NOCDATA); $RX_TYPE = trim($postObj-&gt;MsgType); //消息类型分离 switch ($RX_TYPE) { case &quot;event&quot;: $result = $this-&gt;receiveEvent($postObj); break; case &quot;text&quot;: $result = $this-&gt;receiveText($postObj); break; default: $result = &quot;unknown msg type: &quot;.$RX_TYPE; break; } $this-&gt;logger(&quot;T &quot;.$result); echo $result; }else { echo &quot;&quot;; exit; } } //接收事件消息 private function receiveEvent($object) { $content = &quot;&quot;; switch ($object-&gt;Event) { case &quot;subscribe&quot;: $content = &quot;欢迎关注新华工作室 &quot;; $content .= (!empty($object-&gt;EventKey))?(&quot;\\n来自二维码场景 &quot;.str_replace(&quot;qrscene_&quot;,&quot;&quot;,$object-&gt;EventKey)):&quot;&quot;; break; case &quot;unsubscribe&quot;: $content = &quot;取消关注&quot;; break; case &quot;SCAN&quot;: $content = &quot;扫描场景 &quot;.$object-&gt;EventKey; break; case &quot;CLICK&quot;: switch ($object-&gt;EventKey) { case &quot;COMPANY&quot;: $content = array(); $content[] = array(&quot;Title&quot;=&gt;&quot;多图文1标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;); break; default: $content = &quot;点击菜单：&quot;.$object-&gt;EventKey; break; } break; case &quot;LOCATION&quot;: $content = &quot;上传位置：纬度 &quot;.$object-&gt;Latitude.&quot;;经度 &quot;.$object-&gt;Longitude; break; case &quot;VIEW&quot;: $content = &quot;跳转链接 &quot;.$object-&gt;EventKey; break; case &quot;MASSSENDJOBFINISH&quot;: $content = &quot;消息ID：&quot;.$object-&gt;MsgID.&quot;，结果：&quot;.$object-&gt;Status.&quot;，粉丝数：&quot;.$object-&gt;TotalCount.&quot;，过滤：&quot;.$object-&gt;FilterCount.&quot;，发送成功：&quot;.$object-&gt;SentCount.&quot;，发送失败：&quot;.$object-&gt;ErrorCount; break; default: $content = &quot;receive a new event: &quot;.$object-&gt;Event; break; } if(is_array($content)){ if (isset($content[0])){ $result = $this-&gt;transmitNews($object, $content); }else if (isset($content[&#39;MusicUrl&#39;])){ $result = $this-&gt;transmitMusic($object, $content); } }else{ $result = $this-&gt;transmitText($object, $content); } return $result; } //接收文本消息 private function receiveText($object) { $keyword = trim($object-&gt;Content); //多客服人工回复模式 if (strstr($keyword, &quot;您好&quot;) || strstr($keyword, &quot;你好&quot;) || strstr($keyword, &quot;在吗&quot;)){ $result = $this-&gt;transmitService($object); } //自动回复模式 else{ if (strstr($keyword, &quot;文本&quot;)){ $content = &quot;这是个文本消息&quot;; }else if (strstr($keyword, &quot;单图文&quot;)){ $content = array(); $content[] = array(&quot;Title&quot;=&gt;&quot;单图文标题&quot;, &quot;Description&quot;=&gt;&quot;单图文内容&quot;, &quot;PicUrl&quot;=&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;); }else if (strstr($keyword, &quot;图文&quot;) || strstr($keyword, &quot;多图文&quot;)){ $content = array(); $content[] = array(&quot;Title&quot;=&gt;&quot;多图文1标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;); $content[] = array(&quot;Title&quot;=&gt;&quot;多图文2标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://d.hiphotos.bdimg.com/wisegame/pic/item/f3529822720e0cf3ac9f1ada0846f21fbe09aaa3.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;); $content[] = array(&quot;Title&quot;=&gt;&quot;多图文3标题&quot;, &quot;Description&quot;=&gt;&quot;&quot;, &quot;PicUrl&quot;=&gt;&quot;http://g.hiphotos.bdimg.com/wisegame/pic/item/18cb0a46f21fbe090d338acc6a600c338644adfd.jpg&quot;, &quot;Url&quot; =&gt;&quot;http://m.cnblogs.com/?u=txw1958&quot;); }else if (strstr($keyword, &quot;音乐&quot;)){ $content = array(); $content = array(&quot;Title&quot;=&gt;&quot;最炫民族风&quot;, &quot;Description&quot;=&gt;&quot;歌手：凤凰传奇&quot;, &quot;MusicUrl&quot;=&gt;&quot;http://121.199.4.61/music/zxmzf.mp3&quot;, &quot;HQMusicUrl&quot;=&gt;&quot;http://121.199.4.61/music/zxmzf.mp3&quot;); }else{ $content = date(&quot;Y-m-d H:i:s&quot;,time()).&quot;\\n&quot;.&quot;ID&quot;.$object-&gt;FromUserName.&quot;\\n技术支持 新华工作室&quot;; } if(is_array($content)){ if (isset($content[0][&#39;PicUrl&#39;])){ $result = $this-&gt;transmitNews($object, $content); }else if (isset($content[&#39;MusicUrl&#39;])){ $result = $this-&gt;transmitMusic($object, $content); } }else{ $result = $this-&gt;transmitText($object, $content); } } return $result; } //回复文本消息 private function transmitText($object, $content) { $xmlTpl = &quot;&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;/xml&gt;&quot;; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content); return $result; } //回复语音消息 private function transmitVoice($object, $voiceArray) { $itemTpl = &quot;&lt;Voice&gt; &lt;MediaId&gt;&lt;![CDATA[%s]]&gt;&lt;/MediaId&gt; &lt;/Voice&gt;&quot;; $item_str = sprintf($itemTpl, $voiceArray[&#39;MediaId&#39;]); $xmlTpl = &quot;&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[voice]]&gt;&lt;/MsgType&gt; $item_str &lt;/xml&gt;&quot;; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; } //回复图文消息 private function transmitNews($object, $newsArray) { if(!is_array($newsArray)){ return; } $itemTpl = &quot; &lt;item&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt; &lt;/item&gt; &quot;; $item_str = &quot;&quot;; foreach ($newsArray as $item){ $item_str .= sprintf($itemTpl, $item[&#39;Title&#39;], $item[&#39;Description&#39;], $item[&#39;PicUrl&#39;], $item[&#39;Url&#39;]); } $xmlTpl = &quot;&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt; &lt;ArticleCount&gt;%s&lt;/ArticleCount&gt; &lt;Articles&gt; $item_str&lt;/Articles&gt; &lt;/xml&gt;&quot;; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), count($newsArray)); return $result; } //回复音乐消息 private function transmitMusic($object, $musicArray) { $itemTpl = &quot;&lt;Music&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt; &lt;MusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/MusicUrl&gt; &lt;HQMusicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/HQMusicUrl&gt; &lt;/Music&gt;&quot;; $item_str = sprintf($itemTpl, $musicArray[&#39;Title&#39;], $musicArray[&#39;Description&#39;], $musicArray[&#39;MusicUrl&#39;], $musicArray[&#39;HQMusicUrl&#39;]); $xmlTpl = &quot;&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[music]]&gt;&lt;/MsgType&gt; $item_str &lt;/xml&gt;&quot;; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; } //回复多客服消息 private function transmitService($object) { $xmlTpl = &quot;&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[transfer_customer_service]]&gt;&lt;/MsgType&gt; &lt;/xml&gt;&quot;; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time()); return $result; } //日志记录 private function logger($log_content) { if(isset($_SERVER[&#39;HTTP_APPNAME&#39;])){ //SAE sae_set_display_errors(false); sae_debug($log_content); sae_set_display_errors(true); }else if($_SERVER[&#39;REMOTE_ADDR&#39;] != &quot;127.0.0.1&quot;){ //LOCAL $max_size = 10000; $log_filename = &quot;log.xml&quot;; if(file_exists($log_filename) and (abs(filesize($log_filename)) &gt; $max_size)){unlink($log_filename);} file_put_contents($log_filename, date(&#39;H:i:s&#39;).&quot; &quot;.$log_content.&quot;\\r\\n&quot;, FILE_APPEND); } } } ?&gt; token一定要和微信配置中的相同 然后让我们看看效果吧","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"java反射","date":"2017-02-13T12:04:00.000Z","path":"zxh/20170213.html","text":"记得之前写了一篇json转实体的文章 记得之前写了一篇json转实体的文章，里面就用到了java反射的文章，但是当时只是了解到反射这个知识点，并没有深入的了解，寒假闲来无事觉顶深入整理一下java 反射的知识，一下都是个人学习反射的总结，不到之处，还望大神指点！！！ 反射顾名思义就是和java编译相反的过程，这里实现的效果就是通过类名来进行实例化类对象并对类进行操作。具体看下 获取父类和所有的接口 首先我们的java类是可以继承和实现多个接口的，那么我们如何通过java反射获取java类的父类和接口呢？ 首先我们在这里新建一个Annimal作为父类 public class Annimal { private String AnnimalName; public void eat(){ System.out.println(&quot;Annimal is eatting&quot;); } public void run(){ System.out.println(&quot;Annimal is running&quot;); } } 然后再新建一个Behaviour接口 public interface Behaviour { public String haviour=&quot;test&quot;; public void sayHello(); public void isAngury(); public void love(); } 现在让我们新建一个Dog类并让Dog类继承Annimal类并实现Behavour这个接口 public class Dog extends Annimal implements Behaviour Dog源码 public class Dog extends Annimal implements Behaviour{ private String dogName; public void fuck(String name){ System.out.println(&quot;fuck To : &quot;+name); } @Override public void sayHello() { // TODO Auto-generated method stub System.out.println(&quot;Dog sayHello&quot;); } @Override public void isAngury() { // TODO Auto-generated method stub System.out.println(&quot;Dog isAngury&quot;); } @Override public void love() { // TODO Auto-generated method stub System.out.println(&quot;Dog love&quot;); } } 测试 下面我们开始进行测试，首先我们通过Class类来获取类的class对象 Class&lt;?&gt; target=Class.forName(&quot;tom.change.Reflect.获取父类和所有接口.Dog&quot;); 然后通过getSuperClass和getInterfaces这两个方法就可以获取到父类和所有的接口 //获取Dog类的父类 Class&lt;?&gt; parent=target.getSuperclass(); //获取该类继承的所有类 Class&lt;?&gt; intefaces[]=target.getInterfaces(); 最后看程序运行的效果图 获取所有的属性(getDeclaredFields) 在Java类中出了类与类中关系，每个类还有具有特定的属性，那么我们如何通过反射来获取Java类中的属性呢。下面我写了一个user类，其中的属性为 Dog类： private String dogName; 那么下面我们来试试到底能不能获取上面的几个属性。同样通过类路径获取class对象 Class&lt;?&gt; clazz=Class.forName(&quot;tom.change.Reflect.获取父类和所有接口.Dog&quot;); 然后通过class对象的getDeclaredFields方法获取本地类的属性，这个方法是无法获取继承父类和接口中的属性，如果非要获取你可以先通过该类获取到父类，然后在去获取父类的class 对象，在去获取父类中属性。 for (int i = 0; i &lt; fields.length; i++) { //获取字段的修饰权限符 System.out.println(Modifier.toString(fields[i].getModifiers())+&quot;@@@&quot;+fields[i].getName()); } 这里说一下，获取后用Field 来接受，这个类getModifiers是获取该属性的属性的，私有还是公共还是保护的。 这里获取字段后，通过Field的set方法就可以给属性设置，不管属性的对外状态。前提是开启权限 field.setAccessible(true); field.set(object, &quot;21131084&quot;); 这里的object是class的一个实例化对象 获取类中的所有的方法（getMethods） 在上面我们已经获取了类中所有的属性，那么下面我们自然就是获取类中的所有的方法了。同样的步骤上面已经有了，这里不赘述了，只不过和上面的不同的地方就是获取class对象后我们调用getMethods方法。 public void tom.change.Reflect.获取父类和所有接口.Dog.fuck(java.lang.String) public void tom.change.Reflect.获取父类和所有接口.Dog.sayHello() public void tom.change.Reflect.获取父类和所有接口.Dog.love() public void tom.change.Reflect.获取父类和所有接口.Dog.isAngury() public void tom.change.Reflect.获取父类和所有接口.Annimal.run() public void tom.change.Reflect.获取父类和所有接口.Annimal.eat() public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public final void java.lang.Object.wait() throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public java.lang.String java.lang.Object.toString() public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() 大家有没有疑问，为什么有一些莫名的方法出现，有些方法甚至我们的Dog和继承类中都没有出现过，这是怎么回事呢。首先getMethods获取类本身的方法这是肯定的。继承的类我们也是可以获取的，这就解释了为什么我们的获取方法中有Annimal类中的方法，。那么后面那些Object类的方法是哪里来的呢，大家还记得吗所有的类都是继承Object类的。 类中方法的调用(getMethod) 在上面我们获取了方法后，通过getMethod获取指定的方法，该方法返回的是Method对象，然后通过Method里的invoke方法调用指定的方法。在调用的时候需要传入class实力化对象，有参数的话我们还需要传入参数。 public Object invoke(Object obj, Object... args) 源码显示，方法需要参数有多少这里就传入多少，这里是通用的。 在通过getMethod获取Method的时候我们需要传入方法参数的类型 public Object invoke(Object obj, Object... args) public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 获取所有构造函数（getConstructors） Java类中最后应该还剩下构造函数了，既然是反射，我们就要将类反射的干干晶晶的。获得class对象后我们通过getConstructors获取构造函数，该方法返回的是Constructor集合。在Constructor类中getParameterTypes获取构造函数中的参数，有个这个我们就可以自己进行类的构造了。 总结 到这里我们的反射已经完全可以操作一个类了。有人会问这有啥意思呢，在我们Javaweb中，哪些知名的框架源码里必须有反射，通过反射我们能够实现注解这个功能。当然注解还有其他知识，以后知道在介绍。再比如说我们将map与实体进行映射这里就需要反射区获取Java Bean中的属性并将map的值赋值。不管怎么样，反射是我们Java的重要知识，学会它对自己以后的架构方面试有很大的帮助的。 源码下载","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Spring项目集成ShiroFilter简单实现权限管理","date":"2017-02-13T12:00:00.000Z","path":"zxh/20170213.html","text":"Shiros是我们开发中常用的用来实现权限控制的一种工具包 Shiros是我们开发中常用的用来实现权限控制的一种工具包，它主要有认证、授权、加密、会话管理、与Web集成、缓存等功能。我是从事javaweb工作的，我就经常遇到需要实现权限控制的项目，之前我们都是靠查询数据获取列表拼接展示的，还有的是及时的判断权限的问题的，现在有了Shiros了，我们就可以统一的进行设置权限问题，Shrios的实现也是很简单的，下面让我们来看看具体实现步骤 web.xml配置 因为我们是与spring进行集成的，而spring的基本就是web项目的xml文件。所以我们在web.xml中配置shiros的过滤拦截。正常情况下，我们需要将shiro的filter配置在所有的filter前面，当然和encodingFilter这个filter是不区分前后的。因为两者互相不影响的。 &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由servlet container管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 好了，到这里shiro就集成到spring项目里面去了。What?对的，你妹看错，就这么简单，shiro就这一步就集成到项目里了。集成式集成了，但是想要完整的实现效果当然我们还是需要继续的往下配置的。在这里请记住我这里的shiroq过滤器的名字叫shiroFilter(后面有用的)。下面我们的shiro需要到spring的配置文件application.xml文件里去配置，在我的项目的我的spring配置文件是spring-service.xml。而在spring-service.xml中又引入了spring-shiro.xml，也就是说最后shiro的配置是配置在spring-shiro.xml文件中。最终源码在最后下载 spring-shiro.xml 这里我们将来看看spring-shiro.xml的配置，这里我采取倒叙的方式讲解，我觉的倒叙更加的有助于我们理解代码。首先我们还记得在web.xml中配置的那个filter吧，名字shiroFilter,对spring-shiro.xml配置文件就是通过这个filter展开的。首先我们在web.xml配置的过滤器实际上是配置ShiroFilterFactoryBean，所以在这里需要将ShiroFilterFactoryBean定义为shiroFilter &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!-- 要求登录时的链接(可根据项目的URL进行替换),非必须的属性,默认会自动寻找Web工程根目录下的&quot;/login.html&quot;页面 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.html&quot;/&gt; &lt;!-- 登录成功后要跳转的连接 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/index.html&quot;/&gt; &lt;!-- 用户访问未对其授权的资源时,所显示的连接 --&gt; &lt;!-- 若想更明显的测试此属性可以修改它的值,如unauthor.jsp,然后用[玄玉]登录后访问/admin/listUser.jsp就看见浏览器会显示unauthor.jsp --&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/login.html&quot; /&gt; &lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt; &lt;!-- 此处可配合我的这篇文章来理解各个过滤连的作用http://blog.csdn.net/jadyer/article/details/12172839 --&gt; &lt;!-- 下面value值的第一个&#39;/&#39;代表的路径是相对于HttpServletRequest.getContextPath()的值来的 --&gt; &lt;!-- anon：它对应的过滤器里面是空的,什么都没做,这里.do和.jsp后面的*表示参数,比方说login.jsp?main这种 --&gt; &lt;!-- authc：该过滤器下的页面必须验证后才能访问,它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /statics/**=anon /login.html=anon /sys/schedule.html=perms[sys:schedule:save] /sys/login=anon /captcha.jpg=anon /**=authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 具体的上面的代码注释已经解释的很清楚了，在这里主要讲解下filterChainDefinitions里面的设置属性。里面的value就是我们控制的页面权限设置。filterChainDefinitions的原则是按顺序查找一旦查找到符合的页面要求就不在继续查找了。所以我们需要将有通配符的页面设置在最后。上面配置中有/sys/schedule.html=perms[sys:schedule:save]意思就是说访问schedule.html这个页面前提是你得有sys:schedule:save这个权限。至于这个权限在哪里配置。在这里先透露一下。在Realm中获取 在上面的配置我们securityManager属性是shiro 安全核心配置接口，这里需要我们自己填写，这里的配置就是需要我们实现我们的认证，因为不同的项目我们认证权限肯定是不一样的。所以这也是shiro给我们唯一为数不多的代码编写的接口，我们只需要在这接口提供我们自己的认证和角色权限分配就行了。 &lt;!-- Shiro默认会使用Servlet容器的Session,可通过sessionMode属性来指定使用Shiro原生Session --&gt; &lt;!-- 即&lt;property name=&quot;sessionMode&quot; value=&quot;native&quot;/&gt;,详细说明见官方文档 --&gt; &lt;!-- 这里主要是设置自定义的单Realm应用,若有多个Realm,可使用&#39;realms&#39;属性代替 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;/bean&gt; 那么这里有出现了一个realm，这个realm就是我们实现权限和认证的地方。我们只需要通过spring将我们的实现类指定为realm即可 &lt;bean id=&quot;userRealm&quot; class=&quot;io.renren.shiro.UserRealm&quot;/&gt; 在讲UserRealm之前我们先来看看shir默认的realm逻辑是咋样的 通常我们只需要继承AuthorizingRealm(授权)，因为AuthorizingRealm里面继承了AuthenticatingRealm（认证），所以我们只需要继承AuthorizingRealm（授权），我们就可以重写授权和认证两个方法了，这两个方法里面就实现权限管理操作。 首先来看看在认证登录中我们有哪些值得注意的地方 doGetAuthenticationInfo中实现登录认证出现的几种异常 UnknownAccountException：获取的user为空 LockedAccountException ：此用户被锁住了 IncorrectCredentialsException ： 密码不正确(建议提示为 用户名或密码错误。安全考虑) ExcessiveAttemptsException ： 密码错误次数太多(现在很多网站上都有相关的操作) 最后通过用户名+明文密码+Reaml中的getName进行用户信息组装 登录认证就这几点注意，其次就是权限分配了，doGetAuthorizationInfo(授权)，在doGetAuthorizationInfo里我们通过PrincipalCollection这个身份集合，当我们只配置了一个Reaml的时候我们可以通过PrincipalCollection中的getPrimaryPrincipal方法获得刚刚传入的Reaml(用户名)就行了，但是当我们配置了多个Reaml的时候可以通过PrincipalCollection中的getRealmNames获取所有的Reaml的用户名就行了。 然后通过用户名去数据库获取权限菜单。最后返回一个带有角色和权限的 SimpleAuthorization的信息，意思就是一下角色具有哪些权限。如果就一个角色的时候也可以不指定角色，分别通过setStringPermissions(指定权限)+setRoles(指定角色) 到这里shiro的配置就完成了。 另外还有一点shiro的配置是处理shiro的生命周期和shiro的注解的启用的，这里就不解释了，直接上代码 &lt;!-- Shiro生命周期处理器 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; &lt;!-- AOP式方法级权限检查 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启shiro注解 --&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; spring-shiro.xml源码&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd&quot;&gt; &lt;!-- 继承自AuthorizingRealm的自定义Realm,即指定Shiro验证用户登录的类为自定义的UserRealm.java --&gt; &lt;bean id=&quot;userRealm&quot; class=&quot;io.renren.shiro.UserRealm&quot;/&gt; &lt;!-- Shiro默认会使用Servlet容器的Session,可通过sessionMode属性来指定使用Shiro原生Session --&gt; &lt;!-- 即&lt;property name=&quot;sessionMode&quot; value=&quot;native&quot;/&gt;,详细说明见官方文档 --&gt; &lt;!-- 这里主要是设置自定义的单Realm应用,若有多个Realm,可使用&#39;realms&#39;属性代替 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;/bean&gt; &lt;!-- Shiro主过滤器本身功能十分强大,其强大之处就在于它支持任何基于URL路径表达式的、自定义的过滤器的执行 --&gt; &lt;!-- Web应用中,Shiro可控制的Web请求必须经过Shiro主过滤器的拦截,Shiro对基于Spring的Web应用提供了完美的支持 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!-- 要求登录时的链接(可根据项目的URL进行替换),非必须的属性,默认会自动寻找Web工程根目录下的&quot;/login.html&quot;页面 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.html&quot;/&gt; &lt;!-- 登录成功后要跳转的连接 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/index.html&quot;/&gt; &lt;!-- 用户访问未对其授权的资源时,所显示的连接 --&gt; &lt;!-- 若想更明显的测试此属性可以修改它的值,如unauthor.jsp,然后用[玄玉]登录后访问/admin/listUser.jsp就看见浏览器会显示unauthor.jsp --&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/login.html&quot; /&gt; &lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt; &lt;!-- 此处可配合我的这篇文章来理解各个过滤连的作用http://blog.csdn.net/jadyer/article/details/12172839 --&gt; &lt;!-- 下面value值的第一个&#39;/&#39;代表的路径是相对于HttpServletRequest.getContextPath()的值来的 --&gt; &lt;!-- anon：它对应的过滤器里面是空的,什么都没做,这里.do和.jsp后面的*表示参数,比方说login.jsp?main这种 --&gt; &lt;!-- authc：该过滤器下的页面必须验证后才能访问,它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /statics/**=anon /login.html=anon /sys/schedule.html=perms[sys:schedule:save] /sys/login=anon /captcha.jpg=anon /**=authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Shiro生命周期处理器 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; &lt;!-- AOP式方法级权限检查 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启shiro注解 --&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; Shiro的其他权限过滤器及其用法 anon ：org.apache.shiro.web.filter.authc.AnonymousFilter /statics/**=anon ：以statics开头的请求可以随便访问，没有权限 authc：org.apache.shiro.web.filter.authc.FormAuthenticationFilter /**=authc ：表示所有的请求都需要进行验证权限且权限通过才能放行 authcBasic：org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter /admins/user/**=authcBasic ：表示没有通过httpbasic认证的 perms：org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter /admins/user/*=perms[user:add:] ：上面已经解释过了，表示访问./admins/user/..的请求必须是由use:add:*权限的才可以访问，否则重定向登录页面(这里的登录页面默认是web下的login.html，正常我们通过设置shiro中的filterChainDefinitions属性设置页面)。 port : org.apache.shiro.web.filter.authz.PortFilter /admins/user/**=port[8081] :当访问的请求端口不是8001时，则shiro会重定向到schemal://serverName:8081?queryString请求。这个请求中schemal是http或者https,serverName是我们原请求中的域名，8081就是我们port里设置端口号，queryString是我们原请求中携带的参数。 rest :org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter /admins/user/**=rest[user] :rest表示请求方法。相当于perms[user:method],这里method值得是post，get , delete. roles :org.apache.shiro.web.filter.authz.RolesAuthorizationFilter /admins/user/**=roles[admin] :这个和perms使用时一样的，只不过在后台我们是通过setRoles方法给用户设置角色的。 ssl : org.apache.shiro.web.filter.authz.SslFilter /admins/user/**=ssl : 表示该请求是安全请求，协议是https user ： org.apache.shiro.web.filter.authc.UserFilter /admins/user/**=user 表示必须存在用户，在登录操作是不进行检查的，因为登录的时候根本就不存在用户。 logout : org.apache.shiro.web.filter.authc.LogoutFilter /admins/user/**=logout ： 表示该请求是退出操作 注意！上面中roles，perms，rest这三个里面是可以带参数的，如果有多个参数参数之间必须用英文装填下的逗号分隔。在页面中判断是所有参数都满足才算是满足的。 以上是自己根据别的文章加上自己认识总结，参考一下文章 http://jinnianshilongnian.iteye.com/blog/2018398","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"java swing 开发 -JTable","date":"2017-01-19T12:15:00.000Z","path":"zxh/20170119.html","text":"最近利用空闲时间自己琢磨了一下java swing 编程 最近利用空闲时间自己琢磨了一下java swing 编程，其实在从事javaweb之前我一直向往的就是java swing 开发，不知道为什么可能当时觉得Windows上的exe程序很是神奇，关于windows上制作exe我之前也有介绍 exe打包教程一exe打包教程二 java swing开发都是自己琢磨的，有的地方写的不规范，不过大多都是网上借鉴的，应该不算离谱的。今天看了看自己的java swing的程序，感觉写的还不错，但是发现现在遇到一个瓶颈问题，就是jtable的使用，由于一开始概念不理解现在jtable得重新写，之前我吧数据放在jtable上了，但是真正开发的java swing数据都是放在TableModel上的。下面就Jtable的使用，好好整理了一番，途中参考的文章我都会放在下面列出，读者可以自己参考 JTable结构梳理 JTable=TableHeader+TableColumn 顾名思义我们知道表格是由表头和表列组成的，这两个都是单独的控件。但是JTable中如果想让表头显示仅仅将JTable加入Jpanel或者Jframe中是不行的，我这里提供两种方式实现 1、分别将TableHeader和TableColumn加入控件中单独的显示，这种情况不常见 2、先将JTable加入jscrollpane(滚动条)中，然后在将滚动条加入到对应的控件中(Jpanel或者是Jframe).java swing 开发中加入滚动条是很常见的操作，所以这种方式的加入表格还是很推荐的。 table = new JTable(data, columnNames); table.setBackground(Color.gray); table.setPreferredScrollableViewportSize(new Dimension(800, 100)); table.setFillsViewportHeight(false); pane = new JScrollPane(table); this.add(pane); 上面的代码就是简单的实现将表格以显示表头的方式加入到jframe中显示。其中我们能够看到多了几个设置，setPreferredScrollableViewportSize可有可无的，无所谓，但是setFillsViewportHeight是设置表格在纵向上的铺展情况，什么意思呢，如果这里设置为true则表格就会在纵向上铺满jframe,如果是false，表格则会按照自己的实际占地面积显示，不会多占的。 JTable数据显示 java swing中jtable是mvc形式的，所以jtable仅仅是数据的显示，而真正和数据绑定的却是TableModel这个接口，我们先看看这个接口的内部有哪些方法，这样我们心里才有个底。 众多周知jtable中常用的两种构造函数一个是数组另一个是vector，这两种构造函数中都是采用了匿名内部类实现tablemodel,前者用的是AbstractTableModel，后者是DefaultTableModel。而DefaultTableModel有事继承了AbstractTableModel，所以我们平时如果自定义model的话，都会去继承AbstractTableModel的。我们在去源码里可以看见，我们会发现AbstractTableModel有事继承TableModel这个接口的。所以我们的所有方法都是源于他。 我们观察AbstractTableModel源码中注释发现，我们只需要继承AbstractTableModel类后只需要实现三个必须的方法，其他的方法根据需要实现 public int getRowCount(); public int getColumnCount(); public Object getValueAt(int row, int column); 这三个方法的作用就是通过model高数jtable我需要一个几行几列的表格，至于每个单元格显示的内容就是通过getValueAt这个方法实现的，到这里我们就实现了，jtable的model自定义显示。 //表格的列，需要用户自己设定好 private int column; //待加载的数据 数据每行的列数和上面要统一好 private List&lt;Object&gt; list; public MyTableModel(List&lt;Object&gt; list,int column){ this.column=column; this.list=list; } @Override public int getRowCount() { // TODO Auto-generated method stub return list.size(); } @Override public int getColumnCount() { // TODO Auto-generated method stub return this.column; } @Override public Object getValueAt(int rowIndex, int columnIndex) { // TODO Auto-generated method stub return list.get(rowIndex).toString()+&quot;_&quot;+rowIndex+&quot;_&quot;+columnIndex; } 上面的代码就是我的model类，里面有个穿list的构造函数，然后我们看看我们的三个方法就起到了作用了。然后在getValueAt获取指定行数的list的指定内容就可以填充到表格上了。 jtable数据的CURD 在上面我们继承了AbstractTableModel，这里面有对数据的CURD操作 if(&quot;增加&quot;.equals(command)){ List&lt;Object&gt; data = getData(); data.add(&quot;test5&quot;); data.add(&quot;test6&quot;); datamModel.setList(data); // datamModel.fireTableStructureChanged(); datamModel.fireTableRowsInserted(5,6); }else if(&quot;删除&quot;.equals(command)){ List&lt;Object&gt; data = getData(); data.remove(2); datamModel.setList(data); datamModel.fireTableRowsDeleted(1, 1); }else if(&quot;更新&quot;.equals(command)){ List&lt;Object&gt; data = getData(); data.set(0, &quot;test0_1&quot;); datamModel.setList(data); datamModel.fireTableRowsUpdated(0, 5); } 里面都会带有参数比如datamModel.fireTableRowsUpdated(0, 5);的意思是通州JTable显示模块去刷新从1-6行的所有数据，所以说比如你更新了第一行的数据，而你用的两个参数是1,4.那么恭喜你，你的更新JTable无法实现，因为他只更新从第二行开始到第五行的数据。其他的方法参数和他一样。通过上面就可以轻松实现JTable的CURD操作。 JTable控件显示法 相信有的朋友遇到过，表格中需要显示CheckBox、button等控件的，但是我们发现我们定义的控件在表格上显示成了控件对应的类的字符串了，这又是为什么呢。下面请随我一起看看源码吧： /** * Returns &lt;code&gt;Object.class&lt;/code&gt; regardless of &lt;code&gt;columnIndex&lt;/code&gt;. * * @param columnIndex the column being queried * @return the Object.class */ public Class&lt;?&gt; getColumnClass(int columnIndex) { return Object.class; } 源码中AbstractTableModel的getColumnClass的方法是JTable决定显示类型的主要依据，源码中返回的默认是object.class，这就意味着我们在jtable是true或false或其他类，在这里都会返回object.class，那么jtable就会采用默认的渲染方式去渲染表格，默认的就是所有都是字符串形式展示，这个设置在JTable中的源码中 protected void createDefaultRenderers() { defaultRenderersByColumnClass = new UIDefaults(8, 0.75f); // Objects setLazyRenderer(Object.class, &quot;javax.swing.table.DefaultTableCellRenderer$UIResource&quot;); // Numbers setLazyRenderer(Number.class, &quot;javax.swing.JTable$NumberRenderer&quot;); // Doubles and Floats setLazyRenderer(Float.class, &quot;javax.swing.JTable$DoubleRenderer&quot;); setLazyRenderer(Double.class, &quot;javax.swing.JTable$DoubleRenderer&quot;); // Dates setLazyRenderer(Date.class, &quot;javax.swing.JTable$DateRenderer&quot;); // Icons and ImageIcons setLazyRenderer(Icon.class, &quot;javax.swing.JTable$IconRenderer&quot;); setLazyRenderer(ImageIcon.class, &quot;javax.swing.JTable$IconRenderer&quot;); // Booleans setLazyRenderer(Boolean.class, &quot;javax.swing.JTable$BooleanRenderer&quot;); } 源码中就有渲染器专门处理bool类型的，那么我们只需要在getColumnClass进行处理就行了，在我们的bool的单元格返回bool类JTable就会采用bool类型的渲染器了。 return getValueAt(0, c).getClass(); 这样我们就可以显示一些其他的控件了，还有一些比如每行都需要一行按钮来实现修改改行的功能，这些按钮正常我们不需要再数据中添加(避免数据过于庞大)，如果不在数据中添加那么我们的getClass方法就起不到作用，这个用到了下面的知识来解决 JTable渲染和编辑 这种呢其实就是上面的getClass底层的实现方式，JTable中源码我们上面可以看出JTable通过返回的不同的类来调用不同的渲染器，现在我们不通过返回类的方式来渲染，而是自己定义一个渲染器，然后通过JTable提供的方法设定用该渲染器渲染该单元格！ setCellEditor和setCellRenderer 大家可以观察源码，在JTable的编辑器中AbstractCellEditor是基础的抽象类，他继承了CellEditor,怎么样熟悉吗，这个不就是和AbstractTableModel 是一样的吗。但是这个类不能反回控件需要和TableCellEditor结合使用，或者我们只是用另外一个基础类DefaultCellEditor， DefaultCellEditor和AbstractTableModel 有设么区别呢，他们都是一样实现了CellEditor接口，但是前者构造中只能传入控件，也就是说每日次实力只能通过不同构造函数构建不同的控件，但是后者是抽象类，继承的类可以自定义构造函数，这就方便我们够赞多个不同的控件了，所以这两个大家看情况使用。最后都是通过getTableCellEditorComponent这个函数将控件返回出去。 设置完了编辑器，我们最终要是只渲染器，就是JTable最终如何显示的问题。和上面的那个一样。继承TableCellRenderer类，通过getTableCellRendererComponent方法返回渲染成设么控件，渲染的控件我们可以进行二次封装。 调用如下 两个参数就是通过上面两个类构造的类 column.setCellEditor(editor); column.setCellRenderer(renderer); 源码下载","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Redis回顾","date":"2017-01-18T07:10:00.000Z","path":"zxh/20170118.html","text":"之前有两篇文章着重介绍了redis集群的搭建和redis与spring的整合 之前有两篇文章着重介绍了redis集群的搭建和redis与spring的整合，一个月过去了，现在有些忘记了，今天又拿过来稳固一下，发现有很多的东西都忘记了。 资料汇总下载 首先安装ruby环境 安装过程出现如下页面我们要勾选下面三个框，这是安装环境变量的 rubygem安装，在我的资料包里我放了两个版本，大家最好选用最新的版本。这样会避免版本冲突问题。解压最新版本的rubygem后双击setup 双击之后打开cmd窗口，直接运行如下代码，分行运行 1、 gem sources -r https://rubygems.org/2、 gem sources -a https://gems.ruby-china.org3、 gem install redis 其中如果添加新源出错可以将https改成http试试 到这里我们准备工作完成了，然后下载我的资料包将redis–&gt;redis–&gt;testcluster文件下的7000-7005分别启动redis节点，这里举例说明7000，其他的都是一样的操作 执行之前最好删除下面两个文件 删除之后点击7000，如果防火墙拦截点击允许就行了。 最后在开一个cmd窗口到我的那个资料包里就是 XXXX/redis下执行redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"exe4j打包--exe转安装包","date":"2017-01-12T09:30:00.000Z","path":"zxh/20170112.html","text":"前面一篇已经详细的说明了打包成exe的步骤了， 前面一篇已经详细的说明了打包成exe的步骤了，下面谈谈exe如何压缩成安装文件。这里用到之前的另外一个软件，具体软件看这篇文章exe4j打包成exe 打开inno 编辑器 打开软件后我们选择 用[脚本向导]创建新的脚本文件 点击确定 点击next后会出现如下界面，里面的字段都是汉字，应该不用解释了吧 点击下一步，选择文件夹部分默认，然后继续点击下一步，出现如下界面 这里执行文件我们需要改动，改成我们上面一篇文章说的打成的那个exe文件，这里指的注意的是，我们之前的exe打包用到了jdk或者jre,在这里我们同样需要，打exe时用的是jre这里就选择jre，用的jdk就选择jdk 这里之后我们就可以一直下一步，里面的信息都是汉字提示，你根据意思选择性填写，不填写也咩关系。最好到这里 确定之后你就可以安心的等待了。打包完成之后你就可以去下面那个界面设置的路径找安装包了，如果你没有设置就会在inno 安装包的output文件夹里。祝你好运会！ 效果 下面看看我的程序打成的安装程序效果 此时程序左面下表也跟着变了 安装过程 安装完成 补充：在下面这张图添加文件的时候一定要选择到父文件，比如我们打包exe是选择D:\\zxh\\jre那么我们这里就要选择D:\\zxh之前我选择错了，下面是错误的案例，应该改为 C:\\Users\\87077\\Documents\\test\\* 所以建议在选择jre或者jdk是最好同级的没有其他文件夹，避免安装不必要的文件，是的软件过于假庞大 之前说jdk和jre都可以，我自己试了试本文用jre打包不成功，用jdk才成功。在这里抱歉啦。大家还是同意用jdk","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"exe4j打包--jar打包exe","date":"2017-01-12T09:00:00.000Z","path":"zxh/20170112.html","text":"本文重点介绍如何将我们写的java代码打包成在电脑上可以运行的exe文件 本文重点介绍如何将我们写的java代码打包成在电脑上可以运行的exe文件。这里只介绍直接打包成exe的方法，至于打包成exe安装包下节介绍 test 软件准备exe4j集合包下载地址(下节内容也在这里) 今天我们下载好上面的内容之后只需要用到其中的一个软件，对，就是里面的exe4.exe文件 然后就是安装这个软件，软件都是傻瓜式安装。不多说！安装后首页显示，激活码去网上搜索！ jar包准备 在打包之前我们当然得先准备jar包啦。选择项目右击–&gt;Export–&gt;Runnable JAR file 点击下一步 别忘记选择主入口，这些在之前的文章都已经说过了。 打包开始 在打包开始我们得想之前我用jsmooth打包exe文件一样，需要准备jre文件，我这里就用了jdk文件，jre好像不行 下面就开始打包的真正的开始了，首先我们打开之前安装好的exe4j这个软件。直接点击第二步：peoject type 选择 JAR in EXE mode 点击next我们会看到需要我们填写工程的简名和程序的输出地址，工程简名可以随便填写，输出地址 就是你想把你的exe文件最后输出在哪里，建议放在你好找的地方，毕竟以后你只用点击exe就能运行了。 然是继续点击next，下一个界面我们遇到选择模式的Executable type，这里就取决与我们java的代码了，如果你开发的是黑窗体程序就选择console application； 如果开发的是java swing 程序那就选择默认的GUI application ，第三个选项我也不知道是java 什么程序。读者可以自己研究。我这里就选择默认的GUI程序了。 第二个选项是Executable name 顾名思义就是你程序的名字，你可以起一个响亮的名字，这里支持中文名字的。 第三个选项是Icon File 这就是我们exe层序的图标，就像QQ软件那个企鹅一样，建议可以设置成自己的个性照片，但是这个只能用ico格式的图片。当然也可以不选择，就用系统默认的图标 这里设置好之后我们点击界面的左侧菜单Executable info 下面的Advanced options，因为这里我们需要设置一些详细信息，这里不点很难成功的打包的。 Redirection参数 service options 这里的参数我们自己看看懂了，大家可以设置也可以不设置。 version info 这里也不重要，看看我的参考吧 32 -bit or 64 - bit这个就是取决于你的i项目在那里运行了，如果你想让他在64系统下能运行你就选择Generate 64-bit executable 打上√，否则不勾。 Mainfest options 这里不选择，让他默认就行了 然后就是添加jar包了。(java invocaton) 在class path中点击加号选择我们之前打好的jar包 选择好 jar包我们就选择下面的Main classs中选择我们需要程序运行的主入口，这个对于开发来说应该都懂得。 jre部分设置好最低最高版本之后点击Advanced Options–&gt;Search sequence ,默认是会选择我们电脑上系统环境中的jdk,但是我们系统环境的jdk不能被别人用到所以我们这里把默认的三个全部散掉，然后添加我们事先准备好的jdk next之后出现Preferred VM 中选择Client hostpost VM next之后，我们到了Splash screen,就是你的程序启动界面，如果你想做的酷炫点就可以选择一下，这里图片没有限制应该，我选的就是普通的图片，你也可以试试GIF 动态图。 到这里你就可以一直下一步。一直到下面这个界面你就可以选择Finishing 或者启动程序了。 效果图 启动图 运行后界面 图标变了 其他你可以右键这个exe看看属性就是我们上面设置的一些可有可无的东西楽。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"观书有感(摘自12期CSDN)","date":"2017-01-09T14:32:00.000Z","path":"zxh/20170109.html","text":"CSDN要闻 CSDN要闻 Visual Studio 将登陆Mac平台 在11月的Connect（）上，微软正式发布了Visual Studio For Max预览版，这是微软这一编程工具首次进入苹果平台。Vistual Studio For Mac 以被微软收购的C#语言跨平台应用集成开发环境Xamarim Studio为基础，UX用户界面则源自windows版本。Visual Studio For Mac 上的主要工作是通过Xamarim原声的ios、android和mac开发。与Xamarin Studio 一样，Visual Studio For Mac 基于微软的Monodevelop IDE 开源项目。此项目完全使用C#编写，支持丰富的扩展模型。 FaceBook 计划加强其新闻审核机制 据透露，FaceBook 曾秘密开发工具，以防止帖子出现在特定地区用户的新闻流中。这一举措是为了打入敏感市场，新的软件会提供给第三方使用，以监控社交网络中的帖子和话题，确定是否显示这些内容，同时，由于FaceBook的算法问题，在美国大选期间曾有错误信息被肆意的放大和传播，目前，FaceBook的产品管理VP承认，公司的确需要在新闻审查机制方面做出更多努力。 美国废止DMCA(数字千年版权法案) 2016年10月，美国提出：对DMCA法案进行为期两年的尝试性废止。至此，用户不必担心因“入侵”自己的设备而被起诉的问题了。包括汽车、个人电脑在内，用户可以对自己的各个电子设备进行安全性研究，甚至对其软件进行探查安全漏洞之类的研究。此前，DMCA法案禁止普通用户进行这类研究。废止之后，随着大众对设备的研究的深入，很多安全漏洞的威胁也就随之消除了。但这并不意味着黑客可以为所欲为，根据限制，研究者如果在未被允许的情况下引入别人的计算机，仍可能面临着起诉或者是控告，也就是说，研究者只能研究自己的设备，任意侵入他人的设备还是属于非法的。 社交网络依赖症 计算机科学家David Saracino 同时在写书和经营博客，但他并没有社交网络账号，在他看来，应该推出社交媒体。因为他对自己的事业是有害的。有反对这认为：我们不因该放弃曝光自己的机会。但是在David Saracino认为在这个社交媒体中我们每天都接受微量的刺激，在着中国情况下一旦我们形成习惯化，我们将会很难集中精神。长时间没有接受刺激的大脑将会拒绝集中精神。 苹果停止无线路由的开发，解散团队 &nbsp;&nbsp;&nbsp;&nbsp;古尔曼在文中写道：“在苹果从去年开始就削掉了无线路由器团队，把工程师分散到其他诸如Apple TV那样的产品研发小组中去，但提供内幕的人士要求不要透露其姓名，因为这个决定还没公布。” 目前苹果推出了三款无线路由器——AirPort Express(售价99美元)、AirPort Extreme(售价199美元)以及AirPort Time Capsule(售价299美元)，但这些路由器从2013年就没有升级过，而且销量惨淡。 &nbsp;&nbsp;&nbsp;&nbsp;放弃路由器的产品线意味着将削弱苹果产品体系的统一性，因为AirPort路由器的功能，像无线音乐播放等，都需要iPhone或Mac电脑等设备的配合，另外，此举恰逢对手谷歌发布其无线路由器Google Wifi。 Stack Overflow ： 社区盈利不应以伤害用户体验为代价 &nbsp;&nbsp;&nbsp;&nbsp;09年开始用115，当时体验很差劲、不能断电续传，也没有共享资格，速度很慢，也没什么实验室，没客户端，经常收到为用户着想的公告，等等等等 &nbsp;&nbsp;&nbsp;&nbsp;刚开始时有一个很吸引人的就是积分容易些能得很多空间。后来在我在连续登陆几天就可以得到10G空间的时候115停止了积分等级制度，让我生气很久，把临时空间改成了永久的稍微平衡了一点点。到后来的雨露，再到现在每天的摇啊摇，但是真没劲，如果每次摇都能得到100M以上到时挺好的，一天一次也好。再者也可以是连续登陆的天数越多得到的空间越多，最起码我会为了能得到一些对我重要的积分而每天登陆一个网站。我已经有100G了每天30M、50M的没吸引。像新浪微盘一样冷不丁的给个400M、900M的也很有吸引力。&nbsp;&nbsp;&nbsp;&nbsp;以前觉得115能发展很好,所以一直用也推荐朋友们用.我现在依然觉得就存东西而言115依然很好用，就是现在圈子好友等好像现在发展的重点。一开始很想要的共享资格,后来有了,现在又被剥夺了。最让人讨厌的是进入115,在我的界面里开始有广告了，如果哪天我离开115一定是因为界面里那些该死的和网盘功能无用的广告,我讨厌太混乱。115需要盈利，需要发展，但是不能以牺牲用户的体验为代价。可以有广告但是最好是别的地方.&nbsp;&nbsp;&nbsp;&nbsp;我希望以后登陆了115能像现在的登陆界面一样,把网盘放在首位、简洁、没有广告、需要的东西一目了然。 下一个 Linux？Minoca OS 开源 Monica OS 是一个全新开发的通用型系统。两名开发者Evan和Chris认为，主要的操作系统已有超过25年历史。而这25年，计算机行业变化巨大，硬件根式发生了很大的改变。如果能从头开始，可以在操作系统方面创造一些更有趣、更独特的内容，也会涉及一些25年之前了解不多的领域。他们希望创造一个代码更少，问题更少的操作系统。系统开源后，将会围绕这个操作系统建立起一个用户和开发者组成的社区。 以上内容摘自CSDN12期","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"myeclipse源码相关操作","date":"2017-01-09T12:38:00.000Z","path":"zxh/20170109.html","text":"做web开发经常要看别人的jar里的源码才能搞懂别人的想法 做web开发经常要看别人的jar里的源码才能搞懂别人的想法，但是源码有的时候需要单独下载很麻烦，甚至有的新的jar根本就是没有源码的，那么我们能不能自己制作源码呢。 从jar中提取源码 说白了，提取源码就是反编译的过程jd-gui就是一个很好的工具。 反编译这里点到为止，然后在这个工具的Help–&gt;Preference中 包sources saving中的两个√取消掉，确定之后我们点击File–&gt;save all sources myeclipse引用 按住Ctrl+鼠标点击图上的detect函数，点击第二个进入如下页面 结束myeclipse更换源码 有的时候我们jar可以引入的N版本的，但是我们导入的源码是M版本的，这就导致有的方法不一致了，但是这个时候想换有的人就不知道如何更换了。解决办法是 右击项目进入Java Build Path 比如说我要更改第一个(antiporn-sdk.jar的源码)，我们点击一下打开这个jar的折叠窗 到这里我们就清除了之前的源码记录了，然后你可以重复你熟悉的导入源码的方式，也可以重复上面三张图的方式重新引入一个源码，为什么上面我要将源码删掉在导入呢，因为有的时候源码都在同一个位置，如果是同一位置，myeclipse不会每次都去更新的，这就导致源码无法替换了。所以按照上面的保险一点。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"来自一个程序员内心深处的心声","date":"2017-01-08T03:31:00.000Z","path":"zxh/20170108.html","text":"来自一个程序员内心深处的心声 来自一个程序员内心深处的心声 我适合做程序员吗？ 程序员该怎么学习 程序员的未来 我的规划 我的偶像 我适合做程序员吗？ &nbsp;&nbsp;大学时期我就经常在想，程序员日常是怎么样的，我这样的人适合做程序员吗，一直到现在我还在时不时的思索。因为我不安于现状，总是想去创新。放眼望去天国的程序员们，我觉得程序员就应该去创新，不能太守旧，因为物联网是飞速发展的。其实物联网中的代码没有对与错之分，只有合适不合适的区别。只有在合适的地方的合适的时间产生的合适的效果才是我们心中的正确的代码。所以我们现在的代码可能十年后就不适合那时候的需求了。在之前我曾发表一篇和程序员有关的文章里面剖析了程序员的内质。我觉得我就是符合哪里的程序员的品质。真正的程序员就就应该与时俱进，不断地学习，不断的进步。那么，你可能会说到底哪些程序员是不称职的程序员呢。有这么一种人平时工作认真，但是贬低别人的代码指出所有的不好。跟别人也说很多很前卫的技术，夸耀之前项目经验。大家觉得这种程序员是合格的程序眼吗。至于是与不是100个人心中有N个答案。这里我就不抛砖引玉了。 程序员该怎么学习 那么作为程序员的你，有么有这个时候，我们程序员到底怎么去学习，现在网上的资料铺天盖地到底如何能快速找到对自己有效的文章呢或者是学习的网站呢。其实现在物联网虽然有些论坛里都是一些无聊的人在别的网站转载一些自己都不懂的东西，这样的搬运造成后面的人就无法学习了。但是有很多东西都是国内甚至国外大神总结的。作为程序员我们要懂得如何在网上过滤文章，让我们自动的过滤掉对自己没用的东西。当然了这只是曲线救国。最有效的学习就是看官网，虽然官网大部分都是英文文档，但是作为程序员我们必须要让自己看英文文档，因为英文文档对自己是很有帮助的。毕竟是人家第一手资料。那么难道对我们这些英文不好的人就注定无法快速学习了吗。当然也不是在这里我可以给大家推荐一个国内学习教程 菜鸟教程，这里面涉及了很多知识的基础学习，可以这样说所以的编程只要在这里有的，你都可以通过在这里学会基础的东西。对于一些javaweb框架的学习呢，我们只能在用的时候遇到社么问题就去Google上搜索对应的问题并解决，这也是我们程序员必备的学习手段。学习也是我们程序员的一大能力。 程序员的未来 之前有一篇文章我说了，程序员并不是别人说的那样，四十以后就写不动代码了。我的观点就是四十岁之后我照样能写代码。现在有的程序员整天就是机器，每天准时上下班，及时完成任务。但是作为程序员我们真的该仅仅的安安露露吗。我并不这么觉得。我觉得我们得看向未来。我们程序员其实压力还是很大的，现在物联网正在向自动化迈进。看看近几年的机器人就知道，现在的机器人已经开始慢慢的迈进人们的生活中。在编程中我们也有些自动化处理代码的需求了，所以以后很有可能就是代码自动的按需求生成并且自动的发布项目。如果真的到那一天，我们70%的程序员估计就面临的失业了。在这里我为那些安安露露的程序员们默哀。所以我们的不断学习。不断的去涉及学习其他领域。夸大的说为了以后的自动化编程做准备。 我的规划 出来工作前，就看到有些人在给自己排计划。当时可能是怕自己实现不了，当时我一直不敢给自己规划人生。工作半年之后我觉得规划并不是计划，并不是一定要实现，只是给自己定一个目标。给自己树立一个导航。下面给自己简单罗列一些规划 2017 - 完成毕业设计 下半年和同学开发项目2018 - 系统学习整理java只是 下半年学习python并完成项目练习2019 - 学习C++2020 - 整理自己java风格进行封装2021 - 系统架构师 总结一下就是利用这五年的时间除了以上的东西，还不断的研究javaweb底层的实现。五年之后想架构师努力。 我的偶像","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"编程乐趣--汉字转拼音","date":"2017-01-06T11:57:00.000Z","path":"zxh/20170106.html","text":"各个国家语言上差异较大，本世纪英语特别的流行 各个国家语言上差异较大，本世纪英语特别的流行，至少在程序员上编程就是属于外国的。是英文编写的。那么我们的汉字就是一个特例了。下面说说汉字是如何转拼音的。 jar包准备点我下载pinyin4j.jar 如果你是maven那就方便了。 &lt;!-- 汉字转拼音jar --&gt; &lt;dependency&gt; &lt;groupId&gt;com.belerweb&lt;/groupId&gt; &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/dependency&gt; 使用 jar包准备好了，我们就开始使用吧，这个jar都分装好了，我们只需要简单的调用就行。 第一步：定义汉字拼音的输出格式 HanyuPinyinOutputFormat hypy = new HanyuPinyinOutputFormat(); 上面定义的hypy这个类就是指定拼音的格式。作为中国人我们知道拼音就是字母拼接在一起的。还有就是声调，所以格式就是制定字母显示和声调的。 通过看HanYuPinYinOutputForMat这个类的源码我们可以看到输出格式有三个属性，而且这三个属性的默认值都是设置好的 /** * Restore default variable values for this class * * Default values are listed below: * * &lt;p&gt; * HanyuPinyinVCharType := WITH_U_AND_COLON &lt;br&gt; * HanyuPinyinCaseType := LOWERCASE &lt;br&gt; * HanyuPinyinToneType := WITH_TONE_NUMBER &lt;br&gt; */ public void restoreDefault() { vCharType = HanyuPinyinVCharType.WITH_U_AND_COLON; caseType = HanyuPinyinCaseType.LOWERCASE; toneType = HanyuPinyinToneType.WITH_TONE_NUMBER; } 上面源码的意思就是，如果我们不设置，那么这三个属性默认就是上面的情况，那么这些格式都是对应拼音的那种格式呢，下面继续往下走。 LOWERCASE Combination WITH_U_AND_COLON WITH_V WITH_U_UNICODE WITH_TONE_NUMBER lu:3 lv3 lü3 WITHOUT_TONE lu: lv lü WITH_TONE_MARK throw exception throw exception lǚ UPPERCASE Combination WITH_U_AND_COLON WITH_V WITH_U_UNICODE WITH_TONE_NUMBER LU:3 LV3 LÜ3 WITHOUT_TONE LU: LV LÜ WITH_TONE_MARK throw exception throw exception LǙ 看到上面两张表格没，就是hypy格式中三种属性的结合对应的汉语拼音的显示。在这里我还是解释一下吧。 * @see HanyuPinyinVCharType * @see HanyuPinyinCaseType * @see HanyuPinyinToneType hypy.setCaseType(HanyuPinyinCaseType.LOWERCASE); hypy.setToneType(HanyuPinyinToneType.WITH_TONE_NUMBER); hypy.setVCharType(HanyuPinyinVCharType.WITH_V); 首先setCaseType是指定我们输出的拼音的大小写，这个就不用多讲了。 setToneType是指定我们带声调的拼音的显示。这里有三种选择 HanyuPinyinToneType.WITH_TONE_NUMBER 通过数字标注声调 zhang1 zhang2 zhang3 zhang4 分别是一二三四声、-HanyuPinyinToneType.WITHOUT_TONE：不带声调，就是没有声调HanyuPinyinToneType.WITH_TONE_MARK：通过符号标注，和我们平时书写一样，像u 和 ü 就通过符号区别 setVCharType：WITH_U_AND_COLON + WITH_V + WITH_U_UNICODE 就是处理u ü 的。 输出 在上面一步 我们已经将格式处理好了，这里我们开始处理输出 PinyinHelper.toHanyuPinyinStringArray(&quot;张新华&quot;.charAt(2), hypy)[0] 就这样拼音就出来了，这个就返回出来我们汉字的拼音了。对于使用者到这里就结束了。但是出于好奇我们继续往下看看。 PinyinHelper这个单列中toHanyuPinyinStringArray static public String[] toHanyuPinyinStringArray(char ch, HanyuPinyinOutputFormat outputFormat) throws BadHanyuPinyinOutputFormatCombination { return getFormattedHanyuPinyinStringArray(ch, outputFormat); } 意思就是获取格式化后的ch的拼音 而在getFormtedHanyuPinyinStringArray方法里首先是获取未格式化的拼音，然后在对拼音格式化。 String[] pinyinStrArray = getUnformattedHanyuPinyinStringArray(ch); 如何获取未格式化的拼音是重点我们就侧重这部分 private static String[] getUnformattedHanyuPinyinStringArray(char ch) { return ChineseToPinyinResource.getInstance().getHanyuPinyinStringArray(ch); } 在上面我们能够看到ChineseToPinyinResource类，在这个类中我们可以找到他的初始化数据，这里我们可以理解为web项目中的数据库 /** * Initialize a hash-table contains &lt;Unicode, HanyuPinyin&gt; pairs */ private void initializeResource() { try { final String resourceName = &quot;/pinyindb/unicode_to_hanyu_pinyin.txt&quot;; setUnicodeToHanyuPinyinTable(new Properties()); getUnicodeToHanyuPinyinTable().load(ResourceHelper.getResourceInputStream(resourceName)); } catch (FileNotFoundException ex) { ex.printStackTrace(); } catch (IOException ex) { ex.printStackTrace(); } } 上面的代码指出了这个所谓的额数据库就是unicode_to_hanyu_pinyin.txt 这里面究竟是什么呢，打开你会发现其实就是拼音和Unicode的对应关系。因为在我们获取拼音的时候是首先获取他的Unicode码的getHanyuPinyinRecordFromChar(ch);，然后通过Unicode码去unicode_to_hanyu_pinyin.txt找对应关系的，至于其他文件是处理其他的语种的，时间能力有限，暂不深究！ 获取未格式化的拼音之后就是处理格式了， PinyinFormatter.formatHanyuPinyin 到这里就是根据上面的三个值进行格式化处理了，这个就是格式的问题，本文不深究。 不断学习！不断进步！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"MyEclipse下安装FreeMark插件","date":"2017-01-05T12:35:00.000Z","path":"zxh/20170105.html","text":"现在大多人人喜欢用FreeMark模板。 现在大多人人喜欢用FreeMark模板。但是这个模板在myeclipse或者是eclipse下却是不能只能提示，一大堆只是没有颜色区分的显示在哪里。万能天国总是有办法。 点我去官网下载(比较慢)我的CSDN资源下载(速度快 推荐 已配置好) 配置 如果你选择的是我的CSDN 资源下载直接跳过，这里讲的是从官网下载的，我CSDN里是配置好的，在我的CSDN里下载直接将文件解压在解压文件中有hudson.freemarker_ide_0.9.14，只需要将hudson.freemarker_ide_0.9.14文件夹复制到myeclipse或者eclipse的pluginss里就行了。 在官网下载解压如下 官网里freemarker.jar版本太低，去网上下载高点的版本替换这里的。然后修改META_INF文件夹下的MANIFEST.MF文件里对应的这个jar包的版本 复制在官网上下载需要经过第一步，在我的CSDN下载直接到这步就可以了。 重启Eclipse或者myeclipse重启之后再打开Window–&gt;preferens左侧树中多了Freemarker Editor说明我们成功了。 在General –&gt; Editors –&gt; File Associator中我们可以看到ftl文件的编辑器就是Freemarker Editor这个编辑器了。如果不是我们可以强行的指定这个编辑器。下面看看用了这个编辑器编写的ftl文件的效果吧 有感： 程序员不断学习不断进步。才能享受高等的生活！！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"java web 加载Spring --web.xml 篇","date":"2016-12-25T09:40:00.000Z","path":"zxh/20161225.html","text":"spring是目前最流行的框架。今天谈谈对spring的认识 spring是目前最流行的框架。今天谈谈对spring的认识 起步 javaweb中我们首先会遇到的配置文件就是web.xml，这是javaweb为我们封装的逻辑，不在今天的研究中。略过，下面是一个标准的xml配置文件，我们需要的东西就在下面就行添加就行了。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;3.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot;&gt; &lt;/web-app&gt; 那么xml文件中到底有哪些标签呢，下面说说几种比较常见的标签。重要标签加载顺序 context-param&gt;listener&gt;filter&gt;servlet 1、&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;display-name 是标识项目的名称，这个不是很常用，可有可无的，或者说不需要我们去在意的东西。2、&lt;context-param&gt; &lt;param-name&gt;webAppRootKey&lt;/param-name&gt; &lt;param-value&gt;60000&lt;/param-value&gt; &lt;/context-param&gt; context-param 是web.xml首先加载的标签，其下子标签有param-name和param-value.此所设定的参数,在JSP网页中可以使用下列方法来取得:${initParam.webAppRootKey} 若在Servlet可以使用下列方法来获得: String param_name=getServletContext().getInitParamter(“webAppRootKey”); 3、listener &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; listenter在项目开始的时候就注入进来，尽在context-param之后，所以正常我们将spring配置在listener 中，这样方法spring 初始化相关的bean。 4、filter &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; filter起到一个过滤的作用，在servlet执行前后，像上面的配置就是在过滤servlet前将编码转换UTF-8,filter-mapping 则是将filter和url路径进行映射。其中init-param则是将初始化需要的参数传入到filter-class中从而进行初始化。filter和filter-mapping中的name必须是相同的，才能起到映射的作用，而filter-mapping 中的url-pattern则是匹配请求路径的。上面‘/*’表示过滤所有请求的servlet,如果写成‘/zxh’,则过滤 http://localhost:8080/项目名/zxh 这个请求。 5、servlet &lt;servlet&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定spring mvc配置文件位置 不指定使用默认情况 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- ServLet 匹配映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.zxh&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; servlet和filter类似，需要先指定servlet对应的class类，然后将这个类和utl路径请求地址进行映射。这里不多说了。 以上就是web.xml文件中出现最多的几个标签。其他的比如欢迎页 &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 错误页 &lt;!-- 后台程序异常错误跳转页面 --&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; &lt;location&gt;/views/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- 500跳转页面--&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/views/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- 404跳转页面 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/views/404.jsp&lt;/location&gt; &lt;/error-page&gt; spring加载 通过上面的了解，我们可以看出spring核心配置文件就是listener那块。在监听之前我们已经通过context-param将spring配置文件传到上下文中了(application)。下面我们就来看看spring是如何工作的吧 第一步：点开listener源码，我们发现他有下面几个方法。和继承的关系。我们发现他实现了ContextLoaderListener这个接口，这个接口在参数设置好之后自动执行contextInitialized方法的。 那么我们来看看contextInitialized方法 public WebApplicationContext initWebApplicationContext(ServletContext servletContext) { if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) { throw new IllegalStateException( &quot;Cannot initialize context because there is already a root application context present - &quot; + &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;); } Log logger = LogFactory.getLog(ContextLoader.class); servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;); if (logger.isInfoEnabled()) { logger.info(&quot;Root WebApplicationContext: initialization started&quot;); } long startTime = System.currentTimeMillis(); try { // Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown. if (this.context == null) { this.context = createWebApplicationContext(servletContext); } if (this.context instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) { // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any. ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); } configureAndRefreshWebApplicationContext(cwac, servletContext); } } servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) { currentContext = this.context; } else if (ccl != null) { currentContextPerThread.put(ccl, this.context); } if (logger.isDebugEnabled()) { logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;); } if (logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;); } return this.context; } catch (RuntimeException ex) { logger.error(&quot;Context initialization failed&quot;, ex); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex); throw ex; } catch (Error err) { logger.error(&quot;Context initialization failed&quot;, err); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err); throw err; } } 仔细研究官方解释，就是在这里初始化application，这里会用到contextClass+contextConfigLocation两个参数，如果contextClass在context-param提供了，我们就会根据这一个class去初始化application，很显然我们正常配置都没有配这个，而是配置了后者，配置了后者就会去根据contextConfigLocation中提供的配置文件去解析然后创建相关的bean和application操作，这个方法的最后会执行configureAndRefreshWebApplicationContext方法。这个方法就是在根据contextConfigLocation提供的配置文件中创建相关的bean。 springMVC 加载springMVC其实和spring是一样的，但是他不用再程序开始时访问 &lt;servlet&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定spring mvc配置文件位置 不指定使用默认情况 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- ServLet 匹配映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.zxh&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 看DispatcherServlet源码中对contextConfigLocation参数的解释 上面明确指出我们这个参数给XmlWebApplicationContext类的，我们在进入XmlWebApplicationContext类看看究竟。这样我们很容易理解为什么springmvc默认的配置文件会在WEB-INF/application.xml中的吧。 在dispatcherservlet中有一个初始化方法，这里就初始化配置中一些东西，比如说文件上传适配器的配置等等。 protected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); } 总结spring+springmvc在配置中主要就是上面的两个配置，当然spring的强大不是我们一两天能够研究来的，我上面只是简单的研究讨论了一下。不喜勿喷！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Redis集群与spring的整合","date":"2016-12-21T04:45:00.000Z","path":"zxh/20161221.html","text":"上一篇详细的赘述了Redis的curd操作及集群的搭建 上一篇详细的赘述了Redis的curd操作及集群的搭建。下面我们开始将他整合到我们实际的项目中去。我的项目采用的是标准的ssm框架，ssm框架这里不说，直接开始整合。 首先在maven管理中将我们的jar包引入 &lt;!--1.7.2 开始支持Redis 集群--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.7.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis 缓存Jar --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--下面就是spring的maven坐标了，这里就不写了，读者自己引入--&gt; 在spring配置文件中我们可以进行配置Redis，但是为了将Redis分离容易修改我将它卸载另外一个xml文件中，只要在spring配置文件中引入这个Redis配置文件就行了。 下面所有的记录都是在Redis这个配置文件进行操作的。 Redis连接池配置 这里只是将设置连接池的一些基本属性，比如说最大连接数，连接前属性判断等 &lt;bean id=&quot;redisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;${redis.maxTotal}&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt; &lt;/bean&gt; maxIdle：控制一个pool最多有多少个状态为idle的jedis实例； 在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的 maxWaitMillis : 表示当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛出JedisConnectionException； Redis集群配置这里我们就是将我们上一篇开启的Redis服务引入到项目中来。clusterNodes就是我们一个一个的Redis服务。 &lt;!-- Redis集群配置 --&gt; &lt;bean id=&quot;redisClusterConfig&quot; class=&quot;org.springframework.data.redis.connection.RedisClusterConfiguration&quot;&gt; &lt;property name=&quot;maxRedirects&quot; value=&quot;3&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clusterNodes&quot;&gt; &lt;set&gt; &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;127.0.0.1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;7000&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;127.0.0.1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;127.0.0.1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; Redis连接工厂我们将上面的Redis服务节点和连接池引入到工厂中，有工程去生产一个可用的jedis提供我们进行缓存的CURD操作！！ &lt;!-- ReDis连接工厂 --&gt; &lt;bean id=&quot;redis4CacheConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt; &lt;constructor-arg name=&quot;clusterConfig&quot; ref=&quot;redisClusterConfig&quot; /&gt; &lt;property name=&quot;timeout&quot; value=&quot;${redis.timeout}&quot; /&gt; &lt;property name=&quot;poolConfig&quot; ref=&quot;redisPoolConfig&quot; /&gt; &lt;/bean&gt; Redis模板提供了jedis进行操作我们就要放道模板里面给我们调用！。 &lt;!-- 存储序列化 --&gt; &lt;bean name=&quot;stringRedisSerializer&quot; class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt; &lt;!-- 集群Resis使用模板 --&gt; &lt;bean id=&quot;clusterRedisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;redis4CacheConnectionFactory&quot; /&gt; &lt;property name=&quot;keySerializer&quot; ref=&quot;stringRedisSerializer&quot; /&gt; &lt;property name=&quot;hashKeySerializer&quot; ref=&quot;stringRedisSerializer&quot; /&gt; &lt;property name=&quot;valueSerializer&quot; ref=&quot;stringRedisSerializer&quot; /&gt; &lt;property name=&quot;hashValueSerializer&quot; ref=&quot;stringRedisSerializer&quot; /&gt; &lt;/bean&gt; 项目调用在配置文件中都已经将jedis配置好了，我们只需要通过这个模板就可以对Redis进行CURD操作了。下面是个简单的列子 clusterRedisTemplate.execute(new RedisCallback&lt;Long&gt;() { public Long doInRedis(RedisConnection connection) throws DataAccessException { byte[] keyb = key.getBytes(); byte[] valueb = toByteArray(value); // 判断当前值是否已经存在 if (connection.exists(keyb)) { // 删除原数据 connection.del(keyb); } connection.set(keyb, valueb); return 1L; } }); 源码探究竟在RedisClusterConfiguration类中我们传入的Redis服务node，我们设置的是property然后该类中就开始执行下面代码 然后我们在工厂中传入这些节点， 这个工厂给我提供了一个afterproperties方法，意思就是在这些参数设置完成之后执行的一个方法。 在这里我们可以看见一个creatPool的方法，这个就是去连接池里创建连接 Bug解决上面的部署 会出现一个问题，就是在项目中，每次初始化时会重连接池中选择一个可用的Redis服务连接，当这个Redis服务宕机后我们的项目还会继续连接这个Redis服务，我们只能从新启动项目，项目才会从新从连接池中选择新的Redis服务。 解决办法 我在每次操作Redis时都去重构连接池，这样就保证我每次都会去连接池找一个正真可用的Redis服务。 解决就是将RedisNode注入到项目中，每次都执行我们上次看到的creatPool方法 /** Redis模板注入 */ @Resource private RedisClusterConfiguration redisClusterConfig; private JedisConnectionFactory redis4CacheConnectionFactory; @Resource private RedisTemplate&lt;String, Object&gt; clusterRedisTemplate; //重构连接池 private void init(){ redis4CacheConnectionFactory=new JedisConnectionFactory(redisClusterConfig); redis4CacheConnectionFactory.afterPropertiesSet(); clusterRedisTemplate.setConnectionFactory(redis4CacheConnectionFactory); } 这样又出现问题了，每次都初始化连接池，这在连接池上很费性能，暂时没有解决办法，但是我初步想通过redis sentinel 来检测Redis集群中的Redis服务。当Redis宕机后通过sentinel 提供的API来通知项目重新去构建连接池，重新连接新Redis服务","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Redis简单梳理及集群配置","date":"2016-12-20T08:54:00.000Z","path":"zxh/20161220.html","text":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 Redis简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下几个特点： • Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 • Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 • Redis支持数据的备份，即master-slave模式的数据备份。• 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。• 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。• 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。• 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis安装 点我下载 打开一个 cmd 窗口 使用cd命令切换目录到 redis 运行 redis-server.exe redis.windows.conf到了后面我们知道启动Redis服务是通过redis-cli redis.conf这个命令的到这里我们就成功的启动了一个Redis服务了。默认是没有密码的。这时候我们只需要ip+port就可以访问到这个redis了，从而就可以对这个Redis就行crud操作了。 这个时候另外打开一个新的cmd窗口，运行redis-cli.exe -h 127.0.0.1 -p 6379下面我们就演示一下运行流程 首先 set mykey abc 这是设置然后我们就开始读取我们设置的key 运行 get mykey 获取abc Redis 配置 Redis 的配置在redis.conf配置文件里。我们可以通过config命令获取信息1、 获取config_setting_name 值 Config get config_setting_name2、 获取日志级别 config get loglevel3、 获取所有 config get * 既然我们可以获取就应该可以修改，我们可以编辑redis.conf或者通过config set命令修改配置 Redis数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。有意思的是redis的string包含所有二进制数据，包括图片等。String一个键最大存储512MB 数据 数据类型获取设置 String Get Set Hash Hgetall Hmset List Lrange Lpush Set Smembers Sadd zset ZrangebyscoreZadd 注意：在这里变量不能重复，string a ,那么不能再hash a 了。还有zset和set都是不能元素重复的。Set里添加的元素重复是不处理的。但是zset中添加重复元素会覆盖的。Zset中元素不能重复但是score是可以覆盖的 集群配置前期准备 首先去Github下载最新的Redis， 值得解释的是我下载的windows版本，redis.conf 在这里是redis.windows.conf。有了这个我们只需要在redis.conf文件里修改端口然后通过redis-cli redis.conf 这个命令启动了。在这里给大家一个小建议将下面代码贴在bat文件中，就可以避免每次输入命令了， @echo off redis-server.exe redis.conf @pause 然后将bat文件名修改成自己喜欢的名字就行了，以后我们在点击这个就可以执行开启Redis服务的功能。我都是讲文件名和端口号同意起来的，这样有助于后面集群。 到这里我们就创建了一个Redis服务了。集群就是很多个这样的Redis服务在一起工作。所以我们只要复制我们配置好的这个Redis服务。并把redis.conf里面的端口号改成不一样的，吧bat名字也改成对应端口。 ruby环境安装 因为redis集群是通过Redis cluster来实现的，redis-cluster安装前需要安装ruby环境，搭建集群需要使用到官方提供的ruby脚本。需要安装ruby的环境。 安装RubyGems下载下来是一个压缩包，解压运行里面的 setup.rb 安装 rubyGems删除默认的官方源gem sources -r https://rubygems.org/ 添加淘宝源gem sources -a https://ruby.taobao.org/查看当前源gem sources -l 集群开启(使用Redis - cluster )1.按照上面所说的配置好各个实例，主要是改端口号，运行 7000.bat- 7005.bat脚本启动六个redis实例2.另开一个cmd窗口到redis文件夹下运行 redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 我们选择yes 就是同意Redis-cluster对我开启的这六个Redis服务进行随机分片了。其中是三主三从。根据实际需求我们可以设置N主M从，但是通过Redis-cluster必须至少要启动六个服务器。 replicas -1 意思是为我们的集群中每个主节点都配置一个从节点到这里我们的集群就已经配置完成了，至于怎么在Java中使用呢，Redis也提供了很好接口给我们。 Java Redis 整合 Redis给我们提供了jedis jar包，我们引入这个jar包执行如下操作就可以连接到指定的Redis服务上了。Redis 默认没有密码，没有密码jedis.auth这句就不写或者写空都可以的 //连接redis服务器，192.168.0.100:6379 jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); //权限认证 jedis.auth(&quot;RedisZxh&quot;);","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"PDF.js 详情解说","date":"2016-12-12T08:29:00.000Z","path":"zxh/20161212.html","text":"pdf.js资源下载 pdf.js资源下载点我下载 自定义默认加载的pdf资源 在web/view.js中我们可以通过DEFAULT_URL设置默认加载的pdf。通过上面代码我们也可以看出来可以通过后缀名来指定加载的pdf。如： http://mozilla.github.com/pdf.js/web/viewer.html?file=compressed.tracemonkey-pldi-09.pdf. 这样我们代码获取到file字段就会自动覆盖我们默认的pdf。 加载其他服务器上的pdf(远程加载) 这个功能是可以实现的，但是并不是默认开启的。pdf.js和其他的JavaScript运行机制是一样的。所以无法与request请求交互。但是我们还是可以通过在我们的服务商使用cors或者设置代理向pdf.js提供pdf预览的。 支持的浏览器 插件在火狐35版本及以上是不支持的。pdf.js是火狐自19版本的一部分。扩展名是由开发商和主要用于将使用最新版本的pdf.js图书馆一个年长的Firefox版本。用户应该卸载扩展，恢复pdfjs.disabled配置设置和设置选项-&gt;应用选择PDF文件的内部浏览器继续查看PDF与pdf.js Firefox。如何开始一个pdf.js项目首先我们得准备返回值和安装环境。就是pdf.js;其次我们得属性pdf.js内部运行机制；最后提交请求给pdf添加注释到目前为止，pdf.js还没有提供修改pdf的api,pdf.js主要是让我们能够预览。所以加注释目前无法实现。精简版pdf.jsgithub上 gulp minified可以下载到精简版pdf.js没有正确加载或报错吗答案是会报错。这些问题是用来跟踪用户使用状态的。我们可以尝试通过问题追踪到问题根源pdf已损坏，pdf.js还会加载吗会的，pdf.js会尝试修复并显示pdf文档的优化pdf.jspdf.js加载速度取决于每页的容量。至于页数并不影响我们的加载速度。下面我可以给大家几点使用pdf.js优化的建议1、避免使用高分辨率的图像，150 dpi的分辨率扫描的图像应该足够的屏幕，尤其是低动力装置；2、尝试使用JPEG的RGB颜色空间的彩色图像编码照片；3、避免使用高性能的效果4、避免使用PDF生成器（或不创造内容），产生无效的PDF输出（例如LibreOffice创建一个向量元素/图片不了解小很多的图像）5、如果有这样的设置，使用网站优化的PDF输出线性化；6、固定或不产生损坏的PDF格式不符合规范的pdf32000 小案列 &lt;li&gt;&lt;a href=&quot;viewer.html?name=a.pdf&quot; target=&quot;pdfContainer&quot; onclick=&quot;showPdf(true)&quot;&gt;0001_pdf&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;viewer.html?name=b.pdf&quot; target=&quot;pdfContainer&quot; onclick=&quot;showPdf(true)&quot;&gt;0002_pdf&lt;/a&gt;&lt;/li&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showPdf(isShow){ var state = &quot;&quot;; if(isShow){ state = &quot;block&quot;; }else{ state = &quot;none&quot;; } var pop = document.getElementById(&quot;pop&quot;); pop.style.display = state; var lightbox = document.getElementById(&quot;lightbox&quot;); lightbox.style.display = state; } function close(){ showPdf(false); } &lt;/script&gt; 遗留问题 研究半天没有解决在html中的pdf.js跨域问题。网上教程都是指出php解决方法、在html上以后有机会再更新！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"基于SMS短信平台给手机发送短信","date":"2016-12-09T08:19:00.000Z","path":"zxh/20161209.html","text":"JAVA发送手机短信,我知道的有三种方式，恰逢项目需求，自己整理了基于SMS的短信发送，其他两种这里就说说一下 JAVA发送手机短信,我知道的有三种方式，恰逢项目需求，自己整理了基于SMS的短信发送，其他两种这里就说说一下 使用webservice接口发送手机短信,这个可以使用sina提供的webservice进行发送,但是需要进行注册 使用短信mao的方式进行短信的发送,这种方式应该是比较的常用,前提是需要购买硬件设备。 使用中国网建提供的SMS短信平台（申请账号地址：http://sms.webchinese.cn/default.shtml） 新建短信接口处理类 属性：服务器地址(SERVER_IP)+服务器端口(SERVER_PORT)+主账号名称(ACCOUNT_SID)+主账号令牌(ACCOUNT_TOKEN)+应用ID(App_ID) 短信发送方法： 1、首先我们发送短信前需要对新建类的属性进行验证，这些都是发送短信必须的参数。这里我封装验证方法为accountValidate() 2、封装这个短信的方法也需要三个必须的参数(to,templateId,datas)，其中datas是一个数组就是我们发送到手机上的内容。to代表的是手机号！templateId是我采用的模板，这里我提供了三种模板，这个后面有时间在详细赘述！ 3、把需要的数据封装成两种格式的文本json/xml.最后我们只用将这两种方式的文本内容转换成字符串就可以发送到网络平台了。 LoggerUtil.info(&quot;sendTemplateSMS Request body = &quot; + requsetbody); BasicHttpEntity requestBody = new BasicHttpEntity(); requestBody.setContent(new ByteArrayInputStream(requsetbody.getBytes(&quot;UTF-8&quot;))); requestBody.setContentLength(requsetbody.getBytes(&quot;UTF-8&quot;).length); httppost.setEntity(requestBody); HttpResponse response = httpclient.execute(httppost); 4、到这里就发送成功了。但是由于短信平台的限制我们短信每天发送条数有限","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"linux装OpenOffice后传---中文乱码的解决","date":"2016-12-08T02:56:00.000Z","path":"zxh/20161208.html","text":"上一篇的博客已经详细的介绍了linux系统上如何安装OpenOffice 上一篇的博客已经详细的介绍了linux系统上如何安装OpenOffice，安装之后使用发现转换的pdf出现中文乱码。后来发现是linux上没有中文对应的那个字体。 字体准备 在windows上的位置 具体用什么字体，那就得看你的linux系统上缺什么字体了，如果你不确定就直接把font文件里的所有字体全都拷贝到linux系统上。怎么拷贝上篇文章我是通过xshell传送的，这里不赘述了。 linux操作 将字体拷贝到linux系统下 /usr/share/fonts.之后我们执行三步骤 mkfontscale mkfontdir fc-cache 之后乱码解决！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"NodeJs小试牛刀--聊天室搭建","date":"2016-12-08T02:29:00.000Z","path":"zxh/20161208.html","text":"最近研究聊天室功能，准备用nodejs实现。下面是自己的尝试！！ 最近研究聊天室功能，准备用nodejs实现。下面是自己的尝试！！ nodejs的安装这里就不详细赘述了。 程序创建 引入required模块 var express = require(&#39;express&#39;); var app = express(); var http = require(&#39;http&#39;).Server(app); 创建监听端口 http.listen(8000, function() { console.log(&#39;Server running at http://127.0.0.1:8000/&#39;); }); 以上代码我们完成了一个可以工作的 HTTP 服务器。使用 node 命令执行以上的代码：（*就是我们上面代码保存的文件名） node ****.js express模块var express = require(&#39;express&#39;); var app = express(); var http = require(&#39;http&#39;).Server(app); http.listen(8000, function() { console.log(&#39;Server running at http://127.0.0.1:8000/&#39;); }); 这样我们的8000端口就开启这个服务了。下面我们通过socket.io模块实现服务于客户端的交互。 socket.io模块 首先io.sockets.on函数接受字符串”connection”作为客户端发起连接的事件，当连接成功后，调用带有socket参数的回调函数。我们在使用socket.IO的时候，基本上都在这个回调函数里面处理用户的请求。 socket中最重要的两个方法是emit和on方法。说白了就是发送和接收的方法。在服务端socket.emit就是想客户端发送数据，socket.on就是接收客户端返回的数据。在客户端恰恰相反。 io.on(&#39;connection&#39;, function(socket) {} connect作为客户端发起连接的事件。当连接成功后开始调用带有socket的回调函数。 this.socket = io.connect(&#39;ws://127.0.0.1:8000&#39;); this.socket.emit(&#39;login&#39;, { userid: this.userid, username: this.username, userpwd: this.userpwd }); 客户端对应的就发起这个连接请求。发起连接后客户端向服务端发起一个事件login，并且携带参数对象(userid,username,userpwd)。下面我们看看服务端接收这个事件login socket.on(&#39;login&#39;, function(obj) { //obj这个对象就是客户端传递过来的，obj.userid,obj.username,obj.userpwd //我们就可以通过obj这个对象处理相应的登录逻辑处理 } nodejs主要通过socket来实现服务端和客户端的通信 其他API 向所有客户端广播：socket.broadcast.emit(‘broadcast message’); 我们可以通过他实现群内公告等功能。 进入一个房间（非常好用！相当于一个命名空间，可以对一个特定的房间广播而不影响在其他房间或不在房间的客户端）：socket.join(‘your room name’); 向一个房间广播消息（发送者收不到消息）：socket.broadcast.to(‘your room name’).emit(‘broadcast room message’); 向一个房间广播消息（包括发送者都能收到消息）（这个API属于io.sockets）：io.sockets.in(‘another room name’).emit(‘broadcast room message’); 强制使用WebSocket通信：（客户端）socket.send(‘hi’)，（服务器）用socket.on(‘message’, function(data){})来接收。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://zxhtom.oschina.io/tags/nodejs/"}]},{"title":"算法之路--最小代价生成树","date":"2016-11-29T04:48:00.000Z","path":"zxh/20161129.html","text":"这句话是在我学习算法设计的时候看到的 前言 一个无向连通图的生成树是极小连通子图 这句话是在我学习算法设计的时候看到的，当时学了很多什么无向连同有向连同的，具体的我也记不清了，记得上次说要整理算法模块的，一直没时间整理，心想行动才是最有效的办法。整理得出一句话：一棵生成树的代价是树中各条边上的代价之和且是最小。 贪心法 求一个带权无向图的最小代价生成树问题是一个最优化问题，一个无向图有多颗不同的生成树，一个无向图的所有生成树都可看成是问题的可行图。其中代价最小的生成树就是所求的最优解。加上我个人的观点就是遍历所有无向图可生成的树求得最小代价的解。为什么这么说呢，因为我们知道无向图的节点是有限个，既然结点有限那么派生出的树自然也就是有限个，我们在有限个解集中寻求最小生成树是可行的，不通思路效率不一样罢了。 运用穷举法是可行的，但是穷举法是在是太耗费精力了。实用贪心法可以极大的减少算法的计算量。 既然用贪心法，我们首先就要确定一条贪心准则，在每一步中我们都会选取一个局部最优的方案。在N个点中我们需要通过贪心法选择出N-1条边来构成无向连通图。我刚才也说了，贪心法是每部是选择局部最优，所以从全局的角度来考虑的话，不一定是全局最优解。 首先我们得设计一个类或者是一个Node来形容这个Ｎ个点，通过观察我们发现这个Ｎ个点有相同之处， 记录篇，慢慢更新","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Linux系统上安装OpenOffice","date":"2016-11-25T07:21:00.000Z","path":"zxh/20161125.html","text":"项目需求需要在linux上安装openOffice，本以为很简单，现在看来还是入了很多坑。理清楚就好了。** 项目需求需要在linux上安装openOffice，本以为很简单，现在看来还是入了很多坑。理清楚就好了。 官网地址 http://download.openoffice.org/other.html linux软件下载 解压软件 解压前就是一个压缩文件 在linux系统中我是在Windows上通过XShell连接的。通过这个命令进行解压tar -xzvf file.tar.gz 解压tar.gz 解压之后就是文件夹，我们需要的东西在这个解压后的文件夹中 去我们解压的文件里执行cd RPMS命令。 进入这个文件夹里，里面存放的是rpm文件，下面我们需要安装这些RPM文件，rpm -ivh *.rpm这个命令会一次去安装需要的rpm的，之间的依赖关系他会处理的。 安装完成之后，接着安装 OpenOffice 界面程序，安装程序在 desktop-integration 文件夹下面，安装文件名为：openoffice.org3.3-redhat-menus-3.3-9556.noarch.rpm执行命令进行安装 cd desktop-integration 安装桌面的界面rpm 里面有四个文件 注意区分openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm 命令代码rpm -ivh openoffice4.1.3-redhat-menus-4.1.3-9783.noarch.rpm 到这里OpenOffice安装结束 启动OpenOffice 到了这里怎么启动都不成功，仔细观察发现安装错了，我的linux是64位的，所以重新下载安装。这里需要卸载命令 在program文件下执行rpm -erpm -qa |grep openofficerpm -qa |grep ooobasis`` 重新安装后启动OpenOffice soffice -headless -accept=”socket,host=127.0.0.1,port=8100:urp;” -nofirststartwizard &amp; 启动之后再program输入netstat –tln查看是否启动成功！如上图所示有8100这个端口就可以使用了。 停止 Openoffice 查看ps -ef|grep soffice进程 查杀进程 kill -9 4119//4119 参考","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"项目部署之工具使用心得","date":"2016-11-23T03:24:00.000Z","path":"zxh/20161123.html","text":"最近忙于项目部署，慢慢发现有的时候娴熟的使用工具可以让事情事半功倍！ 最近忙于项目部署，慢慢发现有的时候娴熟的使用工具可以让事情事半功倍！下面一一列举项目部署中我使用的工具。也当做是自己的一种记录 FileZilla Client FileZilla是一个快速，实用多功能和界面直观的FTP客户端。FileZilla 是一个免费的 FTP 客户端软件，虽然它是免费软件，可功能却一点也不含糊，比起那些共享软件来有过之而无不及，在新的版本中作者改进了手动下载的界面和功能等，不过该软件暂时还是不支持断点续传功能。 第一次使用我们可以选择左上角的文件按钮。点击站点管理器。然后新增站点。新增站点时我们需要的信息有：主机(IP)+端口号+用户名+密码。协议我选择第二个(SFTP - SSH File Transfer Protocol)。这些信息配置好了之后我们选择站点连接就行了，然后我们就可以操作这个主机下的这个站点下的文件了(上传下载增加修改) 像上面文件一样，就是我们主机该端口下的文件，我们访问的时候直接加上主机IP后加上文件夹文字就可以访问文件下内容。 用了这么久了，自我感觉这个软件不是太好用，最大缺点就是一段时间不适用这个软件就会断掉连接，不知道其他软件这么样。在这里听公司大牛推荐使用Xftp，暂时还未使用，有时间会尝试这款软件。 SSH Secure Shell Client SSH是一个用来替代TELNET、FTP以及R命令的工具包，主要是想解决口令在网上明文传输的问题。为了系统安全和用户自身的权益，推广SSH是必要的。 SSH这个我的理解就是查看部署在服务器上的项目的运行现状及对项目的管理。 这里cmd命令和Linux下的命令一样，只需要了解常用的cmd命令就行。这款软件每次打开窗口都需要我们验证身份着实的麻烦。验证身份就是验证用户名和密码，这里有两种，我采用的是通过密码验证身份。具体的这里就不多说了。这里只是罗列并不深入研究软件的使用。 未完待续！！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"深入理解struts的运行机制","date":"2016-10-26T12:02:00.000Z","path":"zxh/20161026.html","text":"个人剖析，不喜勿喷 扫码关注公众号，不定期更新干活 在此申明本博文并非原创，原文：http://blog.csdn.net/lenotang/article/details/3336623，本文章是在此文章基础上进行优化。也谈不上优化，只是加上了点自己的想法 jar包准备 为什么会用到这两个jar包呢，因为我需要通过这个jar来解析xml配置文件。 新建项目 流程梳理 struts配置文件 ``` &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; /index.jsp /WEB-INF/login.jsp ``` 熟悉struts的朋友都清楚struts.xml配置文件的重要性，这个配置文件名字是可以更改的，这里简单解释下这个配置文件的作用，首先我们找到action这个节点这个action的name是login,就是说前台中请求这个login经过这个配置文件解析就会把这个请求交给action中的class属性，也就是上面的 org.zxh.action.LoginAction 具体的是交由这个类的login(method)这个方法。这个方法会方法一个string类型的字符串，如果返回的是success就将页面重定向到index.jsp如果是login就重定向到login.jsp。这个配置文件就是这样的作用。因为是自己写的，所以这里并不会想struts框架那样封装了很多东西，这里只是为了让读者更加深入的理解struts的运行机制。 如何将我们写的struts.xml文件在程序中启动呢？ 刚入门的同志可能会疑问，写一个配置文件就能处理前后台交互了？答案当然是不能。这里给大家普及一下web基础接触filter的，每次交互需要filter(jsp就是特殊的servlet)，所以想实现交互我们就得新建一个servlet，在这个servlet里我们去读我们写的struts.xml文件，通过读到的信息决定下一步的操作。那么如何启动一个filter呢？这个不多说，直接在web项目中的web.xml配置拦截器就会执行filter。 新建filter(FilterDispatcher) 这个servlet就是struts的核心过滤器，需要先继承过滤器。 ``` public class FilterDispatcher implements Filter{ @Override public void destroy() { // TODO Auto-generated method stub } @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { // TODO Auto-generated method stub } @Override public void init(FilterConfig arg0) throws ServletException { // TODO Auto-generated method stub } } ``` Filter中我们要在初始化函数(init)中对一些参数进行初始化，对那些数据初始化呢，对！当然是拿配置文件的信息啦。配置文件是.xml这里我用dom4j读取.xml配置文件。 把struts.xml配置文件放在src下，(可以放在其他地方，这里的地址填的对应就行了) // 获得xml配置文件 String webRootPath = getClass().getClassLoader() .getResource(&quot;struts.xml&quot;).getPath(); 拿到配置文件路径之后开始读取，这里我讲读到的数据封装到一个map里面。在封装在Map中我们仔细观察一下配置文件 其实我们放在Map里面就是这四个属性的值，有了这四个值我们就可以完成一次前后台交互的映射了。所以为了方便这里封装成javabean。 package org.zxh.util; import java.util.HashMap; import java.util.Map; /** * 将action属性封装成类 * @author 87077 * */ public class ActionConfig { //action 给别人调用的名字 private String name; //action对应程序中的action类 private String clazzName; //action中的方法 private String method; //返回结果不知一条 所以用Map private Map&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); public ActionConfig(){ } public ActionConfig(String name , String clazzName , String method , Map&lt;String, String&gt; resultMap){ this.name=name; this.clazzName=clazzName; this.method=method; this.resultMap=resultMap; } public String getName() { return name; } public String getClazzName() { return clazzName; } public String getMethod() { return method; } public Map&lt;String, String&gt; getResultMap() { return resultMap; } public void setName(String name) { this.name = name; } public void setClazzName(String clazzName) { this.clazzName = clazzName; } public void setMethod(String method) { this.method = method; } public void setResultMap(Map&lt;String, String&gt; resultMap) { this.resultMap = resultMap; } } 有了javabean 我们开始解析xml文件 package org.zxh.util; import java.io.File; import java.util.List; import java.util.Map; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; /** * 采用dom4j解析xml配置文件 * * @author 87077 * */ public class ConfigUtil { /** * @param fileName * 待解析的文件 * @param map * 存放解析的数据 */ public static void parseConfigFile(String fileName, Map&lt;String, ActionConfig&gt; map) { SAXReader reader = new SAXReader(); try { Document doc = reader.read(new File(&quot;D:\\\\zxh\\\\soft\\\\apache-tomcat-7.0.70\\\\apache-tomcat-7.0.70\\\\webapps\\\\MyStruts\\\\WEB-INF\\\\classes\\\\struts.xml&quot;)); Element root = doc.getRootElement(); List&lt;Element&gt; list = root.selectNodes(&quot;package/action&quot;); for (Element element : list) { // 封装成ActionConfig对象，保存在map中 ActionConfig config = new ActionConfig(); // 获取action中的值 String name = element.attributeValue(&quot;name&quot;); String clazzName = element.attributeValue(&quot;class&quot;); String method = element.attributeValue(&quot;method&quot;); // 将值传入javabean中 config.setName(name); config.setClazzName(clazzName); // 如果没有设置执行method 执行默认的 if (method == null || &quot;&quot;.equals(method)) { method = &quot;execute&quot;; } config.setMethod(method); // 继续向下获取action中的返回方法 List&lt;Element&gt; resultList = element.selectNodes(&quot;result&quot;); for (Element resultElement : resultList) { String resultName = resultElement.attributeValue(&quot;name&quot;); String urlPath = resultElement.getTextTrim(); if (resultName == null || &quot;&quot;.equals(resultName)) { resultName = &quot;success&quot;; } config.getResultMap().put(resultName, urlPath); } map.put(name, config); } } catch (DocumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 现在我们在回到过滤器上，上面两个类就是为了解析xml的。所以在Filter中的init方法里我们就可以将解析的数据放到我们的全局Map中 @Override public void init(FilterConfig arg0) throws ServletException { // TODO Auto-generated method stub 过滤器的初始化过程 // 获得xml配置文件 String webRootPath = getClass().getClassLoader() .getResource(&quot;struts.xml&quot;).getPath(); // 将xml配置文件解析装在到map中 ConfigUtil.parseConfigFile(webRootPath, map); } 过滤器的执行 过滤器真正执行是在doFilter方法开始时。 public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) doFilter()方法类似于Servlet接口的service()方法。当客户端请求目标资源的时候，容器就会调用与这个目标资源相关联的过滤器的 doFilter()方法。其中参数 request, response 为 web 容器或 Filter 链的上一个 Filter 传递过来的请求和相应对象；参数 chain 为代表当前 Filter 链的对象，在特定的操作完成后，可以调用 FilterChain 对象的 chain.doFilter(request,response)方法将请求交付给 Filter 链中的下一个 Filter 或者目标 Servlet 程序去处理，也可以直接向客户端返回响应信息，或者利用RequestDispatcher的forward()和include()方法，以及 HttpServletResponse的sendRedirect()方法将请求转向到其他资源。这个方法的请求和响应参数的类型是 ServletRequest和ServletResponse，也就是说，过滤器的使用并不依赖于具体的协议。 获取请求域和响应域还有Filter链，并设置编码防止乱码 //针对http请求，将请求和响应的类型还原为HTTP类型 HttpServletRequest request = (HttpServletRequest) arg0; HttpServletResponse response = (HttpServletResponse) arg1; //设置请求和响应的编码问题 request.setCharacterEncoding(&quot;UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); 获取请求地址 //获取请求路径 String url = request.getServletPath(); 通过请求去判断知否拦截过滤这个地址的请求，本文默认过滤所有以.action结尾的请求 //请求地址过滤，如果不是以.action结尾的 if(!url.endsWith(&quot;.action&quot;)){ //不是.action的放行 arg2.doFilter(request, response); return ; } 看我之前将xml文件中数据放入到Map的格式可以看出我是讲整个javabean放入Map中名字是action的name。所以下面我就要去那个name(就是请求中的login) //解析request路径 int start = url.indexOf(&quot;/&quot;); int end = url.lastIndexOf(&quot;.&quot;); String path=url.substring(start+1,end); //通过path去匹配到对应的ActionConfig类。在这里已经解析到了所有的action的信息 ActionConfig config = map.get(path); //匹配不成功就返回找不到页面错误信息 if(config==null){ response.setStatus(response.SC_NOT_FOUND); return ; } 获取了ActionConfig类了，action的所有信息都存储在这个javabean类中了，下面的事情就好办了。下面的只是会用到反射的知识。我们拿到真正action类的名称后就需要根据名字获取到这个action的实体类。 //通过ActionConfig获取完成的类名字 String clazzName=config.getClazzName(); //实例化Action对象，不存在的话就提示错误信息 Object action = getAction(clazzName); if(action==null){ //说明这个action是错误的，在配置文件中没有占到对应的action类 response.setStatus(response.SC_NOT_FOUND); return ; } request参数获取并赋值给action 执行action的方法前很定需要先将request中的参数获取到，进行赋值，这部才是真正的意义上的交互。 public static void requestToAction(HttpServletRequest request , Object action ) 将传进来的action对象进行class话并获取action实体下的属性 Class&lt;? extends Object&gt; clazzAction = action.getClass(); //获取aciton中所有属性，从前台获取的值很多，只有action属性中有的才会进行反射赋值 Field[] fields = action.getClass().getDeclaredFields(); 拿到request传过来的值并进行遍历 //获取请求中的名字属性值 Enumeration&lt;String&gt; names=request.getParameterNames(); String name=names.nextElement(); boolean flag=false; //需要判断action属性中没有的而请求中有的我们不需要进行反射处理 for (Field field : fields) { if(name.equals(field.getName())){ flag=true; } } if(!flag){ return; } String[] value=request.getParameterValues(name); 通过request中的name并且在action中有这个属性之后我们就需要获取action这个字段的属性。 Class&lt;Object&gt; fieldType=(Class&lt;Object&gt;) clazzAction.getDeclaredField(name).getType(); 获取action的改name字段属性的set方法 //通过反射调用该属性的set方法 String setName=&quot;set&quot;+name.substring(0,1).toUpperCase()+name.substring(1); Method method=clazzAction.getMethod(setName, new Class[]{fieldType}); 下面我们就需要将获取的value按类型 private static Object[] transfer(Class&lt;Object&gt; fieldType , String[] value){ Object[] os = null; //fieldType 是[]这种类型的，需要将[]去掉 String type=fieldType.getSimpleName().replace(&quot;[]&quot;, &quot;&quot;); if(&quot;String&quot;.equals(type)){ os=value; }else if(&quot;int&quot;.equals(type)||&quot;Integer&quot;.equals(type)){ os = new Integer[value.length]; for (int i = 0; i &lt; os.length; i++) { os[i] = Integer.parseInt(value[i]); } }else if(&quot;float&quot;.equals(type)||&quot;Float&quot;.equals(type)){ os=new Float[value.length]; for (int i = 0; i &lt; os.length; i++) { os[i]=Float.parseFloat(value[i]); } }else if(&quot;double&quot;.equals(type)||&quot;Double&quot;.equals(type)){ os=new Double[value.length]; for (int i = 0; i &lt; os.length; i++) { os[i]=Double.parseDouble(value[i]); } } return os; } 获取object数据之后就是讲这个object数据通过反射付给action对应的属性 //判断是否是数组属性 if(fieldType.isArray()){ method.invoke(action, new Object[]{object}); }else { method.invoke(action, new Object[]{object[0]}); } 这说一下 method.invoke是将action类中method方法这个方法需要的参数就是object&lt;a href=”http://www.oschina.net/code/snippet_216465_36771”&gt;详解 有了这个方法我们在回到Filter就可以了 //前置拦截，获取request里面的参数，调用action的set方法给属性设置值 BeanUtil.requestToAction(request, action); 属性赋值完成就开始执行action中的method了 private String executeAction(ActionConfig config, Object action) { String method = config.getMethod(); String result = null; try { Method callMethod = action.getClass().getMethod(method,String.class); result = (String) callMethod.invoke(action, new Object[] {}); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } return config.getResultMap().get(result); } 到这里你已经获取了配置文件中前台映射后应该的result了，那么就简单了，直接重定向就可以了，到这里就实现了struts的前后台交互。 request.getRequestDispatcher(result).forward(request, response); 验证正确性 下面就在前台jsp中form表单将数据传递给我们的login action看看会不会去执行指定的方法 &lt;form method=&quot;post&quot; action=&quot;login.action&quot; name=&quot;loginForm&quot;&gt; &lt;table width=&quot;422&quot; border=&quot;1&quot; bgcolor=&quot;#0080c0&quot; height=&quot;184&quot;&gt; &lt;caption&gt; &lt;h1&gt;用户登陆&lt;/h1&gt; &lt;/caption&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&amp;nbsp;姓名：&lt;/td&gt; &lt;td&gt;&amp;nbsp; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&amp;nbsp;密码：&lt;/td&gt; &lt;td&gt;&amp;nbsp; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;&amp;nbsp; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; name=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; name=&quot;reset&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/form&gt; 效果读者自行展示吧，到这里struts的运行机制就讲完了，注意知识运行机制里面还有很多值得我们学习的东西，就好比说这里有很多过滤器，不同过滤器过滤数据程度不同执行效果不同。希望有机会再和大家分享一些其他关于struts的知识！ 上诉原理的源码下载 扫码关注公众号，不定期更新干活","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Window.open使用总结","date":"2016-10-22T07:11:00.000Z","path":"zxh/20161022.html","text":"今天在项目中，突然看到window.open的使用，感觉还是很神奇，突然心血来潮查看了window.open的用法。 前言 今天在项目中，突然看到window.open的使用，感觉还是很神奇，突然心血来潮查看了window.open的用法。 用途 主要用于在打开网站时弹出的其他窗口。用于通知广告一类的。 用法 window.open(url, winName, theproperty); 参数详解 url:打开窗口的网址或路径 winName:窗口的名称 ,常见的”_blank”,”_top”,”_self”等 theproperty：是一些参数字符串 width:窗口的宽度； height：窗口的高度； top:窗口距离顶部的高度。 left:窗口距离左边的宽度。 注意：以下几个参数的值均为：yes|no。 menubar:窗口是否有菜单栏。 toolbar:窗口是否有工具栏。 scrollbars:窗口是否有滚动条。 status：窗口是否有状态栏 这是我的项目中的一条字符串 ``` var winoption = &quot;left=0,top=0,height=&quot; + sheight + &quot;,width=&quot; + swidth + &quot;,toolbar=yes,menubar=yes,location=yes,status=yes,scrollbars=yes,resizable=yes&quot;; ``` 调用 参数设置好，直接调用就可以了。 个人记录而已，不喜勿喷！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"POI通用导出Excel数据(包括样式设计)","date":"2016-10-19T03:16:00.000Z","path":"zxh/20161019.html","text":"前一段时间我写过通用的导入Excel 前言 前一段时间我写过通用的导入Excel，前几天也写了导出pdf格式的，还有我之前搞得导出Word，我在之前的博客也都介绍了导出和导入是一个道理，无非是一个获取一个是赋值。昨天有一位同仁看了我的Excel通用导入导出那个源码，说不是太懂。顺道今天整理了一下导出那块的知识，导入我之前已经介绍的很详细了。今天我们就来说说Excel导出的那些事！ 前期准备 jar包下载，我们使用对Excel，Word操作的都是借助poi来实现的，所以首先我们需要下载jar包。POI 下载 猛戳我 代码解析通过javabean来实现数据的导出 数据准备： ``` String[] headers = { &quot;学号&quot;, &quot;姓名&quot;, &quot;年龄&quot;, &quot;性别&quot;, &quot;出生日期&quot; }; List&lt;Student&gt; dataset = new ArrayList&lt;Student&gt;(); dataset.add(new Student(10000001, &quot;张三&quot;, 20, true, new Date())); dataset.add(new Student(20000002, &quot;李四&quot;, 24, false, new Date())); dataset.add(new Student(30000003, &quot;王五&quot;, 22, true, new Date())); ``` 然后我用导出的工具类开始导数据 ``` ExportExcel&lt;Student&gt; ex = new ExportExcel&lt;Student&gt;(); ex.exportExcel(headers, dataset, out); ``` ExportExcel是我写的一个模板，这个模板下面有两个exportExcel这个方法，一个是穿map数据的，另一个是传javabean的，我们上面穿的是javabean所以会调用javabean的方法。也就是说exportExcel会调用下面这个方法 最终我们调用的是exportExcelByBean这个方法。 下面我们详细解说exportExcelByBean这个方法内容。 1、首先声明一个Excel工作簿 HSSFWorkbook workbook = new HSSFWorkbook(); 2、生成一个表格，传的title就是表格sheet也得名字 HSSFSheet sheet = workbook.createSheet(title); 3、设置表格默认宽度 sheet.setDefaultColumnWidth((short) 15); 4、设置样式 HSSFCellStyle style = workbook.createCellStyle(); // 设置这些样式 style.setFillForegroundColor(HSSFColor.SKY_BLUE.index); style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND); style.setBorderBottom(HSSFCellStyle.BORDER_THIN); style.setBorderLeft(HSSFCellStyle.BORDER_THIN); style.setBorderRight(HSSFCellStyle.BORDER_THIN); style.setBorderTop(HSSFCellStyle.BORDER_THIN); style.setAlignment(HSSFCellStyle.ALIGN_CENTER); 需要补充一下，我设置这个样式就是让导出Excel变得美观一点，你可以不要这个。 设置导出的字体样式并把这个字体加入到上面那个样式中 // 生成另一个字体 HSSFFont font2 = workbook.createFont(); font2.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL); // 把字体应用到当前的样式 style2.setFont(font2); 其他的一些样式设置 ```// 声明一个画图的顶级管理器 HSSFPatriarch patriarch = sheet.createDrawingPatriarch(); // 定义注释的大小和位置,详见文档 HSSFComment comment = patriarch.createComment(new HSSFClientAnchor(0, 0, 0, 0, (short) 4, 2, (short) 6, 5)); // 设置注释内容 comment.setString(new HSSFRichTextString(&quot;可以在POI中添加注释！&quot;)); // 设置注释作者，当鼠标移动到单元格上是可以在状态栏中看到该内容. comment.setAuthor(&quot;leno&quot;); 设置表格的表头 // 产生表格标题行 HSSFRow row = sheet.createRow(0); for (short i = 0; i &lt; headers.length; i++) { HSSFCell cell = row.createCell(i); cell.setCellStyle(style); HSSFRichTextString text = new HSSFRichTextString(headers[i]); cell.setCellValue(text); } 到这里表格的容器样式已经设置完了，下面就是导出数据到我们准备的Excel中了。 拿到集合中的所有javabean Iterator&lt;T&gt; it = dataset.iterator(); 在遍历数据的时候我们用的既然javabean就需要用到反射机制，这个简单的介绍一下反射这个神奇的东西。 // 利用反射，根据javabean属性的先后顺序，动态调用getXxx()方法得到属性值 Field[] fields = t.getClass().getDeclaredFields(); 然后遍历属性，拿到单一属性后判断该用get还是is方法 Field field = fields[i]; String fieldName = field.getName(); String[] split=field.toString().split(&quot; &quot;); String getMethodName=&quot;&quot;; if(&quot;boolean&quot;.equalsIgnoreCase(split[1])||&quot;bool&quot;.equalsIgnoreCase(split[1])){ getMethodName = &quot;is&quot; + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1); }else { getMethodName = &quot;get&quot; + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1); } 然后就是通过反射区调用javabean的方法获取值了 Class tCls = t.getClass(); Method getMethod = tCls.getMethod(getMethodName,new Class[] {}); Object value = getMethod.invoke(t, new Object[] {}); 我们获取到了值，现在我们就需要对值进行判断了，如果是日期类型的，我们需要指定格式输出到Excel中，如果是数字我们就输出数字，如果是字符串我们输出字符串，如果是bool那么我们根据需求输出两种值得其中一种。 ``` // 判断值的类型后进行强制类型转换 String textValue = null; if (value instanceof Boolean) { boolean bValue = (Boolean) value; textValue = &quot;男&quot;; if (!bValue) { textValue = &quot;女&quot;; } } else if (value instanceof Date) { Date date = (Date) value; SimpleDateFormat sdf = new SimpleDateFormat(pattern); textValue = sdf.format(date); } else if (value instanceof byte[]) { // 有图片时，设置行高为60px; row.setHeightInPoints(60); // 设置图片所在列宽度为80px,注意这里单位的一个换算 sheet.setColumnWidth(i, (short) (35.7 * 80)); // sheet.autoSizeColumn(i); byte[] bsValue = (byte[]) value; HSSFClientAnchor anchor = new HSSFClientAnchor(0, 0, 1023, 255, (short) 6, index, (short) 6, index); anchor.setAnchorType(2); patriarch.createPicture(anchor, workbook.addPicture( bsValue, HSSFWorkbook.PICTURE_TYPE_JPEG)); } else { // 其它数据类型都当作字符串简单处理 textValue = value.toString(); } ``` 然后就是将数据写入Excel if (textValue != null) { Pattern p = Pattern.compile(&quot;^\\\\d+(\\\\.\\\\d+)?$&quot;); Matcher matcher = p.matcher(textValue); if (matcher.matches()) { // 是数字当作double处理 cell.setCellValue(Double.parseDouble(textValue)); } else { HSSFRichTextString richString = new HSSFRichTextString( textValue); HSSFFont font3 = workbook.createFont(); font3.setColor(HSSFColor.BLUE.index); richString.applyFont(font3); cell.setCellValue(richString); } } 最后写出这个工作簿 try { workbook.write(out); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } 调用说明，OutputStream out = new FileOutputStream(“D://zxh//test//a.xls”); 给一个输出流 工Excel输出，如果是JavaWeb中应用，那就直接将这个工作簿输出到前台让浏览器下载就行了。 通过Map来实现数据的导出 通过Map的好处就是我们不用去准备javabean了，也就自然没有反射那块难点了，既方便有易懂，何乐而不为呢。 也就是说最后我们选择的是 exportExcelByMap 这个方法 基于上面javabean介绍的很详细了，我这个map就不在赘述了，我只说一下关键点的地方，通过Map和通过javabean的，我们的表格样式是不变的，所以不一样的地方就是在遍历数据的时候讲数据赋值到Excel中的，最后输出的那个也不便，说白了就是获取数据的方式不一样了，javabean我是通过反射获取的，如果用了map我们直接用get就行了。 for(int i=0;i&lt;list.size();i++){ Map&lt;String, Object&gt; map = list.get(i); HSSFCell cell = row.createCell(i); cell.setCellStyle(style2); //拿到第一个数据 for(String field : headers){ //遍历字段进行顺序赋值 Object value = map.get(field); // 判断值的类型后进行强制类型转换 String textValue = null; if (value instanceof Boolean) { boolean bValue = (Boolean) value; textValue = &quot;男&quot;; if (!bValue) { textValue = &quot;女&quot;; } } else if (value instanceof Date) { Date date = (Date) value; SimpleDateFormat sdf = new SimpleDateFormat(pattern); textValue = sdf.format(date); } else if (value instanceof byte[]) { // 有图片时，设置行高为60px; row.setHeightInPoints(60); // 设置图片所在列宽度为80px,注意这里单位的一个换算 sheet.setColumnWidth(i, (short) (35.7 * 80)); // sheet.autoSizeColumn(i); byte[] bsValue = (byte[]) value; HSSFClientAnchor anchor = new HSSFClientAnchor(0, 0, 1023, 255, (short) 6, index, (short) 6, index); anchor.setAnchorType(2); patriarch.createPicture(anchor, workbook.addPicture( bsValue, HSSFWorkbook.PICTURE_TYPE_JPEG)); } else { // 其它数据类型都当作字符串简单处理 textValue = value.toString(); } // 如果不是图片数据，就利用正则表达式判断textValue是否全部由数字组成 if (textValue != null) { Pattern p = Pattern.compile(&quot;^\\\\d+(\\\\.\\\\d+)?$&quot;); Matcher matcher = p.matcher(textValue); if (matcher.matches()) { // 是数字当作double处理 cell.setCellValue(Double.parseDouble(textValue)); } else { HSSFRichTextString richString = new HSSFRichTextString( textValue); HSSFFont font3 = workbook.createFont(); font3.setColor(HSSFColor.BLUE.index); richString.applyFont(font3); cell.setCellValue(richString); } } } } try { workbook.write(out); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } 总结整个博客我一直强调，用Map好，因为现在JavaWeb中框架主流是mybatis等框架，而这些框架封装的数据库数据正好就是通过map格式传输的，所以我们直接获取的就是Map数据，然后直接传到我的方法中就可以导出了，就不用javabean了。 源码下载 猛戳！！！！","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"JSmooth 将java代码打包成exe","date":"2016-10-18T07:36:00.000Z","path":"zxh/20161018.html","text":"JSmooth 将java代码打包成exe JSmooth 将java代码打包成exe 前言 java代码写了这么多了，但由于jdk的限制，我只能在jdk电脑上运行项目。所以最近在研究打包exe这个问题，今天终于实现了。 JSmooth下载 前期准备 将我们的jar包和jre还有exe头像三个文件放在同一个文件夹下，如何将java代码打包成jar我就不多说了，不会的可以私信我！ 开始工作 这是JSmooth运行的开始界面，在我的下载包中解压之后第二个exe运行程序打开就是这样子的。 选择骨架 首先我们得选择exe执行的方式，也就是这里的骨架。我这里选择Console Wrapper 可执行程序 首先我们选择我们事先准备好的一些文件，注意这个时候我们选择进去的都是一些绝对路径 勾选完之后我们需要小处理一下，这里也是JSmooth的一个BUG，我们需要先将这个骨架保存起来然后重新点击骨架，在点击可执行程序，回来之后我们会发现之前绝对路径撑了相对路径了。(PS:我个人建议在保存的时候讲文件保存在我们时间准备的那个文件夹中，这样方便以后导入修改) 应用程序 首先选择classPath类路径，按顺序将我们需要的jar包导入，注意要先到用的jar，辅助的jar其次。 还有一种方法我们选择勾选嵌入式jar，这样你的EXE 人家就看不到你的jar,这样就可以保障你的代码不被别人窃取了。 JVM选择 现在我们只需要绑定jre就可以在其他没有jdk电脑上运行了 JVM配置 发布 点击运行就会在指定的文件夹中生成我们的EXE 注意上面出现的绝对路径是因为我在演示的时候没有保存在点骨架，读者们按我的步骤来就会出现相对路径的，出现相对路径就是正确的，如果不是相对路径就导致你的ＥＸＥ拷贝到别人电脑上无法随意的放，只能和你电脑放置的位置一样！！！ 修改ＥＸＥ","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"input默认值设置","date":"2016-10-18T06:12:00.000Z","path":"zxh/20161018.html","text":"在input框里我们可以设置一些默认值，在点击之后input之后就消失了 在input框里我们可以设置一些默认值，在点击之后input之后就消失了 &lt;input id=&quot;_le_name&quot; type=&quot;text&quot; onFocus=&quot;focusInputEle(this)&quot; onBlur=&quot;blurInputEle(this)&quot; defaultVal=&quot;请输入学习资源名称关键字...&quot; value=&quot;请输入学习资源名称关键字...&quot; class=&quot;sou_text&quot; /&gt; 效果： 点击之后效果:","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Spring 5 新功能：函数式 Web 框架","date":"2016-10-14T00:46:00.000Z","path":"zxh/20161014.html","text":"就像在昨天Juergen发布的博客的一样，Spring 英文：ARJEN POUTSMA 译文：debugging, 达尔文, 混元归一, leoxu, xufuji456 链接：oschina.net/translate/new-in-spring-5-functional-web-framework 就像在昨天Juergen发布的博客的一样，Spring 5.0框架第二个里程碑版本中介绍了一个新的函数式web框架。在这篇文章中，我将更详细的介绍这个框架。 紧记该函数式web框架是在Spring5.0第一个里程碑版本基础上构建的。并且我们依旧提供基于注解的请求处理（例如@Controller,@RequestMapping)，关于基于注解的请求处理部分的相关信息请查阅关于Spring5.0第一个里程碑版本的博客。 示例我们选用示例程序作为开始。下面是一个响应资源库用于暴露Person对象。这个响应资源库与传统的无响应资源库类似，除了Flux对应传统的 List，Mono对应传统的 Person对象。Mono作为完成标识：用于指示保存工作完成.更多Reactor 类型信息请查阅 Dave发布的博客 public interface PersonRepository { Mono&lt;Person&gt; getPerson(int id); Flux&lt;Person&gt; allPeople(); Mono&lt;Void&gt; savePerson(Mono&lt;Person&gt; person);} &lt;p&gt;这里我们介绍如何使用新的函数式web框架暴露资源库：&lt;/p&gt; RouterFunction&lt;?&gt; route = route(GET(&quot;/person/{id}&quot;), request -&gt; { Mono&lt;Person&gt; person = Mono.justOrEmpty(request.pathVariable(&quot;id&quot;)) .map(Integer::valueOf) .then(repository::getPerson); return Response.ok().body(fromPublisher(person, Person.class)); }) .and(route(GET(&quot;/person&quot;), request -&gt; { Flux&lt;Person&gt; people = repository.allPeople(); return Response.ok().body(fromPublisher(people, Person.class)); })) .and(route(POST(&quot;/person&quot;), request -&gt; { Mono&lt;Person&gt; person = request.body(toMono(Person.class)); return Response.ok().build(repository.savePerson(person)); })); 这里我们介绍如何运行它，下面是Reactor Netty的示例： HttpHandler httpHandler = RouterFunctions.toHttpHandler(route); ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler); HttpServer server = HttpServer.create(&quot;localhost&quot;, 8080); server.startAndAwait(adapter); 最后要做的是，进行一次尝试请求： $ curl &#39; {&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:42} 上面的介绍覆盖了很多内容，下面让我们深入挖掘下！ 核心组件我将通过依次介绍HandlerFunction,RouterFunction以及FilterFunction 等核心组件来介绍整个框架。这三个接口以及本文中其他类型都可以在org.springframework.web.reactive.function包中找到。 处理功能新框架的起点是HandlerFunction，其实质是Function&lt;Request, Response&gt;，其中的Request 和 Response都是新定义的不可变接口，提供了基础的对JDK8优化的HTTP消息描述DSL。有一个便捷的构造Response实例的构造器，与ResponseEntity中的十分相似。注解方式中与HandlerFunction相对应的是@RequestMapping所注解的方法。如下是“Hello World”的处理方法，它返回了状态为200，body为字符串的消息。 HandlerFunction&lt;String&gt; helloWorld = request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)); 如上，构建于Reactor之上的处理方法是完全的响应式的（reactive），它们可以接受Flux、Mono或者其他相应流（Reactive Streams）的发布者作为返回类型的参数。需要注意的是处理方法本身是没有副作用的，因为它将response作为返回值，而不是作为参数（对比Servlet.service(ServletRequest,ServletResponse)，其实质是BiConsumer）。无副作用的方法有很多好处：更有利于测试、构建和优化。 路由功能入站请求是由RouterFunction，(即Function&lt;Request, Optional&lt;HandlerFunction&gt;)路由到HandlerFunction中去的。当满足条件匹配时，路由方法会执行处理方法，否则会返回一个空结果。路由方法与@RequestMapping注解的作用相似。但是，还有一个显著的区别：用注解时路由会被限制到注解的value所能表达的范围，处理这些方法的覆盖是困难的；当用路由方法的时候，代码就在那里，可以轻松的覆盖或替换。如下是一个路由方法的例子，包含了一个行内的处理方法。这里看起来有一点冗余，不必担心，因为后面我们将会将它变得精简。 RouterFunction&lt;String&gt; helloWorldRoute = request -&gt; { if (request.path().equals(&quot;/hello-world&quot;)) { return Optional.of(r -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;))); } else { return Optional.empty(); } }; 一般不用写完整的路由方法，而是静态引入RouterFunctions.route()，这样就可以用请求判断式（RequestPredicate） (即 Predicate)和处理方法（HandlerFunction）创建路由方法了。如果判断式判断成功则返回处理方法，否则返回空结果。如下是用route方法方式重写上面的例子： RouterFunction&lt;String&gt; helloWorldRoute = RouterFunctions.route(request -&gt; request.path().equals(&quot;/hello-world&quot;), request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;))); 静态引入RequestPredicates.*后就可以使用那些常用的判断式了，如匹配路径、HTTP方法、content-type等。这样上面的例子将会变得更精简： RouterFunction&lt;String&gt; helloWorldRoute = RouterFunctions.route(RequestPredicates.path(&quot;/hello-world&quot;), request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;))); 组合功能两个路由方法可以被组合成一个新的路由方法，可以路由任意处理方法：如果第一个路由不匹配则执行第二个。可以通过调用RouterFunction.and()方法实现，如下： RouterFunction&lt;?&gt; route = route(path(&quot;/hello-world&quot;), request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;))) .and(route(path(&quot;/the-answer&quot;), request -&gt; Response.ok().body(fromObject(&quot;42&quot;)))); 上面的例子如果路径匹配/hello-world会返回“Hello World”，如果匹配/the-answer则返回“42”。如果都不匹配则返回一个空的Optional对象。注意，组合的路由是按顺序执行的，所以应该将更通用的方法放到更明确的方法的前面。请求判断式也是可以组合的，通过调研and或者or方法。正如预期的一样：and表示给定的两个判断式同时满足则组合判断式满足，or则表示任意判断式满足。如下： RouterFunction&lt;?&gt; route = route(method(HttpMethod.GET).and(path(&quot;/hello-world&quot;)), request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;))) .and(route(method(HttpMethod.GET).and(path(&quot;/the-answer&quot;)), request -&gt; Response.ok().body(fromObject(&quot;42&quot;)))); 实际上，RequestPredicates中的大部分判断式都是组合的！比如RequestPredicates.GET(String)是RequestPredicates.method(HttpMethod)和RequestPredicates.path(String)的组合。所以上面的例子可以重写为： RouterFunction&lt;?&gt; route = route(GET(&quot;/hello-world&quot;), request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;))) .and(route(GET(&quot;/the-answer&quot;), request -&gt; Response.ok().body(fromObject(42)))); 方法引用此外，目前为止我们的处理方法都是行内的lambda表达式。尽管这样很适合于实例和简短的例子，但是当结合请求路由和请求处理两个关注点时，可能就有变“混乱”的趋势了。所以我们将尝试将他们简化。首先，创建一个包含处理逻辑的类： class DemoHandler { public Response&lt;String&gt; helloWorld(Request request) { return Response.ok().body(fromObject(&quot;Hello World&quot;)); } public Response&lt;String&gt; theAnswer(Request request) { return Response.ok().body(fromObject(&quot;42&quot;)); }} 注意，这两个方法的签名都是和处理方法兼容的。这样就可以方法引用了： DemoHandler handler = new DemoHandler(); // or obtain via DI RouterFunction&lt;?&gt; route = route(GET(&quot;/hello-world&quot;), handler::helloWorld) .and(route(GET(&quot;/the-answer&quot;), handler::theAnswer)); 过滤功能由路由器函数进行映射的路由可以通过调用 RouterFunction.filter(FilterFunction) 来进行过滤, 这里的 FilterFunction 其实就是一个 BiFunction&lt;Request, HandlerFunction, Response&gt;。函数的处理器（handler）参数代表的就是整个链条中的下一项: 这是一个典型的 HandlerFunction, 但如果附加了多个过滤器的话，它也能够是另外的一个 FilterFunction。让我们向路由添加一个日志过滤器： RouterFunction&lt;?&gt; route = route(GET(&quot;/hello-world&quot;), handler::helloWorld) .and(route(GET(&quot;/the-answer&quot;), handler::theAnswer)) .filter((request, next) -&gt; { System.out.println(&quot;Before handler invocation: &quot; + request.path()); Response&lt;?&gt; response = next.handle(request); Object body = response.body(); System.out.println(&quot;After handler invocation: &quot; + body); return response; }); 注意这里对下一个处理器的调用时可选的。这个在安全或者缓存的场景中是很有用的 (例如只在用户拥有足够的权限时才调用 next)。因为 route 是一个没有被绑定的路由器函数，我们就得知道接下来的处理会返回什么类型的响应消息。这就是为什么我们在过滤器中要以一个 Response&lt;?&gt; 结束, 那样它就会可能有一个 String 类型的响应消息体。我们可以通过使用 RouterFunction.andSame() 而不是 and() 来完成这件事情。这个组合方法要求路由器函数参数是同一个类型。例如，我们可以让所有的响应消息变成小写的文本形式: RouterFunction&lt;String&gt; route = route(GET(&quot;/hello-world&quot;), handler::helloWorld) .andSame(route(GET(&quot;/the-answer&quot;), handler::theAnswer)) .filter((request, next) -&gt; { Response&lt;String&gt; response = next.handle(request); String newBody = response.body().toUpperCase(); return Response.from(response).body(fromObject(newBody)); }); 使用注解的话，类似的功能可以使用 @ControllerAdvice 或者是一个 ServletFilter 来实现。 运行一个服务端所有这些都很不错，不过仍然有一块欠缺：我们如何实际地将这些函数在一个 HTTP 服务器中跑起来呢? 答案毋庸置疑，那就是通过调用另外的一个函数。 你可以通过使用 RouterFunctions.toHttpHandler() 来将一个路由器函数转换成 HttpHandler。HttpHandler 是 Spring 5.0 M1 中引入的一个响应式抽象: 它能让你运行许多的响应式运行时: Reactor Netty, RxNetty, Servlet 3.1+, 以及 Undertow。在本示例中，我们已经展示了在 Reactor Netty 中运行一个路由会是什么样子的。对于 Tomcat 来说则是像下面这个样子： HttpHandler httpHandler = RouterFunctions.toHttpHandler(route); HttpServlet servlet = new ServletHttpHandlerAdapter(httpHandler); Tomcat server = new Tomcat(); Context rootContext = server.addContext(&quot;&quot;, System.getProperty(&quot;java.io.tmpdir&quot;)); Tomcat.addServlet(rootContext, &quot;servlet&quot;, servlet); rootContext.addServletMapping(&quot;/&quot;, &quot;servlet&quot;); tomcatServer.start(); 需要注意的意见事情就是上面的东西并不依赖于一个 Spring 应用程序上下文。就跟 JdbcTemplate 以及其它 Spring 的工具类那样, 要不要使用应用程序上下文是可以选的: 你可以将你的处理器和路由器函数在一个上下文中进行绑定，但并不是必须的。还要注意的就是你也可以将一个路由器函数转换到一个 HandlerMapping中去，那样就它可以在一个 DispatcherHandler (可能是跟响应式的 @Controllers 并行)中运行了。 结论至此便结束了对 Spring 新函数式 web 框架的介绍。让我简单小结一下： 处理功能通过作出回应来处理请求， 路由器功能可连接到处理功能，并可与其他路由器功能共用， 路由器功能可由过滤器的功能进行过滤， 路由器功能可在响应式网络运行机制中运行。 转载 http://geek.csdn.net/news/detail/107401","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"LayDate使用","date":"2016-10-14T00:45:00.000Z","path":"zxh/20161014.html","text":"layDate非常愿意和您成为工作伙伴 layDate非常愿意和您成为工作伙伴。她致力于成为全球最用心的web日期支撑，为国内外所有从事web应用开发的同仁提供力所能及的动力。她基于原生JavaScript精心雕琢，兼容了包括IE6在内的所有主流浏览器。她具备优雅的内部代码，良好的性能体验，和完善的皮肤体系，并且完全开源，你可以任意获取开发版源代码，一扫某些传统日期控件的封闭与狭隘。layDate本着资源共享的开发者精神和对网页日历交互无穷的追求，延续了layui一贯的简单与易用。她遵循LGPL协议，您可以免费将她用于任何个人项目 选择理由 layDate除了包含日期范围限制、开始日期设定、自定义日期格式、时间戳转换、当天的前后若干天返回、时分秒选择、智能响应、自动纠错、节日识别，快捷键操作等常规功能外，还拥有更多趋近完美的解决方案。 引用jsalert(“1”) &lt;script type=&quot;text/javascript&quot; src=&quot;../js/plugins/laydate/laydate.js&quot;&gt;&lt;/script&gt; 注意事项 解压后，将laydate整个文件放至您项目的任意目录，不要移动其文件结构，它们具有完整的依赖体系。使用只需在页面引入laydate.js即可。如果您的网站的js采用合并或模块加载，您需要打开laydate.js，修改path。用于实际项目时请保留来源，勿剔除laydate.js头部注释。 回调执行【自定义日期格式】 &lt;div id=&quot;test1&quot; class=&quot;laydate-icon&quot;&gt;&lt;/div&gt; &lt;script&gt; laydate({ elem: &#39;#test1&#39;, format: &#39;YYYY/MM&#39;, // 分隔符可以任意定义，该例子表示只显示年月 festival: true, //显示节日 choose: function(datas){ //选择日期完毕的回调 alert(&#39;得到：&#39;+datas); } }); &lt;/script&gt; 限定时间范围【日期范围限定在昨天到明天】 &lt;div id=&quot;hello3&quot; class=&quot;laydate-icon&quot;&gt;&lt;/div&gt; &lt;script&gt; laydate({ elem: &#39;#hello3&#39;, min: laydate.now(-1), //-1代表昨天，-2代表前天，以此类推 max: laydate.now(+1) //+1代表明天，+2代表后天，以此类推 }); &lt;/script&gt;","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"iText实现pdf导出","date":"2016-10-10T00:18:00.000Z","path":"zxh/20161010.html","text":"直接看代码吧 /** * AsianTest.java */ import java.io.FileOutputStream; import java.io.IOException; import com.lowagie.text.*; import com.lowagie.text.pdf.PdfWriter; import com.lowagie.text.pdf.BaseFont; import com.lowagie.text.Font; import java.awt.Color; public class AsianTest { public static void main(String[] args) { // 创建一个Document对象 Document document = new Document(); try { // 生成名为 AsianTest.pdf 的文档 PdfWriter.getInstance(document, new FileOutputStream( &quot;c://AsianTest.pdf&quot;)); /** * 新建一个字体,iText的方法 STSongStd-Light 是字体，在iTextAsian.jar 中以property为后缀 * UniGB-UCS2-H 是编码，在iTextAsian.jar 中以cmap为后缀 H 代表文字版式是 横版， 相应的 V * 代表竖版 */ BaseFont bfChinese = BaseFont.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;, false); Font bold_fontChinese = new Font(bfChinese, 12, Font.BOLD, Color.BLACK); Font italic_fontChinese = new Font(bfChinese, 12, Font.ITALIC, Color.BLACK); Font impressFont = new Font(bfChinese, 16, Font.BOLDITALIC, Color.BLACK); // 打开文档，将要写入内容 document.open(); // 插入一个段落 // Paragraph par = new Paragraph(&quot;我们&quot;, fontChinese); // document.add(par); // document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); String[] Trainspotting1 = { &quot;选择生命，选择工作，选择职业，选择家庭，&quot;, &quot;选择可恶的大彩电,选择洗衣机、汽车、雷射碟机,&quot;, &quot;选择健康、低胆固醇和牙医保险,选择楼宇按揭,&quot;, &quot;选择你的朋友,选择套装、便服和行李,选择分期付款和三件套西装,&quot;, &quot;选择收看无聊的游戏节目,边看边吃零食……选择你的未来,选择生命……&quot;, &quot;太多选择,你选择什么,我选择不选择。&quot; }; String[] Trainspotting2 = { &quot;这是电影《猜火车》开头的旁白。&quot;, &quot;这是一个关于“选择”的故事。&quot; }; String[] Benjamin1 = { &quot;有些人就在河边出生长大,&quot;, &quot;有些人被闪电击中,&quot;, &quot;有些人对音乐有着非凡的天赋,&quot;, &quot;有些人是艺术家,&quot;, &quot;有人会游泳,&quot;, &quot;有人懂得做纽扣,&quot;, &quot;有人会背莎士比亚,&quot;, &quot;而有些人。。。是母亲,&quot;, &quot;也有些人,可以翩翩起舞。&quot;, &quot;Goodnight Daisy&quot;, &quot;Goodnight Benjamin&quot; }; String[] Benjamin2 = { &quot;这是电影《本杰明传奇》结尾的旁白。&quot;, &quot;这是一个关于“错过”的故事。&quot; }; String[] text1 = { &quot;我想说的是，&quot;, &quot;我们选择，同时，我们错过。&quot; }; String[] text2 = { &quot;抛去无可选择的选择，抑或不选择的选择，&quot;, &quot;很有趣的一件事：当面临(太多的)选择，人们会如何选择；&quot;, &quot;同时，人们又会如何看待错过。&quot; }; String[] text3 = { &quot;在开始和结束之间，选择了什么，又会错过什么，我还不知道。&quot; }; String[] text4 = { &quot;你会知道么？&quot; }; // for (String s : Trainspotting1) { document.add(new Paragraph(s, italic_fontChinese)); document.add(new Paragraph(&quot; &quot;, italic_fontChinese)); } for (String s : Trainspotting2) { document.add(new Paragraph(s, bold_fontChinese)); } document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); for (String s : Benjamin1) { document.add(new Paragraph(s, italic_fontChinese)); document.add(new Paragraph(&quot; &quot;, italic_fontChinese)); } for (String s : Benjamin2) { document.add(new Paragraph(s, bold_fontChinese)); } document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); for (String s : text1) { document.add(new Paragraph(s, bold_fontChinese)); } document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); for (String s : text2) { document.add(new Paragraph(s, bold_fontChinese)); } document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); for (String s : text3) { document.add(new Paragraph(s, bold_fontChinese)); } document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); for (String s : text4) { document.add(new Paragraph(s, bold_fontChinese)); } document.add(new Paragraph(&quot; &quot;, bold_fontChinese)); // String[] end = { &quot;Some people were born to sit by a river...&quot;, &quot;Some get struck by light...&quot;, &quot;Some have an ear for music...&quot;, &quot;Some are artists...&quot;, &quot;Some swim...&quot;, &quot;Some know buttons...&quot;, &quot;Some know Shakespeare...&quot;, &quot;Some are mothers...&quot;, &quot;And some people can dance...&quot; }; for (String s : end) { document.add(new Paragraph(s, bold_fontChinese)); } document.add(new Paragraph( &quot;by the way, some people can write code.你&quot;, impressFont)); // Chapter Paragraph title1 = new Paragraph(&quot;Chapter 1&quot;, italic_fontChinese); Chapter chapter1 = new Chapter(title1, 1); chapter1.setNumberDepth(0); Paragraph title11 = new Paragraph( &quot;This is Section 1 in Chapter 1中文&quot;, italic_fontChinese); Section section1 = chapter1.addSection(title11); Paragraph someSectionText = new Paragraph( &quot;This text comes as part of section 1 of chapter 1.&quot;); section1.add(someSectionText); someSectionText = new Paragraph(&quot;Following is a 3 X 2 table.&quot;); section1.add(someSectionText); // document.add(chapter1); // // 定义一个图片 Image jpeg = Image.getInstance(&quot;E:/01.jpg&quot;); // 图片居中 jpeg.setAlignment(Image.ALIGN_CENTER); document.add(jpeg); } catch (DocumentException de) { System.err.println(de.getMessage()); } catch (IOException ioe) { System.err.println(ioe.getMessage()); } // 关闭打开的文档 document.close(); } } 此上的文章转载别人的，觉得挺好就借鉴过来 原创部分 建立Document对象的实例 Document document = new Document(); 建立一个书写器(Writer)与document对象关联，通过书写器(Writer)可以将文档写入到磁盘中，filePath是pdf的生成路径 PdfWriter.getInstance(document, new FileOutputStream( filePath)); 新建一个字体，iText的方法STSongStf-Ligth 是字体，在BaseFont中设置之后，我们到处的pdf就可以兼容中文了。itext还有两种输出中文字体的设置， 1 使用iTextAsian.jar中的字体 BaseFont bfChinese = BaseFont.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;, false); - 2 使用Windows系统字体(TrueType) BaseFont.createFont(“C:/WINDOWS/Fonts/SIMYOU.TTF”, BaseFont.IDENTITY_H,BaseFont.NOT_EMBEDDED); 使用资源地址 BaseFont.createFont(&quot;/SIMYOU.TTF&quot;, BaseFont.IDENTITY_H,BaseFont.NOT_EMBEDDED);","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"JavaMail的简单使用(自测可以发邮件)","date":"2016-09-28T09:34:00.000Z","path":"zxh/20160928.html","text":"在很多项目中我们都会遇到发送邮件的功能 在很多项目中我们都会遇到发送邮件的功能，发送邮件其实还是很实用的，正好今天做项目需要实现，现在来简单的整理一下发送邮件的实现。 建立邮件与服务器之间的会话Properties props = new Properties(); props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); props.setProperty(&quot;mail.smtp.host&quot;, &quot;smtp.sina.com&quot;); props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); props.setProperty(&quot;mail.debug&quot;, &quot;true&quot;); Session session = Session.getInstance(props); 这里我使用的是sina的邮件服务器， props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);是指需要同smtp来实现验证登录 props.setProperty(&quot;mail.smtp.host&quot;, &quot;smtp.sina.com&quot;);指明用的是sina的服务器，自测目前QQ的服务器是收费的，sina的这个服务器免费，但是不能连续发送太多的邮件，否则会发送失败的 props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);这句必须有，这个是标识说后面我们用户名和密码验证成功后就可以发送邮件 props.setProperty(&quot;mail.debug&quot;, &quot;true&quot;);开启debug模式，是为了方便我们开发用的，有了这个我们在开发中在控制台上我们就可以看到邮件的发送详情及发送的状态，返回250状态码，说明发送成功。 Session session = Session.getInstance(props);拿到本次的会话，下面我们就可以发送邮件 创建邮件Message msg = new MimeMessage(session); 这里的msg就是我们的邮件，但是现在邮件还是空的，我们需要向里面添加文本，HTML，附件，主题。。。。。。信息。 第一步： 设置邮件的发送方`msg.setFrom(new InternetAddress(这里填你的邮件));` 第二部： 设置邮件的主题(主题就是邮件的主题，这个我就不解释了，如果上传附件这个也会是你下载的附件的压缩名称)msg.setSubject(&quot;培训班结业信息&quot;); 第三部： 设置邮件的附件，附件这里我们需要拿到附件在硬盘上的地址，这里我写了一个方法， ``` public static MimeBodyPart createAttachment(String fileName) throws Exception { MimeBodyPart attachmentPart = new MimeBodyPart(); FileDataSource fds = new FileDataSource(fileName); //得到数据源 attachmentPart.setDataHandler(new DataHandler(fds)); //得到附件本身并至入attachmentPart attachmentPart.setFileName(fds.getName()); return attachmentPart; //得到文件名同样放入BodyPart } ``` 然后我们通过这个方法就拿到这个附件，并加入到邮件里(msg) ``` MimeBodyPart attachment01 = createAttachment(filePath); MimeMultipart allPart = new MimeMultipart(&quot;mixed&quot;); allPart.addBodyPart(attachment01); msg.setContent(allPart); ``` 注明发送地址 ``` msg.setRecipient(RecipientType.TO, new InternetAddress(address)); ``` 发送邮件 这里拿到邮件了，邮件的主题，内容，附件都设置好了，下面我们做的就是发送邮件 ``` Transport trans = session.getTransport(); trans.connect(发送邮件的账号, 发送邮箱的密码); trans.sendMessage(msg, msg.getAllRecipients()); ``` http://download.csdn.net/detail/u013132051/9642347","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"建行项目随笔","date":"2016-09-26T07:56:00.000Z","path":"zxh/20160926.html","text":"项目框架比较老，里面用法很原始，其中我写了一个html界面通过js那地址栏参数的方法 项目框架比较老，里面用法很原始，其中我写了一个html界面通过js那地址栏参数的方法 ``` //获取地址参数 function GetQueryString(name) { var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null; } ``` 解析地址的一些操作 ``` var curWwwPath = window.document.location.href;// 获取当前网址，如：http://localhost:8083/uimcardprj/share/meun.jsp var pathName = window.document.location.pathname;// 获取主机地址之后的目录，如：uimcardprj/share/meun.jsp var pos = curWwwPath.indexOf(pathName); var localhostPaht = curWwwPath.substring(0, pos);// 获取主机地址，如：http://localhost:8083 var projectName = pathName.substring(0, pathName.substr(1).indexOf(&quot;/&quot;) + 1);// 获取带&quot;/&quot;的项目名，如：/uimcardprj var basePath = localhostPaht + projectName; if (top != self) { top.window.location.href = basePath + &quot;/sessiontimeout.html&quot;; } if (document.URL.indexOf(&quot;command&quot;) != -1) { top.window.location.href = basePath + &quot;/sessiontimeout.html&quot;; } ``` 最后这里的bathpath就是项目的地址 ftl文件中遍历list及取大小和下标 ``` &lt;#list menu as m1&gt;&lt;#-- 一级菜单开始 后台中map里的menu--&gt; &lt;div class=&quot;navList&quot;&gt; &lt;div class=&quot;dt-title&quot;&gt;&lt;h3 &lt;#if m1_index == 0&gt;class=&quot;navOn&quot;&lt;/#if&gt;&gt;&lt;b&gt;${m1.title}&lt;/b&gt;&lt;/h3&gt;&lt;/div&gt; &lt;div class=&quot;dd-title&lt;#if m1_index == 0&gt; dd-titleOn&lt;/#if&gt;&quot;&gt; &lt;ul class=&quot;list&quot;&gt;&lt;#-- 二级菜单开始 --&gt; &lt;#list m1.child as m2&gt; &lt;#if m1_index == 0 &amp;&amp; m2_index == 0&gt; &lt;script&gt; //获得当前人员第一个应该显示资源的路径 $(&quot;#startUrl&quot;).val(&quot;${m2.url}&quot;); &lt;/script&gt; &lt;/#if&gt; &lt;li url=&quot;${m2.url}&quot; &lt;#if m2_index == 0&gt;class=&quot;navActiveOn&quot;&lt;/#if&gt;&gt;&lt;img src=&quot;../images/newnavigator/icon/_${m1_index}_icon_${m2_index+1}.png&quot; /&gt;${m2.title}&lt;/li&gt; &lt;/#list&gt;&lt;#-- 二级菜单结束 --&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/#list&gt;&lt;#-- 一级菜单结束 --&gt; ``` jqgrid加载窗口 ``` jQuery(&quot;#_traningAClassLessonGrid&quot;).jqGrid({ url: jQuery.getBasePath() + &#39;/***/*****?flag=******&amp;***8=****&#39;, datatype: &quot;json&quot;, colNames:[&#39;ID&#39;, &#39;评估主题&#39;, &#39;评估类型&#39;,&#39;发布状态&#39;,&#39;开始时间&#39;,&#39;结束时间&#39;,&#39;结果明细&#39;,&#39;删除评估&#39;], colModel:[ {name:&#39;*&#39;,index:&#39;*&#39;, width:55, align:&#39;center&#39;,key:true,hidden:true}, {name:&#39;*&#39;, index:&#39;*&#39;, align:&#39;center&#39;}, {name:&#39;*&#39;, index:&#39;*&#39;, align:&#39;center&#39;}, {name:&#39;*&#39;, index:&#39;*&#39;, align:&#39;center&#39; ,hidden:false}, {name:&#39;*_*&#39;, index:&#39;*_*&#39;, align:&#39;center&#39;}, {name:&#39;*_*&#39;, index:&#39;*_*&#39;, align:&#39;center&#39;}, {name:&#39;*&#39;, index:&#39;*&#39;, align:&#39;center&#39;}, {name:&#39;*&#39;, index:&#39;*&#39;, align:&#39;center&#39;} ], width:933, height:250, rowNum:10, rowList:[10,20,30], pager: &#39;#_lessonBar&#39;, sortname: &#39;id&#39;, viewrecords: true, sortorder: &quot;desc&quot;, multiselect: false, jsonReader: { repeatitems : false }, rownumbers : true, caption: &quot;课程评优&quot;, afterInsertRow : function(rowid, data) { var type = data.TYPE; var ID=&quot;&#39;&quot;+data.ID+&quot;&#39;&quot;; var zt=&quot;&#39;&quot;+data.zt+&quot;&#39;&quot;; var code=&quot;&#39;&quot;+data.CODE+&quot;&#39;&quot;; if (data.status==1){ $(&quot;#_traningAClassLessonGrid&quot;).jqGrid(&#39;setCell&#39;, rowid, &#39;status&#39;, &#39;&lt;span style=&quot;cursor:pointer;&quot; onclick=&quot;_setEvaluteStatus(&#39;+ID+&#39;,0,&#39;+zt+&#39;)&quot;&gt;未发布&lt;/span&gt;&#39;, {color : &#39;blue&#39;}); }else if(data.status==0){ $(&quot;#_traningAClassLessonGrid&quot;).jqGrid(&#39;setCell&#39;, rowid, &#39;status&#39;, &#39;&lt;span style=&quot;cursor:pointer;&quot;&gt;已发布&lt;/span&gt;&#39;, {color : &#39;red&#39;}); } $(&quot;#_traningAClassLessonGrid&quot;).jqGrid(&#39;setCell&#39;, rowid, &#39;EVALUTETYPE&#39;, &#39;&lt;span&gt;课程评优&lt;/span&gt;&#39;, {color : &#39;blue&#39;}); $(&quot;#_traningAClassLessonGrid&quot;).jqGrid(&#39;setCell&#39;, rowid, &#39;DETAILLESSON&#39;, &#39;&lt;span style=&quot;cursor:pointer;&quot; onclick=&quot;_getDETAILLESSON(&#39;+ID+&#39;);&quot;&gt;结果明细&lt;/span&gt;&#39;, {color : &#39;blue&#39;}); $(&quot;#_traningAClassLessonGrid&quot;).jqGrid(&#39;setCell&#39;, rowid, &#39;REMOVELESSON&#39;, &#39;&lt;span style=&quot;cursor:pointer;&quot; onclick=&quot;_delTrainingClassLessonAndFaceLesson(&#39;+ID+&#39;);&quot;&gt;删除评估&lt;/span&gt;&#39;, {color : &#39;blue&#39;}); } }); ``` jqgrid查询 ``` var url = jQuery.getBasePath() + &#39;/command/TrainingClassAction?flag=getEvaluteSuperShow&amp;tc_id=${tc_id}&#39;; jQuery(&quot;#_traningAClassLessonGrid&quot;).jqGrid(&#39;setGridParam&#39;,{ url : url+&#39;&amp;begindateQueryFrom=&#39;+encodeURIComponent( $(&#39;#begindateQueryFrom&#39;).val())+&#39;&amp;begindateQueryTo=&#39;+encodeURIComponent( $(&#39;#begindateQueryTo&#39;).val())+&#39;&amp;enddateQueryFrom=&#39;+encodeURIComponent( $(&#39;#enddateQueryFrom&#39;).val())+&#39;&amp;enddateQueryTo=&#39;+encodeURIComponent( $(&#39;#enddateQueryTo&#39;).val()) ,page:1 }).trigger(&quot;reloadGrid&quot;); ``` 导航菜单的依据权限显示 - 首先拿到在前台需要的菜单数据 ``` Map map = nav.getMenuMap(user.getID());//获取菜单map 权限问题 权限分配 ``` - 数据库关联查询，角色表 用户表 用户角色关联表 资源表 资源角色关联表 - 查询该用户的角色对应的所有资源，将这些资源组成map返回 - 然后就是上面的那种在ftl中遍历list显示菜单了 一个项目中sql有的时候写的好，可以大大减轻代码量 原来： ``` int num=0; num+=updateEvaluteSuper(param); param.put(&quot;obj_id&quot;, param.get(&quot;id&quot;)); param.put(&quot;N_type&quot;, &quot;课程评优&quot;); param.put(&quot;obj_title&quot;, param.get(&quot;zt&quot;)); num+=saveNoticeSuper(param); List typeList = super.queryForList(&quot;trainingclass_sql.xml&quot;, &quot;base_getEvaluteSuper&quot;, param); List userList=new ArrayList(); for(int i=0;i&lt;typeList.size();i++){ Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) typeList.get(i); int type = (Integer) map.get(&quot;TYPE&quot;); param.put(&quot;EntityId&quot;, map.get(&quot;ENTITYID&quot;)); if(type==1){ //EntityID为岗位ID（User_Station） userList=super.queryForList(&quot;trainingclass_sql.xml&quot;, &quot;base_getUserStation&quot;, param); }else if(type==2) { //EntityID为部门ID（Tuser_group） userList=super.queryForList(&quot;trainingclass_sql.xml&quot;, &quot;base_getTuserGroup&quot;, param); }else if(type==3){ //Type=3，EntityID为职位ID（Tuser（Business）） } for(int j=0;j&lt;userList.size();j++){ Map&lt;String, Object&gt; userMap=new HashMap&lt;String, Object&gt;(); userMap=(Map&lt;String, Object&gt;) userList.get(j); param.put(&quot;tnotice_id&quot;, param.get(&quot;id&quot;)); param.put(&quot;id&quot;, UUIDTool.randomUUID()); param.put(&quot;user_id&quot;, userMap.get(&quot;user_id&quot;)); param.put(&quot;r_status&quot;, &quot;1&quot;); num+=super.update(&quot;trainingclass_sql.xml&quot;, &quot;base_saveNoticeUserSuper&quot;, param); } } return num; ``` - 但是我发现这么长的业务逻辑我只需要在sql上改改就行了。 修改的sql:（原来的sql就是一条一条查的简单sql语句） ``` SELECT US_ID AS userId FROM user_stationWHERE ID IN ( SELECT ENTITYID FROM tc_array_user WHERE TC_ID = ‘93acc5f6-3764-4dce-a299-e93ecb7ff702’ AND type = ‘1’ )UNION SELECT USER_ID AS userId FROM tuser_group WHERE GROUP_ID IN ( SELECT ENTITYID FROM tc_array_user WHERE TC_ID = ‘93acc5f6-3764-4dce-a299-e93ecb7ff702’ AND type = ‘2’ ) ``` 总结 ：以后一定要加强对sql的优化","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"JavaWeb配置详解(结合框架SpringMVC)","date":"2016-09-26T00:17:00.000Z","path":"zxh/20160926.html","text":"先说一说常识性的东西，我们的JavaWeb程序运行一开始走的是web.xml文件 详解先说一说常识性的东西，我们的JavaWeb程序运行一开始走的是web.xml文件，这是我们的核心文件，可以说没有web.xml文件我们就无法运行项目，这个文件长什么样子，读者自己新建一个web项目就行了。 web.xml &lt;display-name&gt;项目名&lt;/display-name&gt; 正常情况下我们会配置一些过滤器 filter，过滤器的意思就是在执行某件事件前先进行规范处理之后才能继续运行。我们常见的过滤器有编码过滤器、数据安全过滤器。下面贴一个公用的编码过滤器 ``` &lt;!-- 编码过滤 UTF-8 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; ``` 下面就是设置一些浏览器的读取问题，我们用浏览器打开文件的时候会发现如果是doc文件， 会用记事本打开，出现乱码， 但是如果在web.xml里面配置了类型，浏览器就会根据配置的类型自动调用相应的程序打开在 WEB.XML 配置常用文件类型 &lt;mime-mapping&gt; &lt;extension&gt;doc&lt;/extension&gt; &lt;mime-type&gt;application/vnd.ms-word&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;gif&lt;/extension&gt; &lt;mime-type&gt;image/gif&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;html&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;jnlp&lt;/extension&gt; &lt;mime-type&gt;application/x-java-jnlp-file&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;jpeg&lt;/extension&gt; &lt;mime-type&gt;image/jpeg&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;jpg&lt;/extension&gt; &lt;mime-type&gt;image/jpeg&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;js&lt;/extension&gt; &lt;mime-type&gt;application/x-javascript&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;pdf&lt;/extension&gt; &lt;mime-type&gt;application/pdf&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;png&lt;/extension&gt; &lt;mime-type&gt;image/png&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;rar&lt;/extension&gt; &lt;mime-type&gt;application/x-rar-compressed&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;txt&lt;/extension&gt; &lt;mime-type&gt;text/plain&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;xls&lt;/extension&gt; &lt;mime-type&gt;application/vnd.ms-excel&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;xml&lt;/extension&gt; &lt;mime-type&gt;text/xml&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;xul&lt;/extension&gt; &lt;mime-type&gt;application/vnd.mozilla.xul-xml&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;zhtml&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;zip&lt;/extension&gt; &lt;mime-type&gt;application/x-zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;mime-mapping&gt; &lt;extension&gt;zul&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; 这些事辅助配置，这些配置完了，下面我们就是配置框架的事情了，框架说白了就是servlet，所以我们就需要引用servlet来进行配置框架。 我们通过context-param 去加载spring配置文件 ``` &lt;!-- 加载spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 监听器 加载spring配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; ``` 加载配置文件后我们就剩下去启动框架了 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 可以自定义servlet.xml配置文件的位置和名称，默认为WEB-INF目录下，名称为[&lt;servlet-name&gt;]-servlet.xml，如spring-servlet.xml &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt;&amp;nbsp; 默认 &lt;/init-param&gt; 也可以像下面一样进行自定义位置和名称 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;里面正数越低启动优先级越高，但是里面是负数或者不填的时候，表明容器在该servlet被选择是采取加载 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 整个框架就配置好了，在web.xml文件中我们在配置一些错误界面，就会让整个系统变得更加的人性化。 根据错误编码跳转 &lt;error-page&gt; &lt;error-code&gt;403&lt;/error-code&gt; &lt;location&gt;/change/error_go.action&lt;/location&gt; &lt;/error-page&gt; 根据错误类型跳转 &lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到500.jsp页面处理。 --&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/change/error_go.action&lt;/location&gt; &lt;/error-page&gt; 最后就是系统的欢迎页 &lt;welcome-file-list&gt; &lt;welcome-file&gt;change/login_go.action&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; application.xml配置文件 启动注解配置 &lt;!-- 启动注解配置 --&gt; &lt;context:component-scan base-package=&quot;tm.change&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; 配置数据源 &lt;!-- 配置C3P0数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${c3p0.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${c3p0.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${c3p0.user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${c3p0.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:config/mybatis-config.xml&quot; /&gt; &lt;/bean&gt; 当然用之前需要引入数据库的配置 这个说白了就是properties文件，里面放置了数据连接的信息 然后就要处理mybatis的mapper接口(可以看成是dao层的处理) &lt;!-- 配置扫描mapper接口的处理 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;tm.change.dao&quot;/&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; 事务处理(可以看成是service层) 注册一个事务 &lt;!-- 配置事务操作 --&gt; &lt;bean id=&quot;myTxManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; 配置事务的通知(指定哪些方法会有事务管理) ``` &lt;!-- 事务的advisor --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;myTxManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- propagation事务传播行为 --&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; ``` - 切入点(在哪个里面具有事务) ``` &lt;!--aop实现 业务层 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* tm.change.service..*(..))&quot; id=&quot;txPointcut&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot; /&gt; &lt;/aop:config&gt; &lt;context:annotation-config /&gt; ``` 上述的事务是在service层上insert，update，delete*等这些方法具有事务 controller层(springmvc.xml文件) 配置视图解析器 ``` &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; ``` 设置上传文件的视图解析器 &lt;!-- 上传文件的视图解析器 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;20971520&quot; /&gt; &lt;/bean&gt; 配置拦截器，可以直接定义拦截所有请求，也可以自定义拦截路径 &lt;mvc:interceptors&gt; &lt;!-- 直接定义拦截所有请求 --&gt; &lt;bean class=&quot;com.wxisme.ssm.interceptor.IdentityInterceptor&quot;&gt;&lt;/bean&gt; &lt;!-- &lt;mvc:interceptor&gt; 拦截所有路径的请求 包括子路径 &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.wxisme.ssm.interceptor.IdentityInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; --&gt; &lt;/mvc:interceptors&gt; 配置一些绑定如日期邦迪 &lt;!-- 自定义参数类型绑定 --&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;!-- 日期类型绑定 --&gt; &lt;bean class=&quot;com.wxisme.ssm.controller.converter.DateConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 静态资源不加载问题的解决方法： 在web.xml文件中如何启动spring是设置拦截的url是如下的，那么只有以.action的请求会被拦截处理，一些静态资源不会被拦截，这种情况是正常的，但是有的人会设置springmvc的拦截地址是拦截任何地址，那么这个时候的静态资源也就会被拦截。这个时候我们系统就会因加载不到静态资源而无法显示界面 &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 遇到上述情况难道我们就没办法解决了吗，有的，看下代码 &lt;!-- 访问静态资源文件 --&gt; &lt;!-- &lt;mvc:default-servlet-handler/&gt; 需要在web.xml中配置--&gt; &lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot; /&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot; /&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot; /&gt; &lt;mvc:resources mapping=&quot;/imgdata/**&quot; location=&quot;/imgdata/&quot; /&gt;","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"面试框架部分总结","date":"2016-09-08T07:41:00.000Z","path":"zxh/20160908.html","text":"面试框架部分总结Struts2工作原理 struts2 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 只需要将这段代码放在web.xml文件中就会执行Struts2流程，下面慢慢谈1、struts2是如何启动的呢？Struts2通过我们上述的web.xml我们添加的过滤器里面StrutsPrepareAndExecuteFilter来启动的，在我们打开Tomcat的时候，会执行StrutsPreareAndExecuteFilter中init方法(里面还有 doFilter + destory + postInit三个方法) init 方法会去加载struts.xml文件,并将struts.xml配置文件中内容封装成javabean存放在内存中，之后在请求的时候，就会去这片内存中直接取，而不用每次都去struts文件中了。2、Struts核心控制器StrutsPrepareAndExecuteFilter的作用StrutsPrepareAndExecuteFilter主要负责拦截URL请求，我们在上面配置了/*意思就是我们这个struts将会拦截所有的请求，如果在配置文件里你没有设置拦截url这个，那么在strutsPrepareAndExecuteFilter中doFilter方法中就会默认拦截没有后缀名的或者是后缀名是.action的路径，其他就不会被struts2框架处理。 3、struts2配置文件加载的顺序。Struts.xml—-&gt;struts.properties常量可以定义在struts.xml文件中。也可以定义在struts.properties文件中，如果多个properties文件总值出现了重复，则后出现的覆盖之前的值Struts.xml文件的作用就是通知struts2框架加载与url对应的action资源4、struts2是如何管理action 的，好处？首先strutss使用包来管理action的，包的作用和java中的包的作用类似的(在配置文件中的package,指定继承struts-default)，我理解为给action一个大本营，意思就是所有的action都会放在这个包中统一管理。所以我们应该把一组业务逻辑放在一个包中。5、struts2中默认struts-default 包的作用是什么？a、Struts-default是struts内置的，他定义了struts2中的众多的拦截器和result类型，实现了很多struts2的核心的功能，如：从请求中把参数封装到action中文件上传和数据验证等等都是通过内置拦截器实现的当包继承了struts-default才能使用struts2为我们提供的这些功能b、struts-default是在struts-default.xm文件中定义的，struts-default.xml文件也是struts2中内置的配置文件，不用自己写，struts2会自动的加载这个配置文件的。c、通常每个包都是继承struts-default包的也就是说上诉不需要我们配置什么。只是一个流程6、struts2中的action的url访问路径由什么构成的？由两部分组成的：包的命名空间+action的名称【.action】7、在struts.xml文件中可以不为action制定class属性吗可以的，但是如果你不指定class,该action的class属性默认是 com.opensymphony.xwork2.ActionSupport如果没有给action制定method，默认执行的就是ActionSupport中的execute方法，该方法里就一句话 return “SUCCESS”:没有指定result的name 默认success没有指定类型Type 默认dispatcher在action中都会有一个默认的拦截器的引用： ;注意： 1.一旦我们为该包中的某个action显式指定了某个拦截器，则默认拦截器不会起作用，所以此时要显式的引进默认的拦截器； 2.每个包只能指定一个默认拦截器，每个默认拦截器只针对当前包下有效。 8、struts2拦截器的作用，拦截器与过滤器的区别拦截器是针对action的，他提供一种机制可以使开发者可以定义在action执行前后的代码块。也就是说拦截器在action工作前后工作，在前后我们开发者可以自己写进一些功能代码，减少代码冗余过滤器是拦截用户的请求的，范围大9、常见的拦截器alias 在不同请求之间将请求参数在不同名字件转换，请求内容不变chain让前一个Action的属性可以被后一个Action访问，现在和chain类型的result（）结合使用。 checkbox添加了checkbox自动处理代码，将没有选中的checkbox的内容设定为false，而html默认情况下不提交没有选中的checkbox。 cookies使用配置的name,value来是指cookies conversionError将错误从ActionContext中添加到Action的属性字段中。 createSession自动的创建HttpSession，用来为需要使用到HttpSession的拦截器服务。 debugging提供不同的调试用的页面来展现内部的数据状况。 execAndWait在后台执行Action，同时将用户带到一个中间的等待页面。 exception将异常定位到一个画面 fileUpload提供文件上传功能 i18n记录用户选择的locale logger输出Action的名字 store存储或者访问实现ValidationAware接口的Action类出现的消息，错误，字段错误等。 model-driven如果一个类实现了ModelDriven，将getModel得到的结果放在Value Stack中。 scoped-model-driven如果一个Action实现了ScopedModelDriven，则这个拦截器会从相应的Scope中取出model调用Action的setModel方法将其放入Action内部。 params将请求中的参数设置到Action中去。 prepare如果Acton实现了Preparable，则该拦截器调用Action类的prepare方法。 scope将Action状态存入session和application的简单方法。 servletConfig提供访问HttpServletRequest和HttpServletResponse的方法，以Map的方式访问。 staticParams从struts.xml文件中将中的中的内容设置到对应的Action中。 roles确定用户是否具有JAAS指定的Role，否则不予执行。 timer输出Action执行的时间 token通过Token来避免双击 tokenSession和Token Interceptor一样，不过双击的时候把请求的数据存储在Session中 validation使用action-validation.xml文件中定义的内容校验提交的数据。 workflow调用Action的validate方法，一旦有错误返回，重新定位到INPUT画面 N/A从参数列表中删除不必要的参数 profiling通过参数激活profi 参考网址：http://blog.csdn.net/huxian1234/article/details/17110211 Hibernate 1、Hibernate的配置文件：该文件以cfg.xml结尾2、配置文件主要存放了：数据的url地址+数据库的用户信息+缓存+mapping文件的配置路径3、mapping 该文件的后缀名：.hbm.xml class元素：定义一个实体类的映射信息。常用属性如下。name表示对象实体类的全限定名。table表示对应的数据库表名。 id元素：定义该属性到数据库表主键字段的映射。常用属性如下。name表示实体类属性的名字。type表示实体类属性的类型。column 表示数据库表字段的名字，也可在子元素column中指定。generator 元素：id元素的子元素用于指定主键的生成策略。常用属性及子元素如下。class用来指定具体主键生成策略。param元素用来传递参数。常用主键的生成策略如下increment：对类型为long、short 或int 的主键，以自动增长的方式生成主键的值。主键按数值顺序递增，增量为1。identity：对如SQL Server、DB2、MySQL等支持标识列的数据库，可使用该主键生成策略生成自动增长主键，但要在数据库中将该主键设置为标识列。sequence：对如Oracle、DB2等支持序列的数据库，可使用该主键生成策略生成自动增长主键，通过子元素param传入数据库中序列的名称。 native：由Hibernate 根据底层数据库自行判断采用何种主键生成策略，意思是由使用的数据库生成主键的值。assigned：主键由应用程序负责生成，无需Hibernate参与。 property 元素：定义实体类中属性和数据库中表的字段的对应关系。常用属性如下。name表示实体类属性的名字。type表示实体类属性的类型。column 表示数据库表字段的名字，也可在子元素column中指定。 column 元素：用于指定其父元素代表的实体类属性所对应的数据库表中的字段。常用属性如下。name表示字段的名字。length表示字段长度。not-null设定是否可以为null，值为true 表示不能为null。4、加载配置文件// 1.加载配置文件 hibernate.cfg.xml StandardServiceRegistryregistry = new StandardServiceRegistryBuilder() .configure()// configures settings from hibernate.cfg.xml .build(); try{ //2.SessionFactory工厂对象 SessionFactorysessionFactory = new MetadataSources(registry) .buildMetadata().buildSessionFactory(); //3.获取工厂中关于session对象 Sessionsession = sessionFactory.openSession(); //4.session对象 Useruser1 = session.get(User.class, 2); //session的缓存 Useruser2 = session.get(User.class, 1); System.out.println(user1); System.out.println(user2); //5.释放资源 session.close(); }catch (Exception e) { e.printStackTrace(); //The registry would be destroyed by the SessionFactory, but we had //trouble building the SessionFactory //so destroy it manually. StandardServiceRegistryBuilder.destroy(registry); } 5、get和load的区别Get不支持延时加载 而load支持当查询特定的数据库不存在的数据时，get返回null，而load会抛异常6、为什么加载主键的时候不需要发出sql语句。 因为主键ID并不是实体的属性，在用hibernate加载的时候，只会产生该对象的代理对象，代理对象里属性都是默认值，当你真正的调用属性的时候才会从数据库中加载数据7、缓存缓存介于应用程序和永久性数据存储源之间使用缓存，可以降低应用程序直接读写永久性数据的频率，提高运行性能8、hibernate提高两个级别的缓存a) Session级别的缓存:属于事物级别的缓存，由hibernate管理，一般情况无需进行干预b) Sessionfactory级别的缓存。属于进程范围的缓存，sessionFactory缓存也可以分为两类i. 内置缓存：hibernate自带的，不可卸载。通常在hibernate的初始化阶段，hibernate会把映射元数据和预定义sql语句放到sessionFactory的缓存中，映射元数据是映射文件中的数据的复制，而预定义sql语句是hibernate根据映射元数据推到出来的sql语句ii. 外置缓存：一个可配置的缓存插件，默认情况hibernate不会启用 Spring http://www.php100.com/html/it/focus/2014/0603/6931.html","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"eclipse插件——maven","date":"2016-09-05T06:19:00.000Z","path":"zxh/20160905.html","text":"项目开发中遇到的问题 项目开发中遇到的问题 都是同样的代码，为什么在我的机器上可以编译执行，而在他的机器上就不行？ 为什么在我的机器上可以正常打包，而配置管理员却打不出来? 项目组加入了新的人员，我要给他说明编译环境如何设置，但是让我挠头的是，有些细节我也记不清楚了 我的项目依赖一些jar包，我应该把他们放哪里？放源码库里？ 这是我开发的第二个项目，还是需要上面的那些jar包，再把它们复制到我当前项目的svn库里吧 现在是第三次，再复制一次吧 —– 这样真的好吗？ 我写了一个数据库相关的通用类，并且推荐给了其他项目组，现在已经有五个项目组在使用它了，今天我发现了一个bug，并修正了它，我会把jar包通过邮件发给其他项目组,这不是一个好的分发机制，太多的环节可能导致出现bug 项目进入测试阶段，每天都要向测试服务器部署一版。每次都手动部署，太麻烦了 什么是maven Maven的概念 maven翻译为“专家”，“内行”。Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。 Maven是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。 Maven主要有两个功能： 项目构建 依赖管理 ##什么是构建 ## 为什么使用maven? Eclipse手工操作较多，编译、测试、部署等工作都是独立的，很难一步完成每个人的IDE配置都不同，很容易出现本地代码换个地方编译就出错 Ant没有一个约定的目录结构必须明确让ant做什么，什么时候做，然后编译，打包没有生命周期，必须定义目标及其实现的任务序列没有集成依赖管理 Maven拥有约定，知道你的代码在哪里，放到哪里去拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮你处理其他事情 ##Maven模型 ## Maven的安装及配置下载maven 官方网站：http://maven.apache.org 本课程使用的maven的版本为3.0.5 Maven的安装 第一步：安装jdk，要求1.6或以上版本 第二步：解压maven的压缩包。解压目录最好不要有中文。 第三步：配置系统环境变量，MAVEN_HOME 第四步：设置环境变量Path，将%MAVEN_HOME%\\bin加入Path中，一定要注意要用分号；与其他值隔开 第五步：5.验证安装是否成功，打开cmd窗口，敲入mvn -v 查看 Maven安装目录分析 bin：含有mvn运行的脚本 boot：含有plexus-classworlds类加载器框架。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更丰富的语法以方便配置，Maven使用该框架加载自己的类库。对于一般的Maven用户来说，不必关心该文件。 conf：含有settings.xml配置文件，此配置为maven的全局配置。 lib：含有Maven运行时所需要的java类库LICENSE.txt, NOTICE.txt, README.txt针对Maven版本，第三方软件等简要介绍 Maven的配置 Maven的默认配置 在MAVEN_HOME下的配置文件：MAVEN_HOME/conf/settings.xml 是maven全局的配置。如果不对其修改的话，默认本地仓库的路径就是：当前用户路径C:\\Users[UserName].m2 localRepository：用户仓库，用于检索依赖包路径 用户配置 配置方法： 1、在你想保存仓库的位置创建一个目录作为仓库目录。例如在d:盘创建一个MavenRepository目录 2、在其中创建一个名为“repository”的目录。 3、修改MAVEN_HOME\\conf\\settings.xml 4、从MAVEN_HOME\\conf中把settings.xml复制到MavenRepository目录。得到如下结构： ！注意：用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库，否则使用默认路径仓库 创建Maven工程 4.1 遵从Maven约定 src/main/java —— 存放项目的.java文件src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件src/test/java —— 存放所有测试.java文件，如JUnit测试类src/test/resources —— 测试资源文件target —— 项目输出位置pom.xml——maven项目核心配置文件 Project |-src | |-main | | |-java —— 存放项目的.java文件 | | |-resources —— 存放项目资源文件，如spring, hibernate配置文件 | |-test | |-java ——存放所有测试.java文件，如JUnit测试类 | |-resources —— 测试资源文件 |-target —— 目标文件输出位置例如.class、.jar、.war文件 |-pom.xml ——maven项目核心配置文件 4.2 第一步：创建maven工程 首先建立MavenHelloWorld项目同时建立Maven约定的目录结构 MavenHelloWorld |-src | |-main | | |-java —— 存放项目的.java文件 | | |-resources —— （暂时省略） | |-test | |-java ——存放所有测试.java文件，如JUnit测试类 | |-resources —— （暂时省略） |-target —— （不手工创建） |-pom.xml ——maven项目核心配置文件 4.3 第二步：创建HelloWorld.java 在src/main/java/cn/change/maven目录下新建文件Hello.java package cn.change.maven; public class HelloWorld { public String sayHello(String name){ return &quot;Hello World :&quot; + name + &quot;!&quot;; } } 4.4 第三步：新建测试文件HelloTest.java 在/src/test/java/cn/change/maven目录下新建测试文件HelloTest.java package cn.change.maven; import org.junit.Test; import static junit.framework.Assert.*; public class HelloWorldTest{ @Test public void testHello(){ HelloWorld hello = new HelloWorld(); String results = hello.sayHello(&quot;maven&quot;); assertEquals(&quot;Hello World :maven!&quot;,results); } } 4.5 第四步：创建pom.xml 在项目MavenHelloWorld根目录建立pom.xml &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bshinfo.el&lt;/groupId&gt; &lt;artifactId&gt;ccb_el_manager&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ccb_el_manager Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;finalName&gt;ccb_el_manager&lt;/finalName&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;4.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;4.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;4.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-cas&lt;/artifactId&gt; &lt;version&gt;4.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring mvc jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-paginator jar --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-spring jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql-connector-java jar --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 jar --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log jar --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.19&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jsp Template jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt; &lt;/dependency&gt; &lt;!-- apache servlet api jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;8.0.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- activemq --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;version&gt;5.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- cas security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- end of cas security --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 4.6 第五步：测试maven命令 打开cmd命令行，进入Hello项目根目录(包含有pom.xml文件的目录) 4.6.1 mvn compile命令 执行完毕后，生成了maven工程编译完成后字节码文件的生成目录target 执行 mvn compile命令 执行完毕后，生成了maven工程编译完成后字节码文件的生成目录target 4.6.2 mvn clean命令 cmd 中继续录入mvn clean命令 执行完毕后，字节码生成目录被删除 4.6.3 mvn test命令 cmd 中录入 mvn test命令 执行完毕后，字节码生成目录中生成了被测试类与测试类的编译字节码和测试执行过程日志与详细报告 4.6.4 mvn clean compile命令 cmd 中录入 mvn clean compile命令 组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类 4.6.5 mvn clean test命令 cmd 中录入 mvn clean test命令 组合指令，先执行clean，再执行test，通常应用于测试环节 4.6.6 mvn clean package命令 cmd 中录入 mvn clean package命令 组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前 执行过程： 清理————清空环境 编译————编译源码 测试————测试源码 打包————将编译的非测试类打包 4.6.7 mvn clean install命令 cmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中 组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前 执行过程： 清理————清空环境 编译————编译源码 测试————测试源码 打包————将编译的非测试类打包 部署————将打好的包发布到资源仓库中 4.6.8 错误范例说明：MAVEN 命令输入错误，命令名称显示在[ERROR] Unknown lifecycle phase “compoile”引号中的内容为输入错误的名称[ERROR] Unknown lifecycle phase “compoile”. You must specify a valid lifecycle phase or a goal in the format : or :[:]:. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources,generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -&gt; [Help 1] M2Eclipse 5.1 安装m2eclipse插件 Maven插件的位置，在参考资料\\eclipse插件目录下： 只需要把这两个文件件复制到Eclipse安装目录下的dropins目录下即可。 5.2 配置maven插件 查看maven插件是否安装成功：启动Eclipse→window→preference→Maven 2、设置maven环境，也就是指定maven的安装目录 3、加载用户配置 5.3 创建maven工程 5.3.1 第一个maven工程 第一步：选择new→maven→Maven Project 第二步：next 第三步：next 选择maven的工程骨架，这里我们选择quickstart。点击next。 第四步：next 输入GroupId、ArtifactId、Version、Package信息点击finish完成。 5.3.2 执行maven命令 在Eclipse的maven插件中执行maven命令，需要在maven工程或者pom.xml文件上点击右键，选择Run as→maven build. 5.3.3 第二个maven工程 5.3.3.1 创建工程 第一个工程创建时选用的是maven插件提供的工程骨架，每次选择骨架时都需要联网下载，如果网络不通或者较慢的情况下会有很长时间的等待。使用很是不方便，所以创建工程时可以不选择骨架直接创建工程。 第一步：新建maven工程 输入Groupid、artifactid、version三项内容，然后选择packaging也就是工程的打包格式，常用的打包格式为jar、war、pom三种。 第三步：点击finish完成。 5.3.3.2 修改pom文件 需求：在second工程中调用first工程中的First类的方法，然后测试。 ` 4.0.0 cn.changemaven-second 0.0.1-SNAPSHOT UTF-8 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 依赖maven-first工程 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.change&lt;/groupId&gt; &lt;artifactId&gt;maven-first&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; ` 5.3.3.3 创建Second.java package cn.change.second; import cn.change.first.First; public class Second { public String say(String name) { First first = new First(); String result = first.say(name); return result + &quot;:second&quot;; } } - 5.3.3.4 创建SecondTest.java package cn.change.sencond; import org.junit.Assert; import org.junit.Test; import cn.change.second.Second; public class SecondTest { @Test public void testSay() { Second second = new Second(); String result = second.say(&quot;张三&quot;); Assert.assertEquals(&quot;hello 张三:first:second&quot;, result); } } - 5.3.3.5 测试工程 - ![这里写图片描述](http://img.blog.csdn.net/20160905135716735) - 如果maven-first工程没有安装则会出现以下错误： [INFO] Scanning for projects…[INFO][INFO] ————————————————————————[INFO] Building maven-second 0.0.1-SNAPSHOT[INFO] ————————————————————————[WARNING] The POM for cn.change:maven-first:jar:0.0.1-SNAPSHOT is missing, no dependency information available[INFO] ————————————————————————[INFO] BUILD FAILURE[INFO] ————————————————————————[INFO] Total time: 0.218s[INFO] Finished at: Fri Sep 25 15:06:00 CST 2015[INFO] Final Memory: 4M/15M[INFO] ————————————————————————[ERROR] Failed to execute goal on project maven-second: Could not resolve dependencies for project cn.change:maven-second:jar:0.0.1-SNAPSHOT: Could not find artifact cn.change:maven-first:jar:0.0.1-SNAPSHOT -&gt; [Help 1][ERROR][ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR][ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/DependencyResolutionException提示找不到maven-first的jar包。当系统运行时是从本地仓库中找依赖的jar包的，所以必须先将maven-first安装才能正常运行，需要在maven-first工程上运行 mvn install命令安装到本地仓库。 - 5.3.4 第三个工程 - 创建第三个工程此工程使用maven-second工程中的Second的方法，并测试。 - 5.3.4.1 创建工程 - ![这里写图片描述](http://img.blog.csdn.net/20160905135828749) - 5.3.4.2 修改pom文件 &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.change&lt;/groupId&gt; &lt;artifactId&gt;maven-third&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 依赖maven-first工程 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.change&lt;/groupId&gt; &lt;artifactId&gt;maven-second&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; - 5.3.4.3 依赖关系 - ![这里写图片描述](http://img.blog.csdn.net/20160905135916970) - 5.3.4.4 创建Third.java package cn.change.third; import cn.change.second.Second; public class Third { public String say(String name) { Second second = new Second(); String result = second.say(name); return result + &quot;:third&quot;; } } - 5.3.4.5 创建ThirdTest.java package cn.change.third; import org.junit.Assert; import org.junit.Test; public class ThirdTest { @Test public void testSay() { Third third = new Third(); String result = third.say(&quot;张三&quot;); Assert.assertEquals(&quot;hello 张三:first:second:third&quot;, result); } } Maven核心概念 Maven的核心概念包括：坐标、依赖管理、仓库管理、生命周期、插件和目标、聚合继承。 6.1 坐标 6.1.1 什么是坐标 groupId：定义当前Maven组织名称 artifactId：定义实际项目名称 version：定义当前项目的当前版本 packaging：定义该项目的打包方式，如果没有此项则默认为jar包。 6.1.2 Maven坐标主要组成 Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范拥有了统一规范，就可以把查找工作交给机器 6.1.3 Maven为什么使用坐标 `依赖声明主要包含如下元素： junit junit 4.10 test ` 6.2 依赖管理 其中依赖范围scope 用来控制依赖和编译，测试，运行的classpath的关系. 主要的是三种依赖关系如下： 1.compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效 2.test：测试依赖范围。只对于测试classpath有效 3.provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api 4.runtime:运行时提供。例如:jdbc驱动 5.import 6.system 如果Two中使用One，Three中使用Two则称Two是Three的直接依赖，而称One是Three的间接依赖。C-&gt;B B-&gt;AC直接依赖BC间接依赖A 6.3 生命周期 Maven生命周期就是为了对所有的构建过程进行抽象和统一。包括项目清理，初始化，编译，打包，测试，部署等几乎所有构建步骤。生命周期可以理解为构建工程的步骤。 在Maven中有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn cleaninstall site 运行所有这三套生命周期。 Maven三大生命周期 6.3.2.1 clean：清理项目 clean生命周期每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段： pre-clean 执行一些需要在clean之前完成的工作 clean 移除所有上一次构建生成的文件 post-clean执行一些需要在clean之后立刻完成的工作 mvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvnclean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。 - 6.3.2.2 default：构建项目 - Default生命周期Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：validate generate-sources process-sources generate-resourcesprocess-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目的源代码。process-classes generate-test-sources process-test-sourcesgenerate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。test-compile 编译测试源代码。 process-test-classes test使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package接受编译好的代码，打包成可发布的格式，如 JAR 。 pre-integration-test integration-testpost-integration-test verify install 将包安装至本地仓库，以让其它项目依赖。 deploy将最终的包复制到远程的仓库，以让其它开发人员与项目共享。 运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install的时候，代码会被编译，测试，打包。此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要。 - 6.3.2.3 site：生成项目站点 - Site生命周期 pre-site 执行一些需要在生成站点文档之前完成的工作site 生成项目的站点文档post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备site-deploy 将生成的站点文档部署到特定的服务器上 这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。 6.4 Maven插件 Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。每个插件都能实现一个功能，每个功能就是一个插件目标。Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。例如compile就是插件maven-compiler-plugin的一个插件目标","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"eclipse使用技巧","date":"2016-09-05T02:28:00.000Z","path":"zxh/20160905.html","text":"看全部点这里 var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1260311648'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s4.cnzz.com/z_stat.php%3Fid%3D1260311648' type='text/javascript'%3E%3C/script%3E\")); 看全部点这里 删除所有代码的注释 java通过正则表达式来实现：/*{1,2}[\\s\\S]?\\/ 删除空白行 ： ^\\s*\\n xml 通过正则表达式来实现：&lt;!-[\\s\\S]*?–&gt; 上面三种情况都是一种情况，我只需要列出一种情况！ 打开指定的文件（Ctrl+Shift+R） 有的时候我们在左侧中一时间找不到指定的文件这个时候用Ctrl+Shift+R 这个快捷键，这样可以快速的打开。 智能提示(设置) 是不是自己的电脑无法向我这样快速的智能提示，因为你的电脑进行设置，来细节说明！ 自动万能纠错（Ctrl+1）Ctrl+1 快速定位（Ctrl+L） 一键导入包（Ctrl+Shift+O）","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"做程序员你真的准备好了吗？","date":"2016-08-31T00:24:00.000Z","path":"zxh/20160831.html","text":"什么样的程序员才真正的叫程序员&lt;/ 什么样的程序员才真正的叫程序员 知道不断学习的程序员配得上程序员三个字 不会轻易说做程序员苦 不会说自己负责的模块有多复杂 不会说别人提的问题有多简单 知道不断学习的程序员配得上程序员三个字 &#160;&#160;下面我们来详细谈谈为什么我要着重提到这四点，首先我们要先从程员 的自身角度来考虑，大家都知道程序员的更新特别的快，就好Android一样，版本更新的让程序员无法接受。你试想一下，辛辛苦苦学了三个月的 Android终于搞清楚里面的。所以注定我们要不断地优化自己的能力，我们的知识是不断地变更的。总结一句话就是与时俱进，只有这样我们才能在计算机领域长久的发展下去。所以说我们要懂得不断学习！ &#160;&#160;这篇文章我也是准备了好久，因为现在自己就是程序员，有的时候看到公司里面有些人的状态真的替他们忧心，稍有所成就就在沾沾自喜，我只觉得这样的人也就只能走到这一步了。因为看到他们的这种状态，所以我才更加的警戒自己要时刻的保持冷静，要懂得不断地学习新知识，不断拉开与他们之间的距离。这才是，这才是王道！&#160;&#160;另外从长远的角度来看，我们学习新知识不仅仅是为了获取新知识，而是为了培养自己接受新知识的能力，接触新知识能力会随着你不断地学习而变得不断地强大。这种能力并不是想获得就获得，这种能力也并不是仅仅局限于编程的，我们有了这个能力对我们的未来有很大的帮助，这样我们甚至以后转行都是横轻而易举的事。顺便再这说一句，有些程序员会说整天对着电脑会很累，会说四十岁以后就不在干了。我只想对这种人说一句，干什么都不会轻松的，重要的是兴趣，只要你对当前的事感兴趣你就不会再觉得他累了。说道这里有些刚入门的同学可能会问我想学习编程，但我不知道该看些什么语言。基于这个问题我之后会抽空整理一下，发布博客的！ &gt; 不会轻易说做程序员苦 &#160;首先问大家，你们觉得世上有既轻松又高薪的行业吗。所以说不要动不动就说程序员有多苦有多累，你要是觉得程序员超荷工作你就别干程序员啊。我个人觉得程序员并没有别人口中说的那么累。我们工作要学会从中体会乐趣，这样我们才能生活的更加美好。比如说我吧，我平时就对变成敢兴趣，编写一个小程序就好像高中解开一道数学题一样兴奋，这就是兴趣的作用，在对计算机有兴趣的前提下，我们变成将是事半功倍。还拿我的同事说事吧，我们公司A同事，经常就在发牢骚说自己的周任务量很多很烦，在说这话的时候为什么ta就不知道看看别人同等级的比他的任务多了很多，甚至比他还多别人都不会说一句牢骚的，听到这种话，我只想对ta说一句，太年轻！还有一种情况在任务很多的时候或者是出现某人请假，需要有人顶替请假的人完成他未完成的任务，当找到我这个A同事的时候，我这个A同事会说经理我这周任务很烦，而且他写的东西我也不熟悉，你还是别让我接手他的东西，找别人行不行！这个时候我真的无语了，经理找你就是觉得你有能力，你推脱就是说明你懒，其次就是你不熟悉难道别人就会比你熟悉这个请假的人的模块实现吗。还是那句话，太年轻！言归正传，总是说程序员累，那说这句话的人有没有想过是程序员真的太累还是你的方法不对呢！ 不会说自己负责的模块有多复杂 &#160;这个问题我在上面那个模块应该说了他的严重性。程序员不仅仅各司其职， “来者不拒”，只有这样我们才是地地道道的程序员，程序本身就是个繁琐的东西，不管我们负责的是什么，都会有其中难解决的部分，如果仅因为如此我们就选择退缩，那我还是那句话，太年轻！有的人负责了模块内容少但是逻辑上很难，就会有人抱怨这个超出自己能力了，这个不好做。等给他换个工作，任务本身不麻烦，但是有很多模块是重复的，这时候又会说这东西烦死了，做的整个人没了兴趣，这种程序员注定只能是编代码的程序员！ &gt; 不会说别人提的问题有多简单 &#160;还有一种程序员就和上面几种完全相反，他是那种动手能力很强，但是不尊重别人的程序员，有的时候回嘲笑别人说的问题，殊不知谁不是从基地开始干起，所以作为一个高级程序员我们不应该去嘲笑别人的问题简单，谁都有犯傻的时候。这里我自我批评一下，因为我觉得我在某种程度上就是这种的，自己不会的问题我会表现的很好，但当面对别人提出的对我而言的是简单的问题的时候我就会不自觉的至少从心里是抵触这种问题的，这种作风我会慢慢的改进。其他关于程序员的道德还有很多，这里我就不说了，我只是在这里抒发抒发自己的认识。同时也是变相的对自己的勉励。 &#160; 在未来的五年里，正是我们拼搏的好时机 ，相信自己，在程序员的道路上越走越长久！ 理想 人生 未来 程序员 JavaWeb Android Python 汇编语言 易语言 C语言","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"SSM框架的详细解说","date":"2016-08-30T06:03:00.000Z","path":"zxh/20160830.html","text":"使用SSM（Spring、SpringMVC和Mybatis）已经有三个多月了 文章转载自：http://blog.csdn.net/zhshulin 使用SSM（Spring、SpringMVC和Mybatis）已经有三个多月了，项目在技术上已经没有什么难点了，基于现有的技术就可以实现想要的功能，当然肯定有很多可以改进的地方。之前没有记录SSM整合的过程，这次刚刚好基于自己的一个小项目重新搭建了一次，而且比项目搭建的要更好一些。以前解决问题的过程和方法并没有及时记录，以后在自己的小项目中遇到我再整理分享一下。这次，先说说三大框架整合过程。个人认为使用框架并不是很难，关键要理解其思想，这对于我们提高编程水平很有帮助。不过，如果用都不会，谈思想就变成纸上谈兵了！！！先技术，再思想。实践出真知。（可通过图片水印查看博客地址） 1、基本概念 1.1、Spring Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 1.2、SpringMVC Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 1.3、MyBatis MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 2、开发环境搭建 如果需要，参看之前的博文：http://blog.csdn.net/zhshulin/article/details/30779873 3、Maven Web项目创建 如果需要，参看之前的博文：http://blog.csdn.net/zhshulin/article/details/37921705 4、SSM整合 下面主要介绍三大框架的整合，至于环境的搭建以及项目的创建，参看上面的博文。这次整合我分了2个配置文件，分别是spring-mybatis.xml，包含spring和mybatis的配置文件，还有个是spring-mvc的配置文件，此外有2个资源文件：jdbc.propertis和log4j.properties。完整目录结构如下（最后附上源码下载地址，不建议直接使用源码，因为此教程已经有了全部代码）： 使用框架都是较新的版本： Spring 4.0.2 RELEASE Spring MVC 4.0.2 RELEASE MyBatis 3.2.6 4.1、Maven引入需要的JAR包 为了方便后面说的时候不需要引入JAR包，我这里直接给出所有需要的JAR包，这都是基本的JAR包，每个包的是干什么的都有注释，就不再多说了。 pom.xml [html] view plain copyprint?在CODE上查看代码片派生到我的代码片 &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4.2、Spring与MyBatis的整合 所有需要的JAR包都引入以后，首先进行Spring与MyBatis的整合，然后再进行JUnit测试，先看一个项目结构图： 4.2.1、建立JDBC属性文件 jdbc.properties（文件编码修改为utf-8）[html] view plain copyprint?在CODE上查看代码片派生到我的代码片 driver=com.mysql.jdbc.Driver url=jdbc:mysql://10.221.10.111:8080/db_zsl username=demao password=demao #定义初始连接数 initialSize=0 #定义最大连接数 maxActive=20 #定义最大空闲 maxIdle=20 #定义最小空闲 minIdle=1 #定义最长等待时间 maxWait=60000 4.2.2、建立spring-mybatis.xml配置文件 这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是自动扫描，自动注入，配置数据库。注释也很详细，大家看看就明白了。 spring-mybatis.xml [html] view plain copyprint?在CODE上查看代码片派生到我的代码片 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.cn.hnust&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/cn/hnust/mapping/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.cn.hnust.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 4.2.3、Log4j的配置 为了方便调试，一般都会使用日志来输出信息，Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 Log4j的配置很简单，而且也是通用的，下面给出一个基本的配置，换到其他项目中也无需做多大的调整，如果想做调整或者想了解Log4j的各种配置，参看我转载的一篇博文，很详细： http://blog.csdn.net/zhshulin/article/details/37937365 下面给出配置文件目录： log4j.properties [html] view plain copyprint?在CODE上查看代码片派生到我的代码片 #定义LOG输出级别 log4j.rootLogger=INFO,Console,File #定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录 log4j.appender.File.File = logs/ssm.log #定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB # 输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d{yyyy-MM-dd HH\\:mm\\:ss}][%c]%m%n 4.2.4、JUnit测试 经过以上步骤（到4.2.2，log4j不配也没影响），我们已经完成了Spring和mybatis的整合，这样我们就可以编写一段测试代码来试试是否成功了。 4.2.4.1、创建测试用表 既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，SQL语句为：[sql] view plain copyprint?在CODE上查看代码片派生到我的代码片 DROP TABLE IF EXISTS `user_t`; CREATE TABLE `user_t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(40) NOT NULL, `password` varchar(255) NOT NULL, `age` int(4) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; /*Data for the table `user_t` */ insert into `user_t`(`id`,`user_name`,`password`,`age`) values (1,&#39;测试&#39;,&#39;sfasgfaf&#39;,24); 4.2.4.2、利用MyBatis Generator自动创建代码 参考博文：http://blog.csdn.net/zhshulin/article/details/23912615 这个可根据表自动创建实体类、MyBatis映射文件以及DAO接口，当然，我习惯将生成的接口名改为IUserDao，而不是直接用它生成的UserMapper。如果不想麻烦就可以不改。完成后将文件复制到工程中。如图： 4.2.4.3、建立Service接口和实现类 目录结构： 下面给出具体的内容： IUserService.jave [java] view plain copyprint?在CODE上查看代码片派生到我的代码片 package com.cn.hnust.service; import com.cn.hnust.pojo.User; public interface IUserService { public User getUserById(int userId); } UserServiceImpl.java [java] view plain copyprint?在CODE上查看代码片派生到我的代码片 package com.cn.hnust.service.impl; import javax.annotation.Resource; import org.springframework.stereotype.Service; import com.cn.hnust.dao.IUserDao; import com.cn.hnust.pojo.User; import com.cn.hnust.service.IUserService; @Service(&quot;userService&quot;) public class UserServiceImpl implements IUserService { @Resource private IUserDao userDao; @Override public User getUserById(int userId) { // TODO Auto-generated method stub return this.userDao.selectByPrimaryKey(userId); } } 4.2.4.4、建立测试类 测试类在src/test/java中建立，下面测试类中注释掉的部分是不使用Spring时，一般情况下的一种测试方法；如果使用了Spring那么就可以使用注解的方式来引入配置文件和类，然后再将service接口对象注入，就可以进行测试了。 如果测试成功，表示Spring和Mybatis已经整合成功了。输出信息使用的是Log4j打印到控制台。 [java] view plain copyprint?在CODE上查看代码片派生到我的代码片 package org.zsl.testmybatis; import javax.annotation.Resource; import org.apache.log4j.Logger; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.alibaba.fastjson.JSON; import com.cn.hnust.pojo.User; import com.cn.hnust.service.IUserService; @RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = {&quot;classpath:spring-mybatis.xml&quot;}) public class TestMyBatis { private static Logger logger = Logger.getLogger(TestMyBatis.class); // private ApplicationContext ac = null; @Resource private IUserService userService = null; // @Before // public void before() { // ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // userService = (IUserService) ac.getBean(&quot;userService&quot;); // } @Test public void test1() { User user = userService.getUserById(1); // System.out.println(user.getUserName()); // logger.info(&quot;值：&quot;+user.getUserName()); logger.info(JSON.toJSONString(user)); } } 测试结果： 至此，完成Spring和mybatis这两大框架的整合，下面在继续进行SpringMVC的整合。 4.3、整合SpringMVC 上面已经完成了2大框架的整合，SpringMVC的配置文件单独放，然后在web.xml中配置整合。 4.3.1、配置spring-mvc.xml 配置里面的注释也很详细，在此就不说了，主要是自动扫描控制器，视图模式，注解的启动这三个。 [html] view plain copyprint?在CODE上查看代码片派生到我的代码片 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;com.cn.hnust.controller&quot; /&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 4.3.2、配置web.xml文件 这里面对spring-mybatis.xml的引入以及配置的spring-mvc的Servlet就是为了完成SSM整合，之前2框架整合不需要在此处进行任何配置。配置一样有详细注释，不多解释了。 web.xml [html] view plain copyprint?在CODE上查看代码片派生到我的代码片 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 4.3.3、测试 至此已经完成了SSM三大框架的整合了，接下来测试一下，如果成功了，那么恭喜你，如果失败了，继续调试吧，作为程序员就是不停的与BUG做斗争！ 4.3.3.1、新建jsp页面 showUser.jsp 此页面仅输出一下用户名，完成一个完整的简单流程。 [html] view plain copyprint?在CODE上查看代码片派生到我的代码片 &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${user.userName} &lt;/body&gt; &lt;/html&gt; 4.3.3.2、建立UserController类 UserController.java 控制器 [java] view plain copyprint?在CODE上查看代码片派生到我的代码片 package com.cn.hnust.controller; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import com.cn.hnust.pojo.User; import com.cn.hnust.service.IUserService; @Controller @RequestMapping(&quot;/user&quot;) public class UserController { @Resource private IUserService userService; @RequestMapping(&quot;/showUser&quot;) public String toIndex(HttpServletRequest request,Model model){ int userId = Integer.parseInt(request.getParameter(&quot;id&quot;)); User user = this.userService.getUserById(userId); model.addAttribute(&quot;user&quot;, user); return &quot;showUser&quot;; } } 4.3.3.3、部署项目 输入地址：localhost:8080/项目名称/user/showUser?id=1 至此，SSM三大框架的整合就完成了，在此基础上可再添加其他功能。 源码下载地址：http://download.csdn.net/detail/u012909091/7658611","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"算法之路——递归","date":"2016-08-24T00:14:00.000Z","path":"zxh/20160824.html","text":"递归大家都懂是什么意思，在现实生活中我们也很容易去操作 递归（recursion）：程序调用自身的编程技巧。 递归满足2个条件： 1）有反复执行的过程（调用自身） 2）有跳出反复执行过程的条件（递归出口） 递归大家都懂是什么意思，在现实生活中我们也很容易去操作，但是在程序员的世界递归确实是很多人都头疼的一大难题。我总结了递归特色的一句话：简约而不简单 本博主打算通过四个案列来详细的剖析递归里面的思想 阶乘算法 全排列算法 汉诺塔问题 斐波那契数列 阶乘 阶乘应该是递归里面比较简单的问题了，所以我放在第一个将，在这里并不是越往后的越难，我个人觉得斐波那契数列和阶乘是同级别的，都很简单，阶乘主要就是拿一个数不停的去和比自己小一的数据相乘，一直称到1为止。最后返回数字就是阶乘的数据。这个可以用循环也可以用递归，既然我们本章主题是递归，那我们就用递归来实现吧。 //阶乘 int recursive(int i) { int sum = 0; if (0 == i) return (1); else sum = i * recursive(i-1); return sum; } 全排列问题： 解法一、在数组里进行两两不重复交换，每次交换得到的新数组组成的数据就是全排列的一种情况。 这个有点类似我们排序中的冒泡排序。这个逻辑进行下去就是不断的交换，每次交换完成就会产生一组数据，我们只要输出就行了 //全排列 inline void Swap(int &amp;a,int &amp;b) { int temp=a; a=b; b=temp; } void Perm(int list[],int k,int m) { if (k == m-1) { for(int i=0;i&lt;m;i++) { printf(&quot;%d&quot;,list[i]); } printf(&quot;n&quot;); } else { for(int i=k;i&lt;m;i++) { Swap(list[k],list[i]); Perm(list,k+1,m); Swap(list[k],list[i]); } } } 解法二、对新数据进行遍历，遍历会拿到每一条数据，拿到数据我们在判断这个数据是否已经被使用了，是则抛弃，否则选择。在递归进入结束条件时，我们输出我们的新数据，最后跳出本条递归。跳出之后我们就该将最近选择的数据状态置为未使用状态，方便下一次遍历使用。这样就会形成全排列。 public static void Circle(Object[] arry,Object[] visit,Integer index){ if(index==arry.length){ //自己写的输出list集合的方法。读者自己写 outArry(resultArry); return ;//递归结束；开始想外层跳出 }else{ for(int i=0;i&lt;arry.length;i++){ if((Integer)visit[i]==0){ resultArry[index]=arry[i]; //将该数字置为选中状态，下次再配到该数字则弃用该数字 visit[i]=1; index++; Circle(arry, visit, index); index--; //跳出循环，应该讲最近使用的数字状态恢复为0 visit[i]=0; } } } } 解法二不足之处：在解法二中我将数组写死了，不能根据用户的变化而将记录数组进行改变，后来我进行改进，具体代码如下： private static List&lt;Object&gt; resultArry=new ArrayList&lt;Object&gt;(); private static List&lt;Integer&gt; state=new ArrayList&lt;Integer&gt;(); public static void Circle(Object[] arry,Integer index){ if(index==arry.length){ outList(resultArry); return ;//递归结束；开始想外层跳出 }else{ for(int i=0;i&lt;arry.length;i++){ if(state.get(i)==0){ resultArry.add(arry[i]); state.set(i, 1); index++; Circle(arry, index);//递归的体现 resultArry.remove(arry[i]); index--; state.set(i, 0); } } } } 效果对1、2、3进行全排列： 效果对1、2、3、4进行全排列： 汉诺塔问题 思路梳理： 上图中想实现a–&gt;b，我们必须先将a中上面两个盘子拿到借助柱子B上。那么下面我们要考虑的是如何将A中两个盘子保持顺序的拿到B上呢，这时我们就需要借助C柱来完成，这就需要用递归了。因为我们最终问题是将A上三个盘子借助B按顺序拿到C上，我将问题转换成了将A上的两个盘子借助C拿到B上。ABC在方法里我用1、2、3代替。如果我将方法设为public static void hanoi(int n,int p1,int p2,int p3)也就是说一开始我们调用的是hanoi(3,1,2,3)到我们里面进行分析后变为hanoi(2,1,3,2)（这里转化理解醉关键）下面我们就一层一层向内部挖掘，那么，我们该什么时候结束这个循环递归呢？答案当然是在A柱上就剩一个盘子的时候我们就结束了，也即是方法hanoi(1,1,2,3) 这个时候我们只用将A柱上的一个盘子直接拿到C盘上 还有一点就是在我们都执行过了，现在我们回到我第一次剖析的地方，这个时候我们已经成功的将A柱上两个盘子拿到了B柱上了。这个时候我们就可以将A柱上最后一个盘子拿到C盘上，拿完之后我们该做什么呢，拿完之后我们可以将问题看成将B柱上的两个盘子借助A柱按顺序拿到C柱上。用方法表示为hanoi(2,2,1,3),这部我们继续走上面的思想就会完成。 代码： public static void hanoi(int n,int p1,int p2,int p3) { if(1==n){ System.out.println(&quot;盘子从&quot;+p1+&quot;移动到&quot;+p3); } else { hanoi(n-1,p1,p3,p2); System.out.println(&quot;盘子从&quot;+p1+&quot;移动到&quot;+p3); hanoi(n-1,p2,p1,p3); } } 效果： 斐波拉契数列 斐波纳契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、…… 这个数列从第三项开始，每一项都等于前两项之和。 有趣的兔子问题： 一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？ 分析如下： 第一个月小兔子没有繁殖能力，所以还是一对； 两个月后，生下一对小兔子，总数共有两对； 三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，总数共是三对； …… 依次类推可以列出下表： 经过月数 幼崽对数 成兔对数 总体对数 0 1 0 1 1 0 1 1 2 1 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 11 55 89 144 12 89 144 233 //斐波那契 long Fib(int n) { if (n == 0) return 0; if (n == 1) return 1; if (n &gt; 1) return Fib(n-1) + Fib(n-2); } 近期本博主将主要更新算法一类的博文，可能更新进度会慢点！ 做最好的自己，每天进步一点点","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"谈谈我对Ext的认识，元芳，你怎么看","date":"2016-08-22T00:14:00.000Z","path":"zxh/20160822.html","text":"实用Ext第一步当然是引用jar包啦。 实用Ext第一步当然是引用jar包啦。 下载地址 在页面上加上div用于显示这也是必须的 &lt;div id=&#39;loginpanel&#39; &gt;&lt;/div&gt; 在js中我们肯定需要将Ext进行初始化，我们的Ext初始化仅需两步 Ext.QuickTips.init(); Ext.state.Manager.setProvider(newExt.state.CookieProvider()); 初始化Ext状态管理器，在Cookie中记录用户的操作状态，如果不启用，象刷新时就不会保存当前的状态，而是重新加载 象如果窗口中有用可拖动面板的话，你在拖动后如果启动了Ext.state.Manager.setProvider(new Ext.state.CookieProvider()),就算刷新后面板仍然会在你拖动后的位置。如果不启用的话是不是就会按照默认的排列方式排列 Ext的特点就是不需要jsp，我们所有的空间都在js中借助Ext来创建。现在我们来创建几个空间来看看效果吧 var loginNames = new Ext.form.TextField({ name : &#39;userName&#39;, width:140, allowBlank : false, maxLength : 16, fieldLabel : Label_Login.loginName, listeners : { &#39;specialkey&#39; : function(f, e) { if (e.getKey() == Ext.EventObject.ENTER) { loginForm.form.findField(&#39;password&#39;).focus( true, false); } } }, blankText : Label_Login.loginNameBlank // &#39;用户名不能为空&#39; // regex:/^[0-9a-zA-Z]{2,20}$/, // regexText:&#39;只能为两到二十位的大小写字母。&#39;, }); ###【脚注】上面代码详解点这里[^footnote] var loginPasswords = new Ext.form.TextField({ name : &#39;password&#39;, allowBlank : false, width:140, maxLength : 16, inputType : &#39;password&#39;, fieldLabel : Label_Login.loginPassword, listeners : { &#39;specialkey&#39; : function(f, e) { if (e.getKey() == Ext.EventObject.ENTER) { loginFunc(); } } }, blankText : Label_Login.loginPasswordBlank // 密码不能为空 // regex:/^.{1,}$/, // regexText:&#39;长度不能少于1位&#39; }); // &#39;登陆&#39;, var loginBtn = new Ext.Button({ name : &#39;loginBtn&#39;, anchor : &#39;100%&#39;, style : &#39;margin-left:25px;&#39;, text : Label_Button.login, handler : function(){ loginFunc(); } }); // &#39;取消&#39; var resetButton = new Ext.Button({ style : &#39;margin-left:25px;&#39;, anchor : &#39;100%&#39;, text : Label_Button.reset, handler : function(){ //loginForm.getForm().reset(); loginForm.form.findField(&#39;userName&#39;).setValue(&#39;请输入用户名&#39;); loginForm.form.findField(&#39;password&#39;).setValue(&#39;请输入密码&#39;); } }); // 定义loginForm panel var loginForm = new Ext.FormPanel( { //defaultType : &#39;textfield&#39;, id : &#39;login&#39;, labelWidth : 70, style : &#39;background:#ffffff;padding:25px 35px 30px 16px;&#39;, region : &quot;center&quot;, defaults : { border : false, allowBlank : false, msgTarget : &#39;side&#39; //blankText : &#39;该字段不允许为空&#39; }, waitMsgTarget : true, items : [loginNames,loginPasswords,{ layout :&#39;column&#39;, border : false, width : &#39;100%&#39;, items : [ { columnWidth : 0.73, border : false, layout : &#39;form&#39;, items : [ remPwdCheckBox ] }, { columnWidth : 0.27, border : false, layout : &#39;form&#39;, style : &#39;margin-top:3px;&#39;, html : &#39;&lt;a href=\\&quot;javascript:void(0);return false;\\&quot; onclick=\\&quot;getForgetPassword();\\&quot; style=\\&quot;font-size:11px;\\&quot;&gt;忘记密码？&lt;/a&gt;&#39; } ] },{ layout :&#39;column&#39;, border : false, width : &#39;100%&#39;, items : [ { columnWidth : 0.5, border : false, layout : &#39;form&#39;, items : [ loginBtn ] }, { columnWidth : 0.5, border : false, layout : &#39;form&#39;, items : [ resetButton ] } ] }] }); // cookie中有值,设置记住密码选中状态 // 并赋值给用户名与密码 if ((uName != null &amp;&amp; uName!=&#39;&#39;) &amp;&amp; (uPwd!=null &amp;&amp; uPwd!=&#39;&#39;)) { remPwdCheckBox.checked = true; isRememberPwd = true; loginForm.form.findField(&#39;userName&#39;).setValue(uName); loginForm.form.findField(&#39;password&#39;).setValue(uPwd); } var loginFunc = function() { if(loginForm.form.isValid()){ loginForm.getForm().submit( { url : path + &#39;/SysLogin/login.json?isRememberPwd=&#39;+isRememberPwd, success : function(form, action) { var result = action.result; if (result.success) { document.location=path+action.result.url; } else { Ext.Msg.alert(message.info,action.result.msg); loginForm.getForm().reset(); } }, failure : function(form, action) { if (action.failureType == &#39;server&#39;) { obj = Ext.util.JSON.decode(action.response.responseText); Ext.Msg.alert( message.loginFailure, obj.msg); } else { Ext.Msg.alert( message.warning, message.loginError);//&#39;认证服务器无法连接 &#39; } loginForm.getForm().reset(); }, waitMsg : Label_Login.waitMsg //&#39;正在登录，请稍候...&#39; }); } }; // 展示到登陆页面body中的面板 var panel = new Ext.Panel( { renderTo : &#39;loginpanel&#39;, layout : &quot;border&quot;, width : 525, height : 290, defaults : { border : false }, items : [ { region : &quot;north&quot;, height : 56, html : &#39;&lt;img src=&quot;&#39;+path+&#39;/resources/common/images/head.gif&quot;/&gt;&#39; }, { region : &quot;south&quot;, height : 56, html : &#39;&lt;img src=&quot;&#39;+path+&#39;/resources/common/images/foot.gif&quot;/&gt;&#39; }, { region : &quot;west&quot;, width : 253, html : &#39;&lt;img src=&quot;&#39;+path+&#39;/resources/common/images/left.gif&quot;/&gt;&#39; }, loginForm] }); Ext.get(&#39;loginpanel&#39;).setStyle(&#39;position&#39;, &#39;absolute&#39;).center(Ext.getBody()); loginForm.form.findField(&#39;userName&#39;).focus(true,false); }; Ext.onReady(login); function getForgetPassword(){ var userName = Ext.getCmp(&#39;login&#39;).form.findField(&quot;userName&quot;).getValue(); if(userName != null &amp;&amp; userName != &quot;&quot; &amp;&amp; userName != &quot;请输入用户名&quot; ){ Ext.Ajax.request({ url:path + &#39;/SysLogin/getForgetPassword.json&#39;, params:{userName:userName}, success:function(response){ var responseArray = Ext.util.JSON.decode(response.responseText); Ext.Msg.alert(&#39;警示&#39;,&quot;请你联系&quot;+responseArray.Affiliation+&quot;下的管理员找回密码！&quot;); }, failure:function(){ Ext.Msg.alert(&#39;错误&#39;,&#39;服务器出现错误请稍后再试！&#39;); } }); }else{ Ext.Msg.alert(&#39;错误&#39;,&#39;请确认账户是否存在！&#39;); } } 效果图 创建store var tab2store = new Ext.data.Store( { url : path + &#39;/SysKhyz/getKHyzInstallList.json?id=&#39; + id, reader : new Ext.data.JsonReader( { fields : [ &#39;ID&#39;, &#39;NAME&#39;, &#39;MODEL&#39;, &#39;TONS&#39;, &#39;NUM&#39;, &#39;PLACE&#39;, &#39;LINE_STATUS&#39; ], root : &#39;rows&#39;, totalProperty : &#39;total&#39; }) // autoLoad : true }); tab2store.load( { params : { start : 0, limit : pagesize } }); 加载grid var tab2_grid = new Ext.grid.GridPanel( { id : &#39;KhyzInstall&#39;, // title :&#39;站线信息&#39;, height : 500, trackMouseOver : true, region : &quot;center&quot;, layout : &#39;fit&#39;, anchor : &#39;100%&#39;, frame : false, stripeRows : true, loadMask : { msg : &#39;正在加载数据，请稍后.....&#39; }, ds : tab2store, sm : new Ext.grid.CheckboxSelectionModel( { singleSelect : false }), viewConfig : { forceFit : true }, columns : [ new Ext.grid.CheckboxSelectionModel(), new Ext.grid.RowNumberer(), { header : &#39;设备名称&#39;, sortable : true, width : 220, dataIndex : &#39;NAME&#39; }, { header : &#39;设备型号&#39;, sortable : true, width : 220, dataIndex : &#39;MODEL&#39; }, { header : &#39;吨位（t）&#39;, width : 220, sortable : true, dataIndex : &#39;TONS&#39; }, { header : &#39;数量&#39;, width : 220, sortable : true, dataIndex : &#39;NUM&#39; }, { header : &#39;配置地点&#39;, width : 220, sortable : true, dataIndex : &#39;PLACE&#39; }, { header : &#39;状态&#39;, width : 220, sortable : true, dataIndex : &#39;&#39;, renderer : function(v, p, r, i) { var s = r.get(&#39;LINE_STATUS&#39;); if (s == &#39;0&#39; || s == 0) { return &#39;待提交&#39;; } else if (s == &#39;1&#39; || s == 1) { return &#39;审批中&#39;; } else if (s == &#39;2&#39; || s == 2) { return &#39;已通过&#39;; } else if (s == &#39;3&#39; || s == 3) { return &#39;已驳回&#39;; } else { return &#39;&#39;; } } } ], bbar : new Ext.PagingToolbar( { pageSize : pagesize, store : tab2store, displayInfo : true, displayMsg : &#39;显示第{0}条到{1}条记录，一共{2}条&#39;, emptyMsg : &#39;没有发现记录&#39; }) }); 按钮事件 var addWin = new Ext.Window( { layout : &#39;fit&#39;, width : 1000, height : 400, plain : true, border : false, maximizable : true, title : &#39;新增&#39;, items : [ add_formpanel ], modal : true, shadow : true, resizable : false, closeAction : &#39;hide&#39;, maximizable : true, buttons : [ { id : &#39;SaveBtn5&#39;, text : &#39;保存&#39;, iconCls : &#39;save&#39;, disabled : false, handler : function() { Ext.getCmp(&#39;SaveBtn5&#39;).setDisabled(true); if (add_formpanel.form.isValid()) { add_formpanel .getForm() .submit( { url : path + &#39;/SysKhyz/savaKHyzInstall.json?TKHYZ_BASE_ID=&#39; + id + &#39;&amp;LINE_STATUS=0&#39;, method : &#39;POST&#39;, success : function( form, action) { Ext.MessageBox .alert( &quot;提示信息&quot;, &quot;信息保存成功！&quot;); tab2store .load( { params : { start : 0, limit : pagesize } }); addWin.hide(); Ext .getCmp( &#39;SaveBtn5&#39;) .setDisabled( false); }, failure : function( form, action) { Ext.MessageBox .alert( &quot;提示信息&quot;, &quot;服务器错误,请重试！&quot;); Ext .getCmp( &#39;SaveBtn5&#39;) .setDisabled( false); } }); } else { Ext.getCmp(&#39;SaveBtn5&#39;).setDisabled(false); } } }, { text : &#39;提报&#39;, iconCls : &#39;taskSend&#39;, handler : function() { if (add_formpanel.form.isValid()) { add_formpanel .getForm() .submit( { url : path + &#39;/SysKhyz/savaKHyzInstall.json?TKHYZ_BASE_ID=&#39; + id + &#39;&amp;LINE_STATUS=1&#39;, method : &#39;POST&#39;, success : function( form, action) { if (action.result.flag) { Ext.MessageBox .alert( &quot;提示信息&quot;, &quot;信息提报成功！&quot;); } else { Ext.MessageBox .alert( &quot;提示信息&quot;, &quot;提报流程出错,数据已保存！&quot;); } tab2store .load( { params : { start : 0, limit : pagesize } }); addWin.hide(); }, failure : function( form, action) { Ext.MessageBox .alert( &quot;提示信息&quot;, &quot;服务器错误,请重试！&quot;); } }); } } }, { text : &#39;关闭&#39;, iconCls : &#39;clear&#39;, handler : function() { addWin.hide(); } } ] }); 每天进步一点 [^footnote]: Label_Login.loginName系统字段，读者可以改成自己的文字listeners注册的监听，按下键盘回车就把屏幕焦点放到密码框blankText是右边错误提示信息","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"带你剖析WebGis的世界奥秘----Geojson数据加载(高级)","date":"2016-08-19T00:12:00.000Z","path":"zxh/20160819.html","text":"GeoJSON是一种对各种地理数据结构进行编码的格式。 前言：前两周我带你们分析了WebGis中关键步骤瓦片加载+点击事件（具体的看前两篇文章），下面呢，我带大家来看看Geojson的加载及其点击事件 Geojson数据解析 GeoJSON是一种对各种地理数据结构进行编码的格式。GeoJSON对象可以表示几何、特征或者特征集合。GeoJSON支持下面几何类型：点、线、面、多点、多线、多面和几何集合。GeoJSON里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。 一个完整的GeoJSON数据结构总是一个（JSON术语里的）对象。在GeoJSON里，对象由名/值对–也称作成员的集合组成。对每个成员来说，名字总是字符串。成员的值要么是字符串、数字、对象、数组，要么是下面文本常量中的一个：”true”,”false”和”null”。数组是由值是上面所说的元素组成。 GeoJSON集合特征： {&quot;type&quot;:&quot;FeatureCollection&quot;, &quot;features&quot;:[ {&quot;type&quot;:&quot;Feature&quot;, &quot;id&quot;:&quot;001&quot;, &quot;properties&quot;:{&quot;name&quot;:&quot;新华001&quot;}, &quot;geometry&quot;:{&quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;:[121.9850,42.6737]}}, {&quot;type&quot;:&quot;Feature&quot;, &quot;id&quot;:&quot;002&quot;, &quot;properties&quot;:{&quot;name&quot;:&quot;新华002&quot;}, &quot;geometry&quot;:{&quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;:[121.8345,42.4898]}}, {&quot;type&quot;:&quot;Feature&quot;, &quot;id&quot;:&quot;003&quot;, &quot;properties&quot;:{&quot;name&quot;:&quot;峰山1&quot;}, &quot;geometry&quot;:{&quot;type&quot;: &quot;LineString&quot;, &quot;coordinates&quot;:[[121.9850,42.6737],[121.8345,42.4898]]}}, {&quot;type&quot;:&quot;Feature&quot;, &quot;id&quot;:&quot;004&quot;, &quot;properties&quot;:{&quot;name&quot;:&quot;新华1001&quot;}, &quot;geometry&quot;:{&quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;:[128.9850,42.6737]}}, {&quot;type&quot;:&quot;Feature&quot;, &quot;id&quot;:&quot;005&quot;, &quot;properties&quot;:{&quot;name&quot;:&quot;新华1002&quot;}, &quot;geometry&quot;:{&quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;:[125.8345,42.4898]}}, {&quot;type&quot;:&quot;Feature&quot;, &quot;id&quot;:&quot;006&quot;, &quot;properties&quot;:{&quot;name&quot;:&quot;峰山2&quot;}, &quot;geometry&quot;:{&quot;type&quot;: &quot;LineString&quot;, &quot;coordinates&quot;:[[121.9850,42.6737],[125.8345,42.4898]]}}]} openlayers3代码加载 至于如何加载地图在第一篇的加载瓦片式地图已经提过了，看完第一篇的你应该知道我是将地图map交接给页面的div中，而map中包含了很多遮罩层，我现在加载GeoJSON就是在最上面的层上在加载url数据。 var vector = new ol.layer.Vector( { source : new ol.source.Vector( { // url: // &#39;http://openlayers.org/en/v3.17.1/examples/data/geojson/countries.geojson&#39;, url : &#39;./source/china.json&#39;, format : new ol.format.GeoJSON() }), style : selectStyleFunction }); 我这是引用本地准备好的数据（可以从服务器上获得，从服务器上只需要将url地址改写成服务地址），加载url完成后并不会在map中显示出来，我们还需要指定数据的显示样式，这里和之前瓦片是加载不同，样式很重要我调节了好久才调通的，这里我将封装在方法里。 方法的具体实现： var style; if(feature.getGeometry().getType()==&quot;Point&quot;){ style = [new ol.style.Style({ image : new ol.style.Circle( { fill : new ol.style.Fill( { color : &#39;rgba(255,255,0,0.4)&#39; }), radius : 2, stroke : new ol.style.Stroke( { color : &#39;black&#39;, width : 1 }) }), text : new ol.style.Text( { fill : textFill, stroke : textStroke, text : view.getZoom()&gt;5?(feature.getId()&gt;2?feature.get(&quot;name&quot;):&quot;&quot;):&quot;&quot; }) })]; }else if(feature.getGeometry().getType()==&quot;LineString&quot;){ if(view.getZoom()&lt;3){ return ; } style = [new ol.style.Style( { stroke : new ol.style.Stroke( { color : &#39;#CD950C&#39;, width : 2 }), text : new ol.style.Text( { fill : textFill, stroke : textStroke, text : view.getZoom()&gt;6?feature.get(&quot;name&quot;):&quot;&quot; }) })]; }else if(feature.getGeometry().getType()==&quot;Polygon&quot;){ style = [new ol.style.Style( { stroke : new ol.style.Stroke( { color : &#39;#FFE4B5&#39;, width : 3 }), text : new ol.style.Text( { fill : textFill, stroke : textStroke, text : feature.get(&quot;name&quot;) }) })]; }else if(feature.getGeometry().getType()==&quot;MultiLineString&quot;){ style = [new ol.style.Style( { stroke : new ol.style.Stroke( { color : &#39;black&#39;, width : 3 }) })]; } return style; 申明 里面有些参数没有进行申明，因为定义了全局变量，因为在之前的js中改的，所以并没贴出所有代码。这里需要完整代码的请CSDN上私信我或者在留言板上留言 效果欣赏 1、地图加载完毕 这里你看到的地图不是上次的了，这次这个地图就是GeoJSON里的数据，只不过将数据以图形化的形式展现在我们的面前，看到地图右上方的两个点和一条线了吗，那都是通过数据动态加载出来的，换句话来说就是，我只需要将GeoJSON里的数据进行修改一下，这个地图就不一样了，这很方便我们在后台修改地图。还有这个中国的框架也是数据里的，总之一句话你看到的这个地图里所有元素都是数据里设置的（除了样式） 2、放大缩小地图和之前效果一样，值得注意的是我在js中设置了显示级别，就是放大缩小的不同级别显示的数据也是不同的，比如说那条线吧，我设置在6级以上的才能看到，下面我缩小地图线就不见了，下面是消失了的并不是太小看不见的 3、在放大到一定级别我设置了点的周围显示点的名称！看效果 这里就是加载的效果，下面我们继续探讨。下面就是点击事件了，点击事件在上篇文章我是着重讲了原理及实现，而在新技术中我们的点击事件就很Easy了 点击事件 我们要在map中绑定事件，也就是注册事件 map.on(&#39;singleclick&#39;, mapClick); function mapClick(e) { var pixel = map.getEventPixel(e.originalEvent); var featureInfo = map.forEachFeatureAtPixel(pixel, function(feature, layer) { return { feature : feature, layer : layer }; }); var coordinate = e.coordinate; var hdms = ol.coordinate.toStringHDMS(ol.proj.transform(coordinate, &#39;EPSG:3857&#39;, &#39;EPSG:4326&#39;)); if (featureInfo !== undefined &amp;&amp; featureInfo !== null &amp;&amp; featureInfo.layer !== null) { if (featureInfo.feature.get(&quot;geometry&quot;).B.length == 2) { // alert(view.getZoom()); alert(hdms + &quot;\\n这里属于&quot; + featureInfo.feature.get(&quot;name&quot;) + &quot;点&quot;); } else if (featureInfo.feature.get(&quot;geometry&quot;).B.length == 4) { alert(hdms + &quot;\\n这里属于&quot; + featureInfo.feature.get(&quot;name&quot;) + &quot;线&quot;); alert(&quot;两端信息&quot; + featureInfo.feature.get(&quot;geometry&quot;).B); } else { // alert(hdms+&quot;\\n这里属于&quot;+featureInfo.feature.get(&quot;name&quot;)+&quot;省&quot;);//显示点击区域的 } console.log(&#39;打印选择要素&#39;); console.log(featureInfo.feature); console.log(&#39;打印选择要素所属Layer&#39;); console.log(featureInfo.layer); } else { alert(hdms + &quot;\\n这里不属于中国或者这里是大海&quot;);// 显示点击区域的 } } 在这里我需要讲解一下： 这里的featureInfo是我们在方法里拼接的（feature+layer）组成的，在if条件判断里我们featureInfo.feature.get(“geometry”).B.length == 2是判断feature里数字点的个数，大家想一想如果是点是不是有两个数字点，如果是线就是两个点也就是四个数字点，如果是区域的话那就是至少是超过4的偶数了，这样我们就可以区别出点线和区域了，这也就是说我们在这里就实现了之前很难解决的点线问题了，区域问题我们就不多加讨论了。 var hdms = ol.coordinate.toStringHDMS(ol.proj.transform(coordinate,&#39;EPSG:3857&#39;, &#39;EPSG:4326&#39;)); 这个是将坐标进行转换的，这个不多说 定位 在之前我们的定位就是以某个点中心显示并加上图标那就是所谓的定位，那么在我们的新技术中定位是不是有所改变呢？让我们来一探究竟。 如果你认为既然是新技术了就一定要有突破，那么我的回答可能会让你很失望，新技术里仍然是用上述的思想来实现定位的，但多多少少还是有不同的。 | 新旧对比 | openlayers2 | openlayers3 | |:————– |:————-|:—–| | 点击 | 获取经纬度查询 | 点线类别区分 | | 定位 | map中心显示 | view中心显示 | 由上图的表格我们可以看出我们的定位还是有所区别的，在新技术中我么能采用的是view中心显示法，什么叫view中心显示法呢，就是通过view来调用设置中心的方法。 view.setCenter(ol.proj.fromLonLat( [ Number(document.getElementById(&#39;jd&#39;).value), Number(document.getElementById(&#39;wd&#39;).value) ])); 其他常用的事件介绍 事件句柄 HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。 具体事件 属性 当以下情况发生时，出现此事件 FF N IE onabort 图像加载被中断 1 3 4 onblur 元素失去焦点 1 2 3 onchange 用户改变域的内容 1 2 3 onclick 鼠标点击某个对象 1 2 3 ondblclick 鼠标双击某个对象 1 4 4 onerror 当加载文档或图像时发生某个错误 1 3 4 onfocus 元素获得焦点 1 2 3 onkeydown 某个键盘的键被按下 1 4 3 onkeypress 某个键盘的键被按下或按住 1 4 3 此处参考的w3School 在我的地图中我就随便加了几个试试效果的。 var select = null; // ref to currently selected interaction // select interaction working on &quot;singleclick&quot; var selectSingleClick = new ol.interaction.Select(); // select interaction working on &quot;click&quot; var selectClick = new ol.interaction.Select( { condition : ol.events.condition.click }); // select interaction working on &quot;pointermove&quot; var selectPointerMove = new ol.interaction.Select( { condition : ol.events.condition.pointerMove }); var selectAltClick = new ol.interaction.Select( { condition : function(mapBrowserEvent) { return ol.events.condition.click(mapBrowserEvent) &amp;&amp; ol.events.condition.altKeyOnly(mapBrowserEvent); } }); var selectElement = document.getElementById(&#39;type&#39;); var changeInteraction = function() { if (select !== null) { map.removeInteraction(select); } var value = selectElement.value; if (value == &#39;singleclick&#39;) { select = selectSingleClick; } else if (value == &#39;click&#39;) { select = selectClick; } else if (value == &#39;pointermove&#39;) { select = selectPointerMove; } else if (value == &#39;altclick&#39;) { select = selectAltClick; } else { select = null; } if (select !== null) { map.addInteraction(select); select.on(&#39;select&#39;, function(e) { document.getElementById(&#39;status&#39;).innerHTML = &#39;&amp;nbsp;&#39; + e.target.getFeatures().getLength() + &#39; selected features (last operation selected &#39; + e.selected.length + &#39; and deselected &#39; + e.deselected.length + &#39; features)&#39;; }); } }; 到这里整个GeoJSON加载地图已经讲解完毕了，上述只是为了帮助各位梳理思路，并不是项目的完整代码，如果新入门的没有看明白，可以在博客下方留言，我会将源码发送给你。","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"带你剖析WebGis的世界奥秘----点和线的世界","date":"2016-08-13T09:40:00.000Z","path":"zxh/20160813.html","text":"前言 昨天写了好久的博文我没保存，今天在来想继续写居然没了，气死人啊这种情况你们见到过没，所以今天重新写，我还是切换到了HTML格式的书写上大笑。废话不多说了，我们现在就进入主题，上周我仔细研究了WebGis基于openlayers的显示问题，同事也略微的实现了地图上的点击事件当然啦，这周我们将细分为点和线的点击事件，如果读者有兴趣也可以自己研究区域的点击事件，说白了就是我们初中时候学的那个三维立体的思想，或者读者也可以私下找我交流。逻辑思想 （点）在处理这些点击事件中我突然想到一个很常见的思路，就是我通过点击来获取屏幕的坐标，然后在将屏幕的坐标转换成对应地图上的经纬度，拿到经纬度之后去和数据库里面一条一条匹配，最后从数据查到这个点了我就将这个点的信息给输出，如果我没有查到这个点就说明我没有点击到这个点上。但是值得注意的一点就是我们地图在屏幕上是很小的，是存在点击误差的，什么叫点击误差就是我们点击地图上的点我们肉眼上觉得是点击了点，但是实际上我们点击的那个点的坐标和地图上的那个点的坐标是存在一定的误差的，所以我为了实现肉眼上的点击点的事件，我在查找数据库的时候给定了一个我们肉眼默认的误差范围的，也就是说我在数据中并不是真正去查这个点，而是查询数据库中的点到我这个店的距离的，只要这个距离小于我指定的误差值，我就默认为这两个点是同一个点，这也就是我实现点的思路；那么问题来了如果我在地图上点击的时候出现了两个点都和我这个点的距离在我的误差范围之内呢，答案是肯定会的，那么有的读者会问，这个该怎么办呢。不用担心我有解决方法。在取到不止两个的情况下我们去距离最小的那一个，离的最近的我们默认选择这个点的（线）处理完点自然就是线了，在处理线的时候我一开始的思路就是拿角度去比对，如果是统一角度的就说明我们点击的点在这条线上面，如果不是统一角度就不在这条线上，这个方法后来我实行了，当然这个也是存在误差的，我指定好了误差之后就可行的，但是在性能上不好，没有在距离的方法有效，因为如果我们用角度的话，角度会根据大小的不同误差级别，也就是说角度本身就有误差，在加上我们的肉眼的误差这样就相当于放大了误差，所以最后在项目里我放弃了角度的方法，后来我换了一种思路，我可以求点到直线的距离啊，这样我就成功的将角度的问题转换成了上面的距离的问题了，而且高中我们都会用点到直线的距离公式，而且俩个点确定直线的方程我们也都会使用最后整理了一下就是下面的代码来实现球点到直线的距离，拿到了距离了就回归了我们上面的点的处理中了，我们只要指定误差范围就可以了。（总结）理论呢就是这么多，估计有的同学已经开始着急了，怎么还没有代码啊，个人觉得！授人以渔不如授人以渔。所以我在上面才唠叨半天，只要你们理解我的思路，下面的代码只需要有初中的水平就可以看得懂了。/续上/代码实现 1、在map地图上我们注册点击事件，唯一不同的是我们在这里自行区分点线map.events.register(“click”, map, function(e) { //编写点击事件} 2、获取屏幕坐标从而转向地理坐标var lonlat = map.getLonLatFromPixel(e.xy);3、通过地理坐标去和已有的数据进行匹配查询，这里说的已有数据是说数据库中已经存在的点和线的数据，我现在js模拟一下数据库的写法（data就是数据里的数据）if(data.length&gt;1){ var min=getDis(data[0].x, data[0].y, data[1].x, data[1].y, lonlat.lon, lonlat.lat); var index=0; for(var i=0;i&lt;data.length;i++){ if(i&lt;data.length-1){ var fx = data[i].x; var fy = data[i].y; var tx = data[i+1].x; var ty = data[i+1].y; } var dis = getDis(fx, fy, tx, ty, lonlat.lon, lonlat.lat); if(dis=min){ //在误差范围内，可以认为是同一线 var lineName = data[index].site_name+&quot;&gt;&quot;+data[index+1].site_name; //alert(lineName); $(&quot;#qds&quot;).val(lineName); }else{ searRailLine(lonlat.lon, lonlat.lat); } }else{ searRailLine(lonlat.lon, lonlat.lat); } 4、这里提到的getDis 和 judgediswc 还有searRailLine这几个方法都是自己去写的，他们的作用是分别计算点到直线的距离、点到直线距离和误差的比较、去真实数据库查找线的方法。下面进行这三个方法的讲解4-1、获得点到直线的距离，这个就是我们初高中经常用到的点到直线距离公式，自己稍加推到就可以看得懂了，这个没有什么技术含量，只有别把坐标位置放错了，就可以了，这个返回的dis就是我们需要的距离。这个算法我在数据里也封装好了，待会最后我会帖进来的。function getDis(fx,fy,tx,ty,lon,lat){ var dis = 637800.138 ( Math.abs( ( (ty - fy) lon ) + ( (fx - tx) lat ) + tx fy - ty * fx ) ) / ( Math.pow( (ty - fy) * (ty - fy) + (fx - tx) * (fx - tx), 0.5 ) ); return dis; }4-2、误差的大小（由于地图的缩放级别不同，我们的误差也不同，这个在前面的理论中我已经解释过了，这个就不多说了）这个就返回我们肉眼能够接受的误差最大值function judgediswc(level){ var dis=0; var angle=0; if(level==15){ dis=12; angle=42; }else if(level==14){ dis=16; angle=94; }else if(level==13){ dis=52; angle=149; }else if(level==12){ dis=69; angle=403; }else if(level==11){ dis=178; angle=479; }else if(level==10){ dis=294; angle=1093; }else if(level==9){ dis=682; angle=1449; }else if(level==8){ dis=1488; angle=4143; }else if(level==7){ dis=3521; angle=4617; }else if(level==6){ dis=6636; angle=5265; }else if(level==5){ dis=7051; angle=30217; }else if(level==4){ dis=25763; angle=68126; }else if(level==3){ dis=60342; angle=120000; }else if(level==2){ dis=88189; angle=220000; }else if(level==1){ dis=110189; angle=1000000; } return angle;}4-3、下面的方法我们就是真正去数据库查找的，上面的方法没有实际用处，只是为了掩饰给读者的快捷方法（注意我ajax的传参 很重要）function searRailLine(lon,lat){ var sus = function(json, status) { //alert(); var lineName = json.map[0].station_name+”站”+”&gt;”+json.map[0].next_name+”站”; $(“#qds”).val(lineName); siteJson = json.map; }; AjaxUtil.ajaxCon(path + “/echartMap/selectLineNameStr.json”, {lon:lon,lat:lat,angle:judgediswc(map.getZoom())}, sus);}5、具体的三层架构实现我就不写了，相信能看到这里的孩子们三层架构一定都了解。我直接贴sql语句（x，y，z分别是经度、纬度、地图的显示级别）方法中返回的是点到直线的最小距离（有可能有很多个直线都是符合的我们取最小的那个） SELECT line_name, station_name, station_x, station_y, next_name, next_x, next_y, t FROM ( SELECT line_name, station_name, station_x, station_y, next_name, next_x, next_y, 637800.138 ( ABS( ( (station_y - next_y) #{x} ) + ( (next_x - station_x) * #{y} ) + station_x * next_y - station_y * next_x ) ) / ( POWER( (station_y - next_y) * (station_y - next_y) + (next_x - station_x) * (next_x - station_x), 0.5 ) ) AS t FROM rail_line ) AS t WHERE t &lt; #{angle} AND station_y &gt;= #{y} AND next_y &lt;= #{y} order by t asc limit 0,1 &lt;/select&gt; 6、有的读者会问了，说好的点和线呢，你的点呢，别着急啊，我先把难的讲完简单，点呢我就把sql语句贴出来，返回了距离的值，在后台你想怎么办就怎么办，那就看你自己了。对吧 &lt;![CDATA[ SELECT t.name FROM ( SELECT x.name, ROUND( 6378.138 2 ASIN( SQRT( POW( SIN( (#{y} PI() / 180 - y PI() / 180) / 2 ), 2 ) + COS( #{y} * PI() / 180) * COS(y * PI() / 180 ) * POW( SIN( ( #{x} * PI() / 180 - x * PI() / 180 ) / 2 ), 2 ) ) ) * 1000 ) AS dis FROM (select SITE_NAME name ,fx x,fy y from TKYZ_BASE UNION select SITE_NAME name,fx x,fy y from THYZ_BASE UNION select SITE_NAME name,fx x,fy y from TKHYZ_BASE UNION select SITE_NAME name,fx x,fy y from TYXHR_BASE UNION select SITE_NAME name,fx x,fy y from TBZQD_BASE)x ) AS t WHERE t.dis BETWEEN 0 AND #{z} order by t.dis asc limit 1 ]]&gt; &lt;/select&gt; 效果贴图 1、途中高亮显示的是模拟的js中的数据，点击高亮部分就会在脚本中查询我模拟的数据 2、点击高亮线路（北京–》北京南–》丰台）跳出相应的线路信息 3、点击非高亮地区会去查询数据库中的数据，就是真正的数据，如果点击在线上了也会弹出线的详细信息 4、如果我们点击在点上面就会 是点的相应信息，就不贴出来了，在高亮的线上我留个bug就是在线的延长线上也是认为在线上的，实际上不应该认为是线上，这点由于时间紧急我当时就没有写，读者有兴趣自己补充，提示一下判断点的位置是否在线的两端的中间就可以了，这个功能在点击非高亮线的sql语句我实现了的，可以参考一下。总结 研究了openlayers也有两周了，这两周学到的东西很多。学东西一定要从底层学，才可以学到真正的东西。openlayers的几个基本功能我都已经实现了（地图显示+点线点击事件+定位点+定位线+居中显示墨点+手型显示），其他一些实时定位并随地理位置变动而变动的这个功能没有去实现，因为就两周时间，也就这样了，之间走了很多的弯路，所以发出博文希望对学习WebGis的新同学有点帮助","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"带你剖析WebGis的世界奥秘----瓦片式加载地图","date":"2016-08-05T06:43:00.000Z","path":"zxh/20160805.html","text":"WebGIS应用程序的页面能够通过HTML、JSP、ASP或任何任何类型的Web页文件构成 WebGIS应用程序的页面能够通过HTML、JSP、ASP或任何任何类型的Web页文件构成，其特殊之处在于，它的请求提交的方法并不是通过常用的 “超链接”形式，而是使用鼠标与Web浏览器上地图进行的，因此，我们开发WebGIS应用程序的过程，就是考虑如何向一台Web服务器发送地图请求或其 它类型请求，并将响应进行解释显示的过程 加载瓦片最后我们是呈现出地图的形式，所以我们需要一个div带装在这个map，这个在前端很容易实现 &lt;div id=&quot;rcp2_map&quot; class=&quot;smallmap&quot; style=&quot;width: 100%; height: 100%;&quot;&gt;&lt;/div&gt; 有了这个我们的地图就有了安身之所，下面我们就开始我们的加载步骤，具体步骤我放在脚本里面，在定义map的时候我们我们需要两个参数，第一个是div的名称，第二个是map的一些设置 var options = { projection : &quot;EPSG:4326&quot;, center : new OpenLayers.LonLat(105.5, 39.5) }; var map = new OpenLayers.Map(&#39;rcp2_map&#39;, options); 有了map我们继续向map里面加入我们的瓦片也就是所谓的layer(层)关键是我们的层去哪里拿，我先贴个我服务上的数据地图代码 var wms = new OpenLayers.Layer.WMS(&quot;OpenLayers WMS&quot;, // geoserver所在服务器地址 // &quot;http://192.168.1.120:8080/geoserver/wms&quot;, &quot;http://192.168.1.15:8088/geoserver/china-rail/wms&quot;, { layers : &quot;china-rail:大公鸡&quot; }); 如果你没有在GeoService上发布过，你也不用着急，人家官网给你提供了数据，你可以从官网拿层来用 var wms= new OpenLayers.Layer.OSM(); 两种方式随便你选择，拿到图层我们只要进入map就行了 // 添加wms图层 map.addLayer(wms); 到此我们的地图就显示了，我们来看看想过吧，我拿的是我服务的地图，可以不怎么好看，我们只要效果 滚动鼠标滚动键放大地图显示 在地图显示方面我们可以设置的，比如说以什么地方中心显示呢，以多打的比例显示呢，设置中心点在上面的代码已经提到了，下面我贴个比例显示的代码 map.zoomTo(5); // 以第5级方式显示地图 有没有看到我上面地图左右下角的一些功能，相信你们现在是没有的，这些都是控制功能，需要我们手动加入 // 添加control空间 map.addControl(new OpenLayers.Control.LayerSwitcher()); map.addControl(new OpenLayers.Control.MousePosition()); map.addControl(new OpenLayers.Control.ScaleLine()); map.addControl(new OpenLayers.Control.Scale); 下面我们在看看点击Map事件和定位功能吧。 定位说白了就是以某个点中心显示，然后在把这个点给高亮标注出来我们先标注这个点在这支中心点 - 点击很容易只要我们注册一下事件就好了，我选择在Map控件上面注册这个点击事件，你们根据自己的需要选择控件注 //拿到坐标 var jd = Number(document.getElementById(&#39;jd&#39;).value); var wd = Number(document.getElementById(&#39;wd&#39;).value); if(document.getElementById(&#39;jd&#39;).value==&quot;&quot;){ jd=116.3; } if(document.getElementById(&#39;wd&#39;).value==&quot;&quot;){ wd=39.9; } //定义一个box层 var boxes = new OpenLayers.Layer.Boxes(&quot;Boxes&quot;); if (this.box != null) { this.box.display(false); //清除上一次的区域标记 } //定义一个Bounds bounds = new OpenLayers.Bounds(); //有参数生成两个经纬度 var lonlat1 = new OpenLayers.LonLat(jd, wd); var lonlat2 = new OpenLayers.LonLat(jd, wd); bounds.extend(lonlat1); bounds.extend(lonlat2);//生成一个经纬度范围的bounds box = new OpenLayers.Marker.Box(bounds); box.events.register(&quot;click&quot;, box, function(e) { this.setBorder(&quot;blue&quot;); });//注册box的点击事件 boxes.addMarker(box); map.addLayer(boxes); map.centerLayerContainer(lonlat1,6); map.panTo(lonlat1); //平移到范围的中心点 map.events.register(&quot;click&quot;, map, function(e) { var t=e; //获取经纬度 var lonlat = map.getLonLatFromPixel(e.xy); }); 研究了这个Openlayers好几天感觉这个显示的地图不好，不好确定具体信息，下面介绍一个升级版本OpenLayers3的技术 前面步骤一样，在注册map的时候有了不同 var raster = new ol.layer.Tile({ source: new ol.source.OSM() }); var vector = new ol.layer.Vector({ source: new ol.source.Vector({ url: &#39;./source/china.json&#39;, format: new ol.format.GeoJSON() }) }); var view = new ol.View({ // the view&#39;s initial state center: search, zoom: 5 }); var map = new ol.Map({ layers: [raster, vector], target: &#39;map&#39;, view: view }); 看看效果 双击放大地图显示 这里的定位和点击就草草说说了 点击 map.on(&#39;singleclick&#39;,mapClick); function mapClick(e){ var pixel = map.getEventPixel(e.originalEvent); var featureInfo = map.forEachFeatureAtPixel(pixel, function (feature, layer) { return {feature:feature,layer:layer}; }); var coordinate = e.coordinate; var hdms = ol.coordinate.toStringHDMS(ol.proj.transform( coordinate, &#39;EPSG:3857&#39;, &#39;EPSG:4326&#39;)); if (featureInfo!==undefined&amp;&amp;featureInfo!==null &amp;&amp;featureInfo.layer!==null) { alert(hdms+&quot;\\n这里属于&quot;+featureInfo.feature.get(&quot;name&quot;)+&quot;省&quot;);//显示点击区域的 console.log(&#39;打印选择要素&#39;); console.log(featureInfo .feature); console.log(&#39;打印选择要素所属Layer&#39;); console.log(featureInfo .layer); }else{ alert(hdms+&quot;\\n这里不属于中国或者这里是大海&quot;);//显示点击区域的 } } 定位 view.setCenter(ol.proj.fromLonLat([Number(document.getElementById(&#39;jd&#39;).value), Number(document.getElementById(&#39;wd&#39;).value)])); 里面用到的china.json数据下载地址：http://download.csdn.net/detail/u013132051/9595986 下面本人继续更新WebGis的后续精准操作","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"前端开发中快速掌握的技巧","date":"2016-07-23T08:28:00.000Z","path":"zxh/20160723.html","text":"之前开发过程中没有太在意前端方法的封装，最近在项目里看到别人封装的方法了，实在太有用了，自己总结了一下，好东西就应该共享一下 之前开发过程中没有太在意前端方法的封装，最近在项目里看到别人封装的方法了，实在太有用了，自己总结了一下，好东西就应该共享一下 表单验证非空： 以前我都是将需要验证的字段在js中拿到这个字段的变量，然后判断这个变量是否是空值的，相信你也是这样的，那么来看看改进之后的方法吧`/** 验证表单*/ function validForm() { var b = true; // 遍历页面中，所有符合条件的控件，eg：&lt;input type=&quot;...&quot; verify=&quot;decimal&quot; msg=&quot;用户名&quot;/&gt; $(&quot;body&quot;).find(&quot;*&quot;).each(function(){ if (typeof ($(this).attr(&quot;verify&quot;)) != &quot;undefined&quot;) { var data = $.trim($(this).val()); if (data.length &lt; 1) { // 数据为空时，消息提示 var msg = $(this).attr(&quot;msg&quot;) msg += &quot;，不能为空&quot;; $(this).focus(); alert(msg); b = false; return b; }else { // 合法校验 b = validData(data,$(this).attr(&quot;verify&quot;),$(this).attr(&quot;msg&quot;)); if (!b) { return b; } } } }); return b; }` - 封装了这个方法的好处在哪里，看到里面的遍历方法了，这个方法会遍历页面中所有符合条件的空间进行非空验证，你可能会说他是如何筛选这个条件的呢，看到verify了吗，我们只需要在jsp页面中在需要验证的控件上面填一个verify字段就行了，这个字段不需要附任何值，这就是告诉我，这个空间需要进行非空验证。这里我只是提了一个非空验证，如果验证一些其他规则的就可以在Verify中传值了，这个读者可以自行扩展一下，实现好了的，希望大家也可以发给我，让我瞅瞅。 - 下面贴个我们公司的大牛写了验`` /** * 验证基本数据格式，如果本方法未提供符合要求的验证，请自行添加，格式参照如下 */ function validData(value,type,msg){ // 验证数字： if (type == &#39;number&#39;) { var reg = /^[0-9]*$/ if (!reg.test(value)) { alert(msg+&quot;，不是数字&quot;); return false; } } // 验证Email地址： if (type == &#39;email&#39;) { var reg = /^w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$/ if (!reg.test(value)) { alert(msg+&quot;，格式不对&quot;); return false; } } // 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$或 var regMobile=/^1[3,5,8]\\d{9}$/; if (type == &#39;phone&#39;) { var reg = /^1[3,5,8]\\d{9}$/ if (!reg.test(value)) { alert(msg+&quot;，不是手机号码&quot;); return false; } } // 验证电话号码：：--正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。 if (type == &#39;telephone&#39;) { var reg = /^((d{3,4})|d{3,4}-)?d{7,8}$/ if (!reg.test(value)) { alert(msg+&quot;，不是电话号码&quot;); return false; } } // 验证身份证号（15位或18位数字）： if (type == &#39;ID&#39;) { var reg = /^d{15}|d{}18$/ if (!reg.test(value)) { alert(msg+&quot;，格式不正确&quot;); return false; } } // 非负浮点数（正浮点数 + 0）：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ if (type == &#39;decimal&#39;) { var reg = /^\\d+(\\.\\d{0,5})?$/ if (!reg.test(value)) { alert(msg+&quot;，格式不正确（数值类型，允许保留到小数点后5位）&quot;); return false; } } // 验证用户密码: 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。 if (type == &#39;password&#39;) { var reg = /^[a-zA-Z]w{5,17}$/ if (!reg.test(value)) { alert(msg+&quot;，格式不正确\\n正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线&quot;); return false; } } return true; } 在前端我们除了验证可能遇到最多的就是与后台数据的传递，以前我都是借助框架的封装来传递的，还有就是我自己手动拼接的json，现在来看一种封装指定控件的工具 /** * 获取需要保存的页面数据 * @returns json */ function getFormData() { var jsonArray = [], data = {}; // 遍历页面中，所有符合条件的input 输入类型控件，eg：&lt;input type=&quot;...&quot; column=&quot;columnA&quot;/&gt; $(&quot;input&quot;).each(function(i, e) { if (typeof ($(e).attr(&quot;column&quot;)) != &quot;undefined&quot;) { data[&quot;&quot; + $(e).attr(&#39;column&#39;)] = $(e).val(); } }); // 遍历页面中，所有符合条件的select 输入类型控件，eg：&lt;select column=&quot;columnA&quot;&gt;...&lt;/select&gt; $(&quot;select&quot;).each(function(i, e) { if (typeof ($(e).attr(&quot;column&quot;)) != &quot;undefined&quot;) { data[&quot;&quot; + $(e).attr(&#39;column&#39;)] = $(e).val(); } }); // 遍历页面中，所有符合条件的textarea 输入类型控件，eg：&lt;textarea column=&quot;columnA&quot;&gt;...&lt;/textarea&gt; $(&quot;textarea&quot;).each(function(i, e) { if (typeof ($(e).attr(&quot;column&quot;)) != &quot;undefined&quot;) { data[&quot;&quot; + $(e).attr(&#39;column&#39;)] = $(e).val(); } }); jsonArray.push(data); // 转译为字符串 ，以“dd”标识，用于后台controller接收，eg： &quot;[{&#39;columnA&#39;:&#39;valueA&#39;,&#39;columnB&#39;:&#39;valueB&#39;}]&quot; var jsondata = { &quot;zxh&quot; : JSON.stringify(jsonArray) }; return jsondata; } - 这个和验证是一样的，我将jsp中所有具有column属性的空间的值拿过来进行封装在json中，在json中的名称就是column字段属性的名称，最后将这个字符串返回出来，我们就可以在ajax中将这个字符串当做参数传递到后台，因为参数中的是zxh，所以我在后台中的接受就需要接受这个zxh,这样我们就拿到的jsp中的数据，在后台拿到数据了，作为程序员的你应该懂得 3加载jsp中的空间 比如现在我的jsp中有一个select空间，我在页面初始化的时候需要把后台的数据拿过来，你可以自己写，如果我说这个jsp中有100select 的话，你难道要一个一个写？答案当然是NO，还是一样我在jsp中给每个select 的column 属性赋值，然后我在通用函数中将传这个column的字段，这个函数就会将column这个select框加载到指定的select的位置上去，怎么样方便吧 /** * 加载 下拉框 * @param jsonArray */ function loadSelectData(jsonArray,select) { $(&quot;select[column=&#39;&quot;+select+&quot;&#39;]&quot;).empty(); $.each(jsonArray, function(i) { // 遍历下拉框数据 var data = jsonArray[i]; $(&quot;select[column=&#39;&quot;+select+&quot;&#39;]&quot;).append(&#39;&lt;option value=&quot;&#39;+data.ID+&#39;&quot;&gt;&#39;+data.NAME+&#39;&lt;/option&gt;&#39;); }); } 下面的方法我就不一一介绍了，总的来说就是不要仅仅局限于孔健中给我们提供 的那些属性，我们要善于自定义属性 4js操作cookie 你知道session和cookie吗，JavaWeb开发师最属性的两个东西，但是我们用的最多的就是在后台操作，在前台还是第一次听说吧，相信不少朋友都忘记js怎么操作cookie的了， 这里我们要用到document // 写cookie function _setCookie(key, value, time) { var strsec = getsec(time); var exp = new Date(); exp.setTime(exp.getTime() + strsec * 1); document.cookie = key + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString(); } 既然可以设定cookie的时间，必须有获取时间的方法 // 获取cookie时间 function getsec(str) { var str1 = str.substring(1, str.length) * 1; var str2 = str.substring(0, 1); if (str2 == &quot;s&quot;) { return str1 * 1000; } else if (str2 == &quot;h&quot;) { return str1 * 60 * 60 * 1000; } else if (str2 == &quot;d&quot;) { return str1 * 24 * 60 * 60 * 1000; } } 下面我们来获取cookie吧 // 获取cookie function _getCookie(key) { var arr, reg = new RegExp(&quot;(^| )&quot; + key + &quot;=([^;]*)(;|$)&quot;); if (arr = document.cookie.match(reg)) return unescape(arr[2]); else return null; } js既然想操作cookie那必须像Java一样，所以我们还差一个删除cookie的方法 // 删除cookie function _delCookie(key) { var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = _getCookie(key); if (cval != null) document.cookie = key + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString(); } 到这里cookie基本操作就这些，没了。下面我们来谈谈ajax,上面我们也提到了，封装的json是如何传入后台的呢，ajax，对就是他，网站开发中的王者，没了他我们就要失业了 ajax同步 async: false 就这一个属性就可以实现了，默认是true我们有的时候需要进行同步操作，只需要将async改为false就可以了 ajax异步 async: true 异步更简单写这句话，或者什么都不写就是异步 ajax会发送吗？不会？那我就没办法了$.ajax(url,param,success,error); 这是最基本的ajax，还有好多他的变形方法，读者可以百度一下或看一下手册就好了 前端美工是不可忽视的一种行业，在条CSS的时候最怕的就是浏览器版本问题，所以我们的知道我们的浏览器的版本 $(document).ready(function() { if (navigator.userAgent.match(/msie/i) ){ alert(&#39;I am an old fashioned Internet Explorer&#39;); } }); 元素固定在顶部 这个是很有用的，有时候我们的导航按钮就需要这样设计，还有我们的工具栏也是需要固定在顶部的 $(function(){ var $win = $(window) var $nav = $(&#39;.mytoolbar&#39;); var navTop = $(&#39;.mytoolbar&#39;).length &amp;&amp; $(&#39;.mytoolbar&#39;).offset().top; var isFixed=0; processScroll() $win.on(&#39;scroll&#39;, processScroll) function processScroll() { var i, scrollTop = $win.scrollTop() if (scrollTop &gt;= navTop &amp;&amp; !isFixed) { isFixed = 1 $nav.addClass(&#39;subnav-fixed&#39;) } else if (scrollTop &lt;= navTop &amp;&amp; isFixed) { isFixed = 0 $nav.removeClass(&#39;subnav-fixed&#39;) } } 用其他内容取代html标志 jQuery使得用另外一个东西取代html标志很简单。 `$(&#39;li&#39;).replaceWith(function(){ return $(&quot; &quot;).append($(this).contents()); });` 检测视窗宽度 这个也很重要，我们的用户有的喜欢小屏幕有的喜欢超大的，你的网站需要适合所有大小的屏幕这样才能赢得用户的好感var responsive_viewport = $(window).width(); 检测复制、粘贴和剪切的操作 你的网站如果不是那种要求高的，都是可以让用户赋值你网站上面的东西的， $(&quot;#textA&quot;).bind(&#39;copy&#39;, function() { $(&#39;span&#39;).text(&#39;copy behaviour detected!&#39;) }); $(&quot;#textA&quot;).bind(&#39;paste&#39;, function() { $(&#39;span&#39;).text(&#39;paste behaviour detected!&#39;) }); $(&quot;#textA&quot;).bind(&#39;cut&#39;, function() { $(&#39;span&#39;).text(&#39;cut behaviour detected!&#39;) }); 遇到外部链接自动添加target=”blank”的属性 现在网络的发展快，很多网站希望提高自己的访问量，会到一些知名网站上发送外链(我也经常干，但我都是发别人需要的，不是那种水军)，这样我们可以防止 var root = location.protocol + &#39;//&#39; + location.host; $(&#39;a&#39;).not(&#39;:contains(root)&#39;).click(function(){ this.target = &quot;_blank&quot;; }); 在文本或密码输入时禁止空格键 $(&#39;input.nospace&#39;).keydown(function(e) { if (e.keyCode == 32) { return false; } }); 页面显示也是前端的菜，显示中最常见的就是分页显示了，我们的数据可能是成千上万的数据，你想一次都展示吗，当然不，我们就炫耀用到分页，下面我简单介绍几种分页插件吧 jqPagination 是一个简单易用的轻量级 jQuery 分页插件，其使用了 HTML5 和 CSS3 技术来实现。此插件提供了几个参数设置选项，通过简单的配置即可生成分页控件。此外，它的外观样式是可自定义的，扩展性很强 这个是我用的最多的，读者可以结合我的另外一篇文章看看http://blog.csdn.net/u013132051/article/details/51753312 下面接不介绍了，分页只要懂就行，下面看看其他的分页的效果吧 +++++++++++++++++++++++++++++++++++++++++++ 下面我在讲讲显示的框架，我用的最多的是jQuery 、bootstrap里面显示数据的用的datagrid最多，最近用的是mmgrid,其实两者类似，只需要搞懂流程这些就不是事，给读者推荐这几个网址 mmGrid：http://miemiedev.github.io/mmGrid/examples/index.html datagrid:http://www.php1.cn/Article/index/id/6040 jQuery EasyUI:http://www.runoob.com/jeasyui/jqueryeasyui-intro.html bootstrap:http://www.runoob.com/bootstrap/bootstrap-tutorial.html 后续还会整理 《程序员常用网站简介》-一个网站为了实现友好，就得用到弹出层，下面贴几个弹出层的效果 这些弹层可以自己调节样式，也可以自己定义，下面简单说怎么使用这个插件 下载jar包(网址：http://sc.chinaz.com/tag_jiaoben/DanChuCeng.html) 解压文件然后将里面的js、css引入自己的项目中 &lt;link href=&quot;&lt;%=request.getContextPath()%&gt;/resources/common/Css/dialog.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;link href=&quot;&lt;%=request.getContextPath()%&gt;/resources/common/Css/dialog-theme.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; 使用的时候需要用到人家的样式，就必须要按照别人的风格来编写 &lt;div class=&quot;open btn&quot; id=&quot;btnVerify&quot;&gt; &lt;span&gt;&lt;img src=&quot;&lt;%=request.getContextPath()%&gt;/resources/common/images/upload-white.png&quot;&gt;&lt;/span&gt;&lt;i&gt;审核&lt;/i&gt; &lt;/div&gt; 就这样就可以使用了 说到这里前端就总结了这么多，下面还会总结后台的一些注意方法，在多说一句，程序员最需要的就是心态，每天进步一点点，一年后你就不一样了 http://blog.csdn.net/u013132051/article/details/51743627","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"JSP前端数据本地排序","date":"2016-06-28T12:46:00.000Z","path":"zxh/20160628.html","text":"在前端中我们经常需要数据的排序，首先写引入我写好的js $(function($) { $(&#39;#sclazzId&#39;).val($(&#39;#voId&#39;).val()); document.getElementsByName(&#39;nameup&#39;)[0].style.display = &quot;none&quot;; document.getElementsByName(&#39;nameup&#39;)[1].style.display = &quot;none&quot;; document.getElementsByName(&#39;nameup&#39;)[2].style.display = &quot;none&quot;; document.getElementsByName(&#39;nameup&#39;)[3].style.display = &quot;none&quot;; var tabobj = document.getElementById(&quot;tbValue&quot;); /* * for (var i = 2; i &lt; tabobj.rows.length; i++) { * * if (tabobj.rows[i].cells[1].innerHTML == code) { * * tabobj.rows[i].style.backgroundColor = &quot;red&quot;; * * break; } } */ }); function OnChange(code) { // alert(document.getElementById(&quot;drpIndustry&quot;).value+&quot;_&quot;+code+&quot;.html&quot;); window.location.href = document.getElementById(&quot;drpIndustry&quot;).value + &quot;_&quot; + code + &quot;.html&quot;; } // 转换器，将列的字段类型转换为可以排序的类型：String,int,float function convert(sValue, sDataType) { switch (sDataType) { case &quot;int&quot;: if (sValue != &quot;--&quot;) return parseInt(sValue); else return -10000000000000; case &quot;float&quot;: if (sValue != &quot;--&quot;) return parseFloat(sValue); else return -10000000000000.0; case &quot;date&quot;: if (sValue != &quot;--&quot;) return new Date(Date.parse(sValue)); else return &quot;1900-01-01&quot;; default: return sValue.toString(); } } // 排序函数产生器，iCol表示列索引，sDataType表示该列的数据类型 function generateCompareTRs(iCol, sDataType) { return function compareTRs(oTR1, oTR2) { var vValue1 = convert(oTR1.cells[iCol].firstChild.nodeValue, sDataType); var vValue2 = convert(oTR2.cells[iCol].firstChild.nodeValue, sDataType); if (vValue1 &lt; vValue2) { return -1; } else if (vValue1 &gt; vValue2) { return 1; } else { return 0; } }; } // 排序方法 function sortTable(sTableID, iCol, sDataType) { if (document.getElementsByName(&#39;nameup&#39;)[parseInt(iCol) - 1].style.display == &#39;none&#39;) { document.getElementsByName(&#39;nameup&#39;)[parseInt(iCol) - 1].style.display = &#39;block&#39;; document.getElementsByName(&#39;namedown&#39;)[parseInt(iCol) - 1].style.display = &#39;none&#39;; } else { document.getElementsByName(&#39;nameup&#39;)[parseInt(iCol) - 1].style.display = &#39;none&#39;; document.getElementsByName(&#39;namedown&#39;)[parseInt(iCol) - 1].style.display = &#39;block&#39;; } var oTable = document.getElementById(sTableID); var oTBody = oTable.tBodies[0]; var colDataRows = oTBody.rows; var aTRs = new Array; // 将所有列放入数组 for (var i = 0; i &lt; colDataRows.length; i++) { aTRs[i] = colDataRows[i]; } // 判断最后一次排序的列是否与现在要进行排序的列相同，是的话，直接使用reverse()逆序 if (oTable.sortCol == iCol) { aTRs.reverse(); } else { // 使用数组的sort方法，传进排序函数 aTRs.sort(generateCompareTRs(iCol, sDataType)); } var oFragment = document.createDocumentFragment(); for (var i = 0; i &lt; aTRs.length; i++) { aTRs[i].cells[0].innerHTML = i + 1; oFragment.appendChild(aTRs[i]); } oTBody.appendChild(oFragment); // 记录最后一次排序的列索引 oTable.sortCol = iCol; } function detatilWork(id) { alert(id); $.post(&quot;&quot;, { id : id }, function() { }); } function reflash() { window.location.reload(true); } function openSearch() { var name = $(&#39;#sname&#39;).val(); var clazzId = $(&#39;#sclazzId&#39;).val(); window.location.href = &quot;assistantWork.action?name=&quot; + name + &quot;&amp;clazzId=&quot; + clazzId; } function lastPage(page) { var name = $(&#39;#sname&#39;).val(); var clazzId = $(&#39;#sclazzId&#39;).val(); page = (page - 1 &lt; 0) ? 0 : (page - 1); window.location.href = &quot;assistantWork.action?page=&quot; + page + &quot;&amp;name=&quot; + name + &quot;&amp;clazzId=&quot; + clazzId; } function selPage(page) { var name = $(&#39;#sname&#39;).val(); var clazzId = $(&#39;#sclazzId&#39;).val(); window.location.href = &quot;assistantWork.action?page=&quot; + page + &quot;&amp;name=&quot; + name + &quot;&amp;clazzId=&quot; + clazzId; } function nextPage(page, pages) { var name = $(&#39;#sname&#39;).val(); var clazzId = $(&#39;#sclazzId&#39;).val(); page = (page + 1 &gt; pages) ? pages : (page + 1); window.location.href = &quot;assistantWork.action?page=&quot; + page + &quot;&amp;name=&quot; + name + &quot;&amp;clazzId=&quot; + clazzId; } function detail(id, type) { $.ajax({ url : &#39;selectOneWork.action?id=&#39; + id, async : false, // 同步请求 error : function() { alert(&quot;失败&quot;); }, success : function(data) { data = eval(&quot;(&quot; + data + &quot;)&quot;); $(&#39;#workid&#39;).val(data.id); $(&#39;#cname&#39;).val(data.name); $(&#39;#sclazzIdM&#39;).val(data.clazzId); $(&#39;#cdescription&#39;).val(data.description); }, }, &#39;json&#39;); if(type==1){ //查看 需要改成不可编辑 setDisabled(); }else if(type==2){ cleanDisabled(); } } function add(){ cleanDisabled(); } function setDisabled(){ $(&#39;#cname&#39;).attr(&quot;disabled&quot;,true); $(&#39;#sclazzIdM&#39;).attr(&quot;disabled&quot;,true); $(&#39;#cdescription&#39;).attr(&quot;disabled&quot;,true); $(&#39;#submitWork&#39;).attr(&quot;disabled&quot;,true); } function cleanDisabled(){ $(&#39;#cname&#39;).attr(&quot;disabled&quot;,false); $(&#39;#sclazzIdM&#39;).attr(&quot;disabled&quot;,false); $(&#39;#cdescription&#39;).attr(&quot;disabled&quot;,false); $(&#39;#submitWork&#39;).attr(&quot;disabled&quot;,false); } 在jsp页面中我们只需要在字段中嵌入这两div就可以实现视觉上的升序或降序，真正实现排序的是字段上面的那个点击事件，事件的执行方法在上面的脚本中都已经写好了，就这么简单，你就实现了表格数据的本地排序，大大的减少了与服务器之间的访问次数。 另外在说一句就是在我们的jsp中我们有的时候并不是很需要数据库数据的格式，这个时候我们需要将数据的格式进行转化，转化的方式有很多种，我们可以将数据在后台的时候进行格式处理，但是这样做的话在效率上并不是很快，我们在jsp中就有这样的标签 这样我们就实现了日期的格式化处理，值得注意的是这里的fmt只能用我页面上的布局，不能用工具上的格式化处理，处理过就会影响我们上面的本地排序，所以只能用我的格式","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"Excel批量导入(导出同理)","date":"2016-06-28T12:24:00.000Z","path":"zxh/20160628.html","text":"在做JavaWeb中添加数据使我们在所难免会遇到的， 在大数据的环境下批量添加和批量删除是必须的，而批量删除只需要获取到我们需要删除的ID就可以了，在批量添加中我们就会遇到问题，问题是得到批量的数据，这就涉及到了poi技术中的Excel导入导出 在前端中我们使用的Dropzone上传技术，在BootStrap中使用模态框显示Dropzone界面 ` &lt;form id=&quot;my-awesome-dropzone&quot; class=&quot;dropzone&quot; action=&quot;${pageContext.request.contextPath}/change/assistantUpload.action&quot;&gt; &lt;div class=&quot;dropzone-previews&quot;&gt;&lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;` Dropzone技术特点就是可以将温江拖拽到画面里面，然后开始js工作在form表单提交之后开始到后台收取数据 在后台的函数上面加上如下标记 就可以保证范文到制定的函数了 然后我们需要制定上传的编码格式为UTF-8 下面就是后台数据处理的部分 `try { // 上传得请求对象 MultipartHttpServletRequest req = (MultipartHttpServletRequest) request; // 获取上传的文件 CommonsMultipartFile multipartFile = (CommonsMultipartFile) req .getFile(&quot;upload&quot;); // 获取文件的名称 xxx.jpg xxx_1000101897.jp String fileName = multipartFile.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 声明excel文件对象 Workbook wb = null; // 获取文件上传输入流对象 InputStream is = multipartFile.getInputStream(); // 判断文件的后缀名称 if (&quot;.xls&quot;.equalsIgnoreCase(suffix)) { wb = new HSSFWorkbook(is); } else if (&quot;.xlsx&quot;.equalsIgnoreCase(suffix)) { wb = new XSSFWorkbook(is); } // 存储的班级名称 List&lt;String&gt; clazzNames = new ArrayList&lt;String&gt;(); // 存储的学号 List&lt;String&gt; studnos = new ArrayList&lt;String&gt;(); // 判断是否为null if (wb != null) { // 读取内容 Sheet sheet = wb.getSheetAt(0); List&lt;StudentCustom&gt; students = new ArrayList&lt;StudentCustom&gt;(); // 读取行数 int rowNumber = sheet.getPhysicalNumberOfRows(); // 遍历行数 for (int row = 1; row &lt; rowNumber; row++) { StudentCustom student = new StudentCustom(); // 获取一行记录对象 HSSFRow entity = (HSSFRow) sheet.getRow(row); // 获取列数 int colNumber = entity.getPhysicalNumberOfCells(); // 遍历列数 for (int col = 0; col &lt; colNumber; col++) { // 获取指定列 HSSFCell cell = entity.getCell(col); // 声明当前列的值 String value = &quot;&quot;; Date date = null; // 判断是否为null if (cell != null) { // 判断单元格类型 switch (cell.getCellType()) { // 数字类型 case Cell.CELL_TYPE_NUMERIC: // 判断是否是日期类型 if (HSSFDateUtil.isCellDateFormatted(cell)) { // 日期类型 SimpleDateFormat sdf = new SimpleDateFormat( &quot;yyyy-MM-dd&quot;); date = HSSFDateUtil.getJavaDate(cell .getNumericCellValue()); } else { // 获取数字 Integer data = (int) cell .getNumericCellValue(); if (col == 1) { HSSFCellStyle cellStyle = cell .getCellStyle(); String format = cellStyle .getDataFormatString(); DecimalFormat f = new DecimalFormat( format); value = f.format(data); } else { value = data.toString(); } } break; // 判断是否是字符型 case Cell.CELL_TYPE_STRING: value = cell.getStringCellValue(); break; // 判断是否是boolean型 case Cell.CELL_TYPE_BOOLEAN: Boolean data = cell.getBooleanCellValue(); value = data.toString(); break; // 错误类型 case Cell.CELL_TYPE_ERROR: // System.out.println(&quot;单元格内容出现错误&quot;); value = &quot;error&quot;; break; // 判断是否是公式类型 case Cell.CELL_TYPE_FORMULA: value = String.valueOf(cell .getNumericCellValue()); if (value.equals(&quot;NaN&quot;)) {// 如果获取的数据值非法,就将其装换为对应的字符串 value = cell.getStringCellValue() .toString(); } break; case Cell.CELL_TYPE_BLANK: // System.out.println(&quot;单元格内容 为空值 &quot;); value = null; break; default: value = cell.getStringCellValue().toString(); break; } //System.out.println(value); if (col == 1) { studnos.add(value); student.setStudno(value); // 默认密码 student.setPass(value); } else if (col == 2) { student.setName(value); } else if (col == 3) { student.setSex(value); } else if (col == 4) { student.setEnrol(date); } else if (col == 5) { student.setEmail(value); } else if (col == 6) { if (!clazzNames.contains(value)) { clazzNames.add(value); } // 查询设置班级的id值 Clazz clazz = new Clazz(); clazz.setName(value); student.setClazz(clazz); } } } // 行结束 students.add(student); } // 第一步检测班级是否存在 // 查询出该用户管理的班级 List&lt;Clazz&gt; clazzs = clazzService.selectByAssistanUserId(user .getId()); // 班级的名称集合 List&lt;String&gt; names = new ArrayList&lt;String&gt;(); // 遍历班级 for (Clazz clz : clazzs) { // 把班级名称加入到集合中 names.add(clz.getName()); } // 遍历excel中存在的班级 for (String clazzName : clazzNames) { //System.out.println(clazzName); // 判断excel中的班级是否 存在班级集合中 if (!names.contains(clazzName)) { throw new ClazzExitException(&quot;该用户不负责班级,或者班级不存在&quot;); } } // 第二步检测学号是否存在 QueryVo vo = new QueryVo(); int count = studentService.selectAdminStudentsCount(vo); vo.setStartSize(0); vo.setPageSize(count); // 查询出所有学生信息 List&lt;StudentCustom&gt; stus = studentService.selectAdminStudents(vo); List&lt;String&gt; nos = new ArrayList&lt;String&gt;(); // 遍历studnos学号， for (StudentCustom stu : stus) { // 把班级名称加入到集合中 nos.add(stu.getStudno()); } // 1.1如果excel中有重复的学号，也不可以插入 扩展 for(int i =0;i&lt;studnos.size();i++){ for(int j=i+1;j&lt;studnos.size();j++){ if(studnos.get(i)==studnos.get(j)){ throw new ExcelStuNoExitException(studnos.get(i)+&quot;该学号在Excel存在重复&quot;); } } } // 检测查询的学号中是否含有该班级，如果含有 就跑出异常 for (String no : nos) { System.out.println(no); // 判断excel中的班级是否 存在班级集合中 if (studnos.contains(no)) { System.out.println(no); throw new StuNoExitException(no+&quot;学号已存在&quot;); } } // excel解析结束 // 按班级分好类 Map&lt;Clazz, List&lt;StudentCustom&gt;&gt; map = new HashMap&lt;Clazz, List&lt;StudentCustom&gt;&gt;(); // 批量保存学生信息 for (String clazzName : clazzNames) { List&lt;StudentCustom&gt; s = new ArrayList&lt;StudentCustom&gt;(); Clazz clazz = clazzService.selectClazzName(clazzName); for(int i=0;i&lt;students.size();i++){ if(students.get(i).getClazz().getName()==clazzName) { students.get(i).setClazzId(clazz.getId()); s.add(students.get(i)); } } map.put(clazz, s); } transactionService.insertStudentsCustomFromExcel(map); // 同步更新班级的人数 } out.print(&quot;{\\&quot;msg\\&quot;:\\&quot;success\\&quot;}&quot;); } catch (ClazzExitException ce) { out.print(&quot;{\\&quot;msg\\&quot;:\\&quot;&quot;+ce+&quot;\\&quot;}&quot;); } catch (ExcelStuNoExitException ce) { out.print(&quot;{\\&quot;msg\\&quot;:\\&quot;&quot;+ce+&quot;\\&quot;}&quot;); } catch (StuNoExitException ce) { out.print(&quot;{\\&quot;msg\\&quot;:\\&quot;&quot;+ce+&quot;\\&quot;}&quot;); } catch (Exception ex) { out.print(&quot;{\\&quot;msg\\&quot;:\\&quot;&quot;+ex+&quot;\\&quot;}&quot;); } finally { out.flush(); out.close(); 另外值得一提的是在前端我们的需要因要到一段js来设置传送的接口 `function initUploadOptions(){ Dropzone.options.myAwesomeDropzone = { method : &#39;post&#39;, paramName : &#39;upload&#39;, autoProcessQueue : false, uploadMultiple : false, maxFiles : 1, init : function() { var myDropzone = this; this.element.querySelector(&quot;button[type=submit]&quot;) .addEventListener(&quot;click&quot;, function(e) { e.preventDefault(); e.stopPropagation(); myDropzone.processQueue() }); this.on(&quot;sending&quot;, function() { alert(&quot;发送过程中&quot;); }); this.on(&quot;success&quot;, function(file, response) { alert(file + &quot;成功&quot; + response); var obj=eval(&quot;(&quot;+response+&quot;)&quot;); file.previewTemplate.appendChild(document .createTextNode(obj.msg)); window.location.reload(true); }); this.on(&quot;error&quot;, function(file, response) { alert(file + &quot;失败&quot; + response); }) } } };` 在这里我们需要制定参数的名称为upload 这样我们在controller中渠道upload这个上传的对象 整个过程就可以将Excel中的数据拿到了，至于怎么存取就看个人了，你可以用list去接收这些数据 上面这些就是为了实现功能，读者可以自行在此基础上进行分装方法放在自己的项目上就可以使用了 在此之前我还有一种方法是封装在Util工具类中的 至于这点我就不多说了我放在下载里 有需要的朋友自己下载吧 http://download.csdn.net/detail/u013132051/9561129","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"JavaWeb前端分页显示方法","date":"2016-06-24T07:44:00.000Z","path":"zxh/20160624.html","text":"在前端中我们总会遇到显示数据的问题 正常情况分页显示是必须的，这个时候我们不能仅仅在前端进行分页，在前端其实做起分页是很困难的，着就要求我们在后台拿数据的时候就要把分页数据准备好，在前端我们只需要将这些后台准备好的数据拿过来就行了 在后台我们通常是实现准备好一个分页工具类Pagination这里是分页显示的基本数据 在前台中我们只需要将pagination中构造函数中所需要的参数传过来就可以了。然后在向数据查询数据的时候将pagination中的限定条件传过去查询的数据就不是所有的数据而是前端所请求的分页数据了理论就是这样了下面看看我是如何实现的 `@RequestMapping(value = { “/assistantWork.action” }) public String assistantWork(HttpSession session, Integer page, QueryVo vo, Model model) { User user = (User) session.getAttribute(&quot;user&quot;); if (vo == null) { vo = new QueryVo(); } // 当前页 if (page == null) { page = 1; } vo.setUserId(user.getId()); // 查询总记录 Integer countrecord = workSerivce.selectAllWorksByConditionCount(vo); List&lt;Clazz&gt; clazzs = workSerivce.selectClazzsByUserId(user.getId()); model.addAttribute(&quot;clazzs&quot;, clazzs); if(countrecord!=0){ // 分页对象 Pagination&lt;Work&gt; pagination = new Pagination&lt;Work&gt;(page, countrecord); // 设置分页的查询条件 vo.setStartSize(pagination.getStartsize()); vo.setPageSize(pagination.PAGESIZE); // 拿到改助教管理下的所有班级的作业 // List&lt;Work&gt; works = workSerivce.selectAllWorks(user.getId()); List&lt;Work&gt; works = workSerivce.selectWorksByClazzId(vo); pagination.setRows(works); model.addAttribute(&quot;pagination&quot;, pagination); // 条件传过去 回写 model.addAttribute(&quot;vo&quot;, vo); }else { //没有管理的班级 model.addAttribute(&quot;msg&quot;, &quot;当前用户没有管理的作业&quot;); } return &quot;/pages/assistant/homework_assistant&quot;; }` 这段代码里面用到其他的mybatis分装类，这里读者请忽视其他的只看我们将的pagination这段就可以了，可以看出我在最后查询的时候是带着pagination条件的，最后拿到的数据就是我们前端需要的 整个过程就是这样下面我将pagination工具类贴在下面 `package tm.change.util; import java.util.List; /** @author redarmy_chen @param */public class Pagination { // 分页信息 private int nowpage;// 当前页 private int countrecord;// 总记录 private int countpage;// 总页数 public static final int PAGESIZE = 3;// 每页显示的记录数 private int startpage;// 页面中的起始页 private int endpage;// 页面中的结束页 private int startsize; private final int SHOWPAGE = 6;// 页面中显示的总页数 baidu,google显示的总页数是20 // 在测试我们才用6来测试 private List rows; private String url; public Pagination() { super(); // TODO Auto-generated constructor stub } /** 根据当前页及总记录数来构造分页对象 */ public Pagination(int nowpage, int countrecord) { //获取当前页 //1 2 3 //判断最小页码 if(nowpage&lt;=1){ this.nowpage=1; }else{ this.nowpage = nowpage; } //总记录数 this.countrecord = countrecord; /** 计算总页数 */ this.countpage = this.countrecord % this.PAGESIZE == 0 ? this.countrecord / this.PAGESIZE : this.countrecord / this.PAGESIZE + 1; //判断最大页 if(this.nowpage&gt;=this.countpage){ this.nowpage=this.countpage; } //开始的记录数 this.startsize=(this.nowpage-1)*this.PAGESIZE; /** 计算startpage与endpage的值 */ /** 总页数数是否小于4 */ if (this.countpage &lt; (this.SHOWPAGE / 2 + 1)) { this.startpage = 1; // 页面中起始页就是1 this.endpage = this.countpage;// 页面中的最终页就是总页数 } else { /** else中是总页数大于4的情况 */ /** 首先当前页的值是否小于等于4 */ if (this.nowpage &lt;= (this.SHOWPAGE / 2 + 1)) { this.startpage = 1; this.endpage = this.nowpage + 2; /** 判断页面的最终页是否大于总页数 */ if (this.endpage &gt;= this.countpage) { this.endpage = this.countpage; } } else { this.startpage = this.nowpage - 3; this.endpage = this.nowpage + 2; if (this.endpage &gt;= this.countpage) { this.endpage = this.countpage; if (this.countpage &lt; this.SHOWPAGE) { this.startpage = 1; } else { this.startpage = this.endpage - 5; } } } } } public int getNowpage() { return nowpage; } public void setNowpage(int nowpage) { this.nowpage = nowpage; } public int getCountrecord() { return countrecord; } public void setCountrecord(int countrecord) { this.countrecord = countrecord; } public int getCountpage() { return countpage; } public void setCountpage(int countpage) { this.countpage = countpage; } public int getStartpage() { return startpage; } public void setStartpage(int startpage) { this.startpage = startpage; } public int getEndpage() { return endpage; } public void setEndpage(int endpage) { this.endpage = endpage; } public List&lt;T&gt; getRows() { return rows; } public void setRows(List&lt;T&gt; rows) { this.rows = rows; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public int getStartsize() { return startsize; } public void setStartsize(int startsize) { this.startsize = startsize; } }`","tags":[{"name":"Java","slug":"Java","permalink":"https://zxhtom.oschina.io/tags/Java/"}]},{"title":"javaWeb 中前端Form表单数据处理(手动拼json)","date":"2016-06-23T07:08:00.000Z","path":"zxh/20160623.html","text":"在前端我们会用到最多的就是form表单提交数据，在form表单中有很多都是自动将数据传到后台 在前端我们会用到最多的就是form表单提交数据，在form表单中有很多都是自动将数据传到后台，然后通过实体来接受的，但是有的时候我们就是需要在前端就拿到这个Form表单的数据，这是我们就可以自己讲数据拼接好 `// 获取表单里面的数据，返回一个json形式的对象// 参数 form 为表单对象，filler 为字符串// 对于表单中空值的元素，默认忽略，也可以设置填充值：filler 来填充空值function getFormData (form, filler) { var data = {}; for (var i = 0; i &lt; form.length; ++i) { var name = form[i].name; var value = form[i].value; if (name.length == 0) continue; if (value.length == 0) { if ((typeof filler != &#39;string&#39;) || (filler.length == 0)) continue; else value = filler; } var sz = &quot;data.&quot;+name+&quot; = &#39;&quot; + value + &quot;&#39;&quot;; try { eval(sz); } catch (e) { alert(e); } } return data;} ` 在脚本中我们添加这个方法后只需在jsp、html等前端页面中引用脚本就可以得到数据了 值得一提的是在调用脚本中的这个方法的时候 var datajson=getFormData(document.getElementById(&quot;updateff&quot;), &quot;1&quot;); 我们通过上面进行调用方法其中updateff是form表单中的ID 这样方法返回的数据就是一个json数据了，在前端就可以使用，当然你也可以传递到后台，但是form表单提交单后台有很多框架都是可以实现的，没必要采用我这方法，我这主要是在前端调用的","tags":[{"name":"Java","slug":"Java","permalink":"https://zxhtom.oschina.io/tags/Java/"}]},{"title":"Json串与实体的相互转换 (不依赖于jar包 只需Eclipse环境即可)","date":"2016-05-19T01:40:00.000Z","path":"zxh/20160519.html","text":"Json串与实体的相互转换 (不依赖于jar包 只需Eclipse环境即可) Json串与实体的相互转换 (不依赖于jar包 只需Eclipse环境即可)最近学习了javaWeb开发，用的是ssh框架里面自己整合了hibernate 和Struts2 和spring框架，其中就遇到了一个问题–json的转换的问题。考虑到程序的稳定性，我花三天的时间研究json的转换，网上的代码有很多，但是都是依赖于一些写好的jar包，我导入这些jar包后都提示少东西要么就是提示错误所以我就自己手写了一个工具类，使用我的这个工具类就可以直接使用工具进行转换了不需要导入任何jar包。需要的程序员可以看看，代码还有不足的地方还在改进 工具类 JsonConEntity 定义为私有的构造函数 成为单列 方便使用 首先使用到的是拿到json串中实体个数 `for(int i=0;i&lt;JsonConEntity.getCount(str);i++){ Module entity=new Module(); list.add(entity); }` 这里是getCount方法 public static Integer getCount(String json){ Map&lt;Integer, Map&lt;String, Object&gt;&gt; bigMap = JsonConEntity.getMap(json); return bigMap.size(); } 创建好对应的实体后我们就可以调用核心代码实现了 list = JsonConEntity.jsonToEntity2(str, list); 在核心代码里我们首先需要将json串转换到一个集合中，这里我用的是map集合来装取 Map&lt;Integer, Map&lt;String, Object&gt;&gt; bigMap = getMap(json); 将数据装到map中之后我们就可以遍历了，在遍历中取到的实际上已经是一个实体的数据了 在得到实体后的方法定义 拿到一个实体的map参数数据之后我们还需要对实体的属性进行遍历赋值 Field[] fields = tClass.getDeclaredFields(); for (Field field : fields) { 在这里我们就可以遍历真正的实体中的属性的名称了，然后我们将真正实体中的属性和map集合中对应的实体的属性进行比较从而方便了我们的赋值 PropertyDescriptor pd = new PropertyDescriptor( field.getName(), tClass); // 获得set方法 Method method = pd.getWriteMethod(); String str = map.get(key1).toString(); 这样我们就可以操作实体中的set方法了，在这里V1.0中没有对实体总的set方法进行判断导致了一个错误 就是导致实体中的所有的属性在你传过来的json中必须要有对应字段值，这样的话很不符合json和实体转换的初衷，所以在V2.0中我解决了这个问题，在哪实体中的set方法前先与json中对应的实体的属性进行比较，json串中没有的就不用在拿实体中的set方法了，json中有的在去实体中拿set方法，然后通过set方法将值传过去，这样就起到了json转换实体的作用了，到这里我的思想也就玩了，同志们还没懂得自己看看我的代码吧，在文章的最后会贴上下载链接的 下面就是实体转换成json串了这个相对简单很多，我们只需要拿到属性然后就行拼接之后就可以了， 使用说明小提示： —–无jar包支持 纯手写代码—–要求—json格式为 [{},{},…..]或{}—在调用此工具类中的实体向json转换的时候实体的所有属性至少必须有get方法 否则无法用此工具类生成json串。在json转换为实体的时候需要将json串中有的属性值必须要有set方法，否则也无法正常的进行转换。—在实体转换json时只需要将实体创建好然后进行工具转换就行了—在json转换成实体的时候我们麻烦一步，需要向用工具类拿到json串的实体的个数，然后向创建出N个空的实体用来接收json串中的实体，新创建的N的实体我们一次加入到list里面然后将整个list传到json工具类中，最后我们遍历这个list就行了—V1.0中我只能解析json串中的整数型不能有引号。 也就是说实体的属性的int型的那么我们的json里面的对应的属性不能有引号。 在V2.0里已经解决了这个问题了 工具类下载链接： - **http://download.csdn.net/detail/u013132051/9524654**","tags":[{"name":"Java","slug":"Java","permalink":"https://zxhtom.oschina.io/tags/Java/"}]},{"title":"三层架构(MVC)实现简单登陆注册验证（含验证码）","date":"2016-04-01T07:18:00.000Z","path":"zxh/20160401.html","text":"前言在我的上一篇微博里我已经提出了登陆的方法，当时我采取的是纯servlet方式，因为当时刚接触到servlet，正好网上没有这方面的全面讲解，所以我就发飙了。不过在现实生产中我们大多采用的三层架构。所谓三层架构（web层+service层+dao层）。下面我就详细讲解一下 一、dao层------数据访问层 模拟数据库：依然像钱一张一样，我们无法将数据库拿到文档中，所以我还是模拟了数据库（Dao）.只不过这里我用的是xml文件来实现数据库 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;users&gt; &lt;user username=&quot;Admin&quot; password=&quot;Admin&quot; nickname=&quot;Admin&quot; email=&quot;1@qq.com&quot;&gt;&lt;/user&gt; &lt;user username=&quot;张新华&quot; password=&quot;123&quot; nickname=&quot;烟花散尽13141&quot; email=&quot;870775401@qq.com&quot;&gt;&lt;/user&gt; &lt;/users&gt; 然后再数据库中我实现了查找了和增加功能，查找呢又细分通过用户名查找和通过用户名密码查找，前者是查找后者则偏向于验证。通过后者可以验证用户名和密码是否匹配，这两个函数在后面的web层中起到关键因素。 通过用户名查找： `public User FindUserByUsername(String username){Document dom=XmlDaoUtil.GetDom();//�õ�dom����Element root=dom.getRootElement(); List list = root.selectNodes(“//user[@username=’”+username+”‘]”);if(list.size()&gt;0){ Element userele=list.get(0); User user=new User(); user.setUsername(userele.attributeValue(“username”)); user.setPassword(userele.attributeValue(“password”)); user.setNickname(userele.attributeValue(“nikename”)); user.setEmail(userele.attributeValue(“email”)); return user;}else{ return null;}}` 通过用户名和密码进行验证 public User FindUserByUNameAndPsw(String username,String password){Document dom=XmlDaoUtil.GetDom();//�õ�dom����Element root=dom.getRootElement(); List list = root.selectNodes(“//user[@username=’”+username+”‘ and @password=’”+password+”‘]”);if(list.size()&gt;0){ Element userele=list.get(0); User user=new User(); user.setUsername(userele.attributeValue(“username”)); user.setPassword(userele.attributeValue(“password”)); user.setNickname(userele.attributeValue(“nikename”)); user.setEmail(userele.attributeValue(“email”)); return user;}else{ return null;}} 添加用户 public void AddUser(User user){ Document dom=XmlDaoUtil.GetDom(); Element root=dom.getRootElement();//��ȡ���ڵ� //����һ��Ԫ�ض��� Element userele=DocumentHelper.createElement(“user”); Attribute attr1=DocumentHelper.createAttribute(userele, “username”, user.getUsername()); Attribute attr2=DocumentHelper.createAttribute(userele, “password”, user.getPassword()); Attribute attr3=DocumentHelper.createAttribute(userele, “nickname”, user.getNickname()); Attribute attr4=DocumentHelper.createAttribute(userele, “email”, user.getEmail()); userele.add(attr1); userele.add(attr2); userele.add(attr3); userele.add(attr4); root.add(userele);}","tags":[{"name":"java","slug":"java","permalink":"https://zxhtom.oschina.io/tags/java/"}]},{"title":"java 购物商城小项目训练","date":"2016-04-01T07:16:00.000Z","path":"zxh/20160401.html","text":"java 购物商城小项目训练 java web 模拟购物车练习(项目一) 首页(index.jsp) ` Estore商城 &lt;b&gt;欢迎大家访问的我的首页！烟花散尽13141！&lt;/b&gt; 欢迎光临，游客！ 注册 登录 欢迎回来！${user.username } 添加商品 注销用户 订单查询 商品列表 榜单下载 查看购物车 ` 在首页中我们大体上为两种身份的人提供界面欣赏，一个是管理员另外一个是普通用户还有一个是以有课的身份去浏览本网页的。在我们的注册页面中我们只提供注册普通用户的，由于时间紧张我们并没有提供对管理员的身份的认证，下面我简单说一下普通员工的身份的认证， 注册(register.jsp) 在注册页面中我们比较首页而言是复杂的，在注册的页面我们需要在提交前对用户提交的数据进行相关的检查，首先用户需要提交的数据是用户名+密码+密码2+昵称+邮箱+验证码对于这六个数据大前提是我们用户提交的数据不能为空，其次就是两次密码必须是一致的，还有提交的邮箱要符合邮箱的格式。这些都符合了才能通过客户端提交到服务器上，在服务器上为了安全起见我们还是得在进行这些数据的检查目的就是为了防止别人截取到我们的数据进行修改。为了给用户呈现一种友好的界面我有使用了无闪刷新，这样就会在用户焦点离开某项时就会对用户进行相应的提示，总的说来在这个注册页面中我们还是做了不少的前期工作的，。前期标准都符合的才能提交有服务起判断是否合法。这个数据的合法性有后面我们要介绍的RegisteServlet来解决， 刚才也说了数据最后是提交到服务器上的，那么我们下面说的是服务器是如何处理服务器的（RegisteServlet） 第一步验证用户提交的验证码是否正确 if(code!=null &amp;&amp; !code.equals(&quot;&quot;) &amp;&amp; !code.equals(AuthCode)) { //验证码错误 request.setAttribute(&quot;msg&quot;, &quot;验证码错误！请核实&quot;); request.getRequestDispatcher(&quot;/register.jsp&quot;).forward(request, response); } 第二步对提交的数据进行封装，方便数据库进行相关操作 `User user=new User(); BeanUtils.populate(user, request.getParameterMap());` 第三步业务类调用数据方法操作数据的注册 `user.setPassword(MD5Utils.md5(user.getPassword())); /** * 第四步 调用service方法注册 */ service.regist(user);` 第五步成功调回首页这里也可以直接调到登陆页 response.getWriter().write(&quot;注册成功！请注意留意邮箱的激活码进行账号激活！&quot;); 讲完注册当然就是登录了，有了注册的页面基础上我们的登录做起来就得心应手了，所以登录我就不说了，那么现在我们已经可以登录我们的购物商城的系统中去了，那么我们在这个商城中到底能干什么呢，下面才是我们的重点，针对两个身份我们有不同的功能，首先我来说普通用户 下订单 首先我们的用户能够看到商城先所有的代售商品，并可以将他们加入到属于自己的购物车中，并进行支付或者取消支付，在我们上面的一句话转换到我们的程序中我们就需要好几个类来实现 第一个我们需要一个ProdList.jsp界面来将商城中的所有商品进行展示，在展示之前我们需要ProdListServlet来获取商城中到底有哪些东西，获得到商城中商品后我们需要一个购物车car.jsp相当于容器来装下我们选择购买的东西，这里我们将自己购买的东西放在一个HashMap中，而这个Map我们将他放在session中，读者如果想实现客户端缓存的话可以将这个map存储到cookie中，最后想要支付我们还需要一个pay.jsp和计算金额的Servlet来实现支付功能。 ProdListServlet ProdService service=(ProdService) BasicFactory.getFactory().getInstance(&quot;ProdService&quot;); User user=(User) request.getSession().getAttribute(&quot;user&quot;); List&lt;Prod&gt; list=null; /* if(user!=null &amp;&amp; &quot;admin&quot;.equals(user.getRole())) { int uid=user.getId(); list=service.getAllProds(uid); } else { list=service.getAllProds(); } 加入监听器后就不需要再这里进行判断了 */ list=service.getAllProds(); request.getSession().setAttribute(&quot;list&quot;, list); request.getRequestDispatcher(&quot;/prodlist.jsp&quot;).forward(request, response); ProdList.jsp &lt;c:forEach items=&quot;${list }&quot; var=&quot;l&quot;&gt; 只需要取到在ProdListServlet中存储的list就可以进行遍历了，就可以实现购物商城中的商品的浏览，到这里我们的购物商城已经实现了， 下面就是加入购物车，加入购物车笔者建议在加入之前我们就开始判断数数据的合法性，基本合法就是购买数量不能为0 还有就是不能大于商城中商品的数量，在合法的数据中我们就将这个商品加入到我们自己的购物车(HashMap)。计入购物车中我们得将他展现出来供用户操作Car.jsp car.jsp &lt;c:forEach items=&quot;${carMap }&quot; var=&quot;car&quot; varStatus=&quot;status&quot;&gt; &lt;c:set var=&quot;i&quot; value=&quot;${i+1 }&quot;&gt;&lt;/c:set&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;&lt;img src=&quot;${pageContext.request.contextPath }/GetImgServlet?id=${car.key.id }&quot;&gt;&lt;/td&gt; &lt;td&gt;${car.key.name }&lt;/td&gt; &lt;td&gt;${car.key.category }&lt;/td&gt; &lt;td&gt;${car.key.price }元&lt;/td&gt; &lt;td&gt;&lt;b&gt;&lt;a href=&quot;${pageContext.request.contextPath }/ChangeCarServlet?id=${car.key.id}&amp;buynum=${car.value-1}&quot;&gt; - &lt;/a&gt;&lt;/b&gt;&lt;input type=&quot;text&quot; name=&quot;pnum&quot; value=&quot;${car.value }&quot; style=&quot;width: 30px;&quot; onblur=&quot;check(&#39;${car.key.id }&#39;,this,&#39;${car.value }&#39;,&#39;${status.count }&#39;)&quot; /&gt;&lt;b&gt;&lt;a href=&quot;${pageContext.request.contextPath }/ChangeCarServlet?id=${car.key.id}&amp;buynum=${car.value+1}&quot;&gt; + &lt;/a&gt;&lt;/b&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;oneprice&quot; value=&quot;${car.value * car.key.price }&quot; width=&quot;5px;&quot;/&gt;元&lt;/td&gt; &lt;c:set var=&quot;sum&quot; value=&quot;${sum + car.value * car.key.price }&quot;&gt;&lt;/c:set&gt; &lt;td name=&quot;price&quot;&gt;&lt;a href=&quot;${pageContext.request.contextPath }/DeleteProdServlet?id=${car.key.id}&quot;&gt;删除商品&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; 到这里我们购物商城的框架就已经搭建好了，下面还剩下的就是管理员的一些操作和用户购物车结算或取消的一些相关操作，这些只是我们留在下一节进行讲解，在文章的最后我也会将我们的开发过程的笔记和最终的项目源码奉上。尽请期待！","tags":[{"name":"Java","slug":"Java","permalink":"https://zxhtom.oschina.io/tags/Java/"}]},{"title":"Servlet生成验证码并进行账号密码和验证码的验证登陆！","date":"2016-03-05T08:57:00.000Z","path":"zxh/20160305.html","text":"人不是生来就懂事的，在编程的世界也是一样， 前言： 人不是生来就懂事的，在编程的世界也是一样，想想在大一的时候我还是那个连输出Hello World！都不会的小孩子是，现在我已经可以编出属于我自己的小程序了。编程其实并不可怕，可怕的是你不去编。现在已经大三了，正在实训时间很紧，我争取每周发表一篇微博。今天我想来谈谈验证码登陆这个问题。我看了网上的相关知识，感觉网上大多只有如何生成验证码的，并没有系统的将相关的认证，今天我就整理了一下。 验证码的生成 我们需要用到Servlet来生成验证码，验证码其实就是一张图片，那么我们首先定义一下图片的背景 BufferedImage img=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); 然后我们需要一支画笔 Graphics2D g=(Graphics2D) img.getGraphics(); 得到画笔后我们就开始绘画了 `g.fillRect(120, 120, width, height); g.drawRect(120, 120, width-1, height-1);` 基本的框架画好了就开始填数字了 for(int i=0;i&lt;4;i++) { int r=RandNum(9); AuthCode+=r+&quot;&quot;; g.setColor(new Color(RandNum(255), RandNum(255), RandNum(255))); g.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 20)); g.drawString(r+&quot;&quot;, 5+i*30, 22); } 大家应该都见过验证码长什么样子，验证码给人一种模糊的感觉，那么下面我们还要做的事将这个框架填充点线，形成模糊的感觉 for (int i=0;i&lt;255;i++) { int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x,y,x,y); 到这里我们已经完成了验证码的绘制了，下面我将他发布到浏览器上 ImageIO.write(img, &quot;jpg&quot;, response.getOutputStream()); 这里还有一点值得注意，我们随机生成的四位数验证码我们自己也要存储起来，用来我们登陆时进行验证 `public String GetAuthCode(){String authcode=””;for(int i = 0; i &lt; 4; i++){ authcode += (new Random()).nextInt(10);}return authcode; }` 这里我们得到的验证码我将用HttpSession来存储。 request.getSession().setAttribute(&quot;AuthCode&quot;, AuthCode);//保存到session中以便验证 验证码生成的工作到这里已经结束了，网上的也就到这里结束，下面我还要进行登陆验证，因为是演示我无法将数据库带过来，所以在程序中自己模拟了一个数据库用来账号的验证。 模拟的数据我用map来存储键值对，这样方便我们搜索 UserInfor u1=new UserInfor(&quot;张新华&quot;, &quot;123&quot;); UserInfor u2=new UserInfor(&quot;奥巴马&quot;, &quot;456&quot;); UserInfor u3=new UserInfor(&quot;习近平&quot;, &quot;789&quot;); UserInfor u4=new UserInfor(&quot;安倍&quot;, &quot;1234&quot;); UserInfor u5=new UserInfor(); map.put(u1.getUserName(), u1); map.put(u2.getUserName(), u2); map.put(u3.getUserName(), u3); map.put(u4.getUserName(), u4); map.put(u5.getUserName(), u5); 在这个数据库中我提供了一个验证方法，用来验证账户和密码是否枕正确 if(map.containsKey(name)&amp;&amp;map.get(name).getPwd().equals(pwd)) { return map.get(name); } 在上面的数据库中我们不难发现里面有一个用户数据类，所以下面我们还要构造这个数据类，在这里我给用户提供了姓名和密码 private String userName;private String pwd; 关于这个类的有参’无参‘和访问器我就不写了，你们自动生成就行了 下面才是我们的主菜，在这里我们需要构造一个Servlet来承接我们之前的验证码，用html更好（其实我就是在Servlet里面写Html的）我将他起名为IndexServlet 在DoGet方法中我们要告诉浏览器不要缓存 response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, -1); 首页我们就要来判断用户是登陆了回来的还是第一次来 String err=(String) session.getAttribute(&quot;errmsg&quot;); err=err==null ? &quot;&quot; : err; String errv=(String) session.getAttribute(&quot;errvalid&quot;); errv=errv==null ? &quot;&quot; : errv; String name=request.getParameter(&quot;username&quot;); name= name==null ?&quot;&quot; : name; out.write(&quot;&lt;font color=&#39;Red&#39;&gt;&quot;+err+&quot;&lt;/font&gt;&lt;/br&gt;&quot;); out.write(&quot;&lt;font color=&#39;Red&#39;&gt;&quot;+errv+&quot;&lt;/font&gt;&quot;); session.removeAttribute(&quot;errmsg&quot;); session.removeAttribute(&quot;errvalid&quot;); out.append(&quot;&lt;script type=\\&quot;text/javascript\\&quot;&gt;&quot;); //脚本 out.append(&quot;function imgclick(img)&quot;); out.append(&quot;{&quot;); out.append(&quot;img.src=\\&quot;/ValidLoad2/Valimg?time=\\&quot;+new Date().getTime()&quot;); out.append(&quot;}&quot;); out.println(&quot;&lt;/script&gt;&quot;); out.append(&quot;&lt;form action=&#39;&quot;+request.getContextPath()+&quot;/LoginServlet&#39; method=&#39;post&#39;&gt;&quot;); out.append(&quot;&lt;table&gt;&quot;); //第一行 out.append(&quot;&lt;tr&gt;&quot;); out.append(&quot;&lt;td&gt;&quot;); out.append(&quot;用户名：&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;td&gt;&quot;); out.append(&quot;&lt;input type=text name=&#39;username&#39; id=&#39;zxh&#39; value=&#39;&quot;+name+&quot;&#39; style=&#39;width:152px;height:30px;&#39;/&gt;&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;/tr&gt;&quot;); //第二行 out.append(&quot;&lt;tr&gt;&quot;); out.append(&quot;&lt;td&gt;&quot;); out.append(&quot;密码：&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;td&gt;&quot;); out.append(&quot;&lt;input type=password name=&#39;pwd&#39; style=&#39;width:152px;height:30px;&#39;/&gt;&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;/tr&gt;&quot;); //第三行 out.append(&quot;&lt;tr&gt;&quot;); out.append(&quot;&lt;td&gt;&quot;); out.append(&quot;验证码：&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;td&gt;&quot;); out.append(&quot;&lt;input type=text name=&#39;code&#39; style=&#39;width:152px;height:30px;&#39;/&gt;&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;td&gt;&quot;); out.append(&quot;&lt;img src=&#39;/ValidLoad2/Valimg&#39; onclick=&#39;imgclick(this)&#39;/&gt;&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;/tr&gt;&quot;); //第四行 out.append(&quot;&lt;tr&gt;&quot;); out.append(&quot;&lt;td colspan=2&gt;&quot;); out.append(&quot;&lt;input type=submit value=&#39;登录&#39; style=&#39;width:222px;height:30px;&#39;/&gt;&quot;); out.append(&quot;&lt;/td&gt;&quot;); out.append(&quot;&lt;/tr&gt;&quot;); out.append(&quot;&lt;/table&gt;&quot;); // out.append(&quot;用户名：&lt;input type=text name=&#39;username&#39; id=&#39;zxh&#39; value=&#39;&quot;+name+&quot;&#39;/&gt;&lt;/br&gt;&lt;/br&gt;&quot;); // out.append(&quot; 密码 ：&lt;input type=password name=&#39;pwd&#39;/&gt;&lt;/br&gt;&quot;); // out.append(&quot;验证码：&lt;input type=text name=&#39;code&#39; /&gt;&quot;); // out.append(&quot;&lt;img src=&#39;/ValidLoad2/Valimg&#39; onclick=&#39;imgclick(this)&#39;/&gt;&quot;); // out.append(&quot;&lt;a href=&#39;LoginServlet&#39;&gt;看不清&lt;/a&gt;&lt;/br&gt;&quot;); // out.append(&quot;&lt;input type=submit value=&#39;登录&#39;/&gt;&quot;); out.append(&quot;&lt;/form&gt;&quot;); 如果登陆成功，则跳转到我们的欢迎界面 out.write(&quot;欢迎&quot;); out.write(&quot;&lt;b&gt;&quot;); out.write(userInfor.getUserName()); out.write(&quot;&lt;/b&gt;&quot;); out.write(&quot;回来&quot;+&quot;&lt;/br&gt;&quot;+&quot;&lt;a href=&#39;&quot;+request.getContextPath()+&quot;/LoginOutServlet&#39;&gt;注销&lt;/ a&gt;&quot;); 在上面IndexServlet中我提到了登陆成功界面，在这里我起名为LoginOutServlet. 在这个Servlet中特别简单就是为了实现用户推出功能的，所以我们只需要将session中的数据删除就行了，那么问题来了如果直接删除会导致我们网页一旦受到攻击服务器将会不堪重负，所以我加了限制条件 HttpSession session=request.getSession(false); if(session!=null) session.invalidate(); response.sendRedirect(request.getContextPath()+&quot;/IndexServlet&quot;); 最后就是我们的验证界面了，我们的账号和密码匹配在我们模拟数据库中就已经写好了，那为什么还要进行验证呢，难道你忘了我们还有验证码呢，再说了，我的数据库只是验证账号和密码是否匹配，并不做任何事情，所以我们还需要一个servlet来实现验证的执行 `String name=request.getParameter(“username”);// name= name==null ?”” : name;String pwd=request.getParameter(“pwd”);String code=request.getParameter(“code”);UserInfor userInfor=UserDao.CheckInfor(name, pwd);HttpSession session=request.getSession();String AuthCode=(String) session.getAttribute(“AuthCode”);// System.out.println(AuthCode+”——-“+code);if(AuthCode.equals(code)){ if(userInfor==null) { //失败 session.setAttribute(&quot;errmsg&quot;, &quot;用户名或密码错误！&quot;); response.sendRedirect(request.getContextPath()+&quot;/IndexServlet?username=&quot;+name); // System.out.println(“1”); } else { //成功 response.setContentType(&quot;text/html;charset=utf-8&quot;); session.setAttribute(&quot;userInfor&quot;, userInfor); response.setHeader(&quot;Refresh&quot;, &quot;3;url=&quot;+request.getContextPath()+&quot;/IndexServlet&quot;); response.getWriter().write(&quot;恭喜您！登录成功！&quot;); // System.out.println(“2”); }}else{// System.out.println(“3”); //验证码出错 session.setAttribute(“errvalid”, “验证码错误！”); response.sendRedirect(request.getContextPath()+”/IndexServlet?username=”+name+”&amp;pwd=”+pwd);}` 到这里我们的验证登陆功能就已经实现了，我们是从IndexServlet这个页面开始进入的，不要进错了，我写这个 博客主要是为了帮助和我一样志同道合的人一起学习一起探讨。下面是我的运行流程 下面我填写正确的数据看看效果 验证码错误的情况 密码错误","tags":[{"name":"Java","slug":"Java","permalink":"https://zxhtom.oschina.io/tags/Java/"}]},{"title":"io流处理文件夹复制功能(java代码)","date":"2016-02-27T09:05:00.000Z","path":"zxh/20160227.html","text":"##拷贝某个目录下得所有文件拷指定位置 思想归纳 首先我们需要做的先获取到资源文件夹路径，这里我们先在程序中写死，然后我们还需要一个目标文件夹就是你需要拷贝到哪里。有了这两个文件夹我就可以进行复制了 然后我们首先要先将目标文件路径创建出来，然后我们在对源文件进行遍历，遍历时我添加了两个辨认方法 1、如果是系统识别的标准文件则执行文件复制功能 2、如果是文件夹的话则在目标文件夹对应的地方进行创建文件夹，方便遍历。 总体思想就是这些。下面我们需要完成的函数有 文件复制函数+文件夹创建函数 文件拷贝函数： 1、创建输入对象 BufferedInputStream bis=new BufferedInputStream(new FileInputStream(SourceFile)); 2、创建输出流对象 BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(TargetFile)); 3、获取数据 完成数据的复制 下面就是文件夹的创建 获取路径并遍历 (new File(TargetFolder)).mkdirs();//创建目标文件夹 File[] files=(new File(SourceFolder)).listFiles();//获取原文件夹下的所有文件准备遍历 判断是否是文件 if(f.isFile())//检测f是否是标准文件 { //获取源文件和目标文件 File SourceFile=f; File TargetFile=new File(new File(TargetFolder).getAbsoluteFile()+f.separator+f.getName()); //准备进行复制 CopyFile(SourceFile, TargetFile); } 判断是否是文件夹 else if(f.isDirectory())//检测到f是个标准目录 { CopyFolder(SourceFolder+f.getName(), TargetFolder+File.separatorChar+f.getName()); } 这两个函数完成后只要在主函数中我们在将源文件和目标文件进行一次遍历就行了，如果主函数中不进行遍历我们将无访问权进行数据的访问。","tags":[{"name":"Java","slug":"Java","permalink":"https://zxhtom.oschina.io/tags/Java/"}]},{"title":"java学习总结","date":"2016-02-27T08:13:00.000Z","path":"zxh/20160227.html","text":"最近在实训java，正好抽空把学到的只是进行了整理，在此声明次文章及后续java实训的内容大多是上课内容。 java学习总体最近在实训java，正好抽空把学到的只是进行了整理，在此声明次文章及后续java实训的内容大多是上课内容。第一章 抽象类、接口、内部类1、抽象类 1.1、 定义 ：抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。通常在编程语句中用 abstract 修饰的类是抽象类。在C++中，含有纯虚拟函数的类称为抽象类，它不能生成对象；在java中，含有抽象方法的类称为抽象类，同样不能生成对象。抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色 2、举例 ：自然界下最聪明的当属人类，除了人类还有其他的生物，今天我来举个例子，比如说动物，这是一个概括性词。我们日常说的动物并不是特质什么，而是对猫、狗、羊。。。。。。。这些东西的统称，这里我们java中有个专有名词—-抽象类。在java中动物我们把它叫做抽象类，猫、狗、羊。。。。。。。这些就是这个抽象类下的具体类。每种动物具备不同特性。在java中继承抽象类的具体类就具有特有的方法。这些方法有继承抽象类的也有自己特有的。 1.3、 特点 ：在举例中我们可以看出抽象类的特点 3.1、抽象类和必须用abstract修饰 格式 abstact class Demo1{} 类 public abstact void eat(){} 方法 3.2、抽象类是抽象方法既不充分也不必要条件 也就是说抽象类不一定具有抽象函数 有抽象函数的类也不一定是抽象类 3.3、抽象类不能实例化对象 可以用抽象类定义对象用具体类实列化 3.4、抽象类的子类 要么是抽象类 要么是重写抽象类中的抽象方法 3.5抽象类成员特点 成员变量 可以是变量也可以常量 构造方法 可以有构造方法但是这个构造方法是为了方便子类继承调用的，并不能用来实例化对象 成员变量 可以有抽象方法也可以有飞抽象方法下面是我实训老师给的课堂作业。想自学java的伙伴可以尝试联系一下，很简单的。 2、接口 2.1描述:继续回到我们的猫狗案例，我们想想狗一般就是看门，猫一般就是作为宠物了，对不。但是，现在有很多的驯养员或者是驯兽师，可以训练出：猫钻火圈，狗跳高，狗做计算等。而这些额外的动作，并不是所有猫或者狗一开始就具备的，这应该属于经过特殊的培训训练出来的，对不。所以，这些额外的动作定义到动物类中就不合适，也不适合直接定义到猫或者狗中，因为只有部分猫狗具备这些功能。所以，为了体现事物功能的扩展性，Java中就提供了接口来定义这些额外功能，并不给出具体实现，将来哪些猫狗需要被培训，只需要这部分猫狗把这些额外功能实现即可。 2.2接口特点: 首先接口是通关关键字interface来定义的，也就是说只要有interface修饰的类就是接口了，这个好识别吧。 格式：interface 接口名{} 另外当我们调用接口的时候我们需要用implements关键字 格式：class 类名 implements 接口名{} 接口类不能实例化对象 接口和抽象类在这方面有点像，都是通过子类中的具体类来实现实列化的 接口的子类 要么抽象类 要么是重写接口中的抽象方法 2.3接口成员特点： 成员变量 只能是常量（默认修饰符 public static final） 构造方法 - 没有构造方法。接口的主要功能就是扩展，而没有具体存在所以不需要构造函数，但是有时候也需要用接口来定义对象是因为既然用接口了就一定有子类继承这个接口，所以接口定义的对象实际上就是子类的对象 成员方法 只能是抽象方法 默认修饰符（public abstract ） 3、内部类 定义：顾名思义将类定义在其他类中 内部类成员访问特点： 内部类可以直接访问外部类的成员，包括私有。 外部类要访问内部类的成员，必须创建对象 种类：成员内部类+局部内部类 相关问题： 类与类,类与接口以及接口与接口的关系 类与类 类与类之间只能进行单继承，但是可以多层继承 类与接口 可以单实现也可以多实现，也可以多继承 接口与接口 可以单继承也可以多继承 抽象类和接口的区别 成员区别 抽象类可以常量也变量 抽象方法有抽象和飞抽象 接口只有常量和抽象方法 关系区别 类与类 单继承+多继承 类与接口 单实现+多实现 接口与接口 单继承+多继承 设计理念区别 抽象类 体现的是“Is a”的关系，有共性 接口 被实现体现 “Like a”的关系，有扩展性 package cn.edu.hysf; interface Controlw { void contr(); } class SCDP { private Controlw controlw; public SCDP(Controlw c) { this.controlw=c; } public void contr() { controlw.contr(); } } class wendu implements Controlw { private int t; public wendu(int t) { this.t=t; } public void contr() { if(t&gt;28) System.out.println(&quot;开启制冷模式&quot;); else if(t&lt;20) System.out.println(&quot;开启制热模式&quot;); } } public class test02 { public static void main(String[] args) { // TODO Auto-generated method stub wendu w=new wendu(19); SCDP scdp=new SCDP(w); scdp.contr(); } } 上面的大棚控温练习代码 以上是第一章内容，内部类个人觉得没必要讲的太详细。所以那个地方就省略了。以上内容来自老师PPT ，其中代码都是自己写，属于原创！大家觉得好的话，就赞一下哈！","tags":[{"name":"Java","slug":"Java","permalink":"https://zxhtom.oschina.io/tags/Java/"}]},{"title":"欢迎使用Markdown编辑器写博客","date":"2016-02-27T07:05:00.000Z","path":"zxh/20160227.html","text":"欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ###定义列表 Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如： @requires_authorization def somefunc(param1=&#39;&#39;, param2=0): &#39;&#39;&#39;A docstring&#39;&#39;&#39; if param1 &gt; param2: # interesting print &#39;Greater&#39; return (param2 - param1 + 1) or None class SomeClass: pass &gt;&gt;&gt; message = &#39;&#39;&#39;interpreter ... prompt&#39;&#39;&#39; ###脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。 块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 张三-&gt;李四: 嘿，小四儿, 写博客了没? Note right of 李四: 李四愣了一下，说： 李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： st=&gt;start: 开始 e=&gt;end: 结束 op=&gt;operation: 我的操作 cond=&gt;condition: 确认？ st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 ##浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入","tags":[{"name":"markdown","slug":"markdown","permalink":"https://zxhtom.oschina.io/tags/markdown/"}]},{"title":"减谈迷宫C++","date":"2015-04-07T05:23:00.000Z","path":"zxh/20150407.html","text":"今天老师让做了个迷宫问题，我一看到就发现和我之前写过的一个程序是一样 的，但是在后来编写的时候有一个地方搞错了，最后下课了我还是没有正确的编写好，然后今天回来之后自己有看了一下，现在已经解决了。 #ifndef DIRECTION_H #define DIRECTION_H #include&lt;iostream&gt; using namespace std; struct node { int a; int b; }; class Direction { public: Direction(); ~Direction(); void DFS(int n, int m); void udlr(int &amp;n, int &amp;m, int num); void durl(int &amp;n, int &amp;m, int num); void output(); private: int **a; int **visit; node zxh[64]; int count1; }; Direction::Direction() { count1 = 0; a = new int*[8]; visit = new int*[8]; for (int i = 0; i&lt;8; i++) { a[i] = new int[8]; visit[i] = new int[8]; } for (int i = 0; i&lt;8; i++) { zxh[i].a = -1; zxh[i].b = -1; } int b[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0 }; for (int i = 0; i&lt;8; i++) { for (int j = 0; j&lt;8; j++) { a[i][j] = b[i * 8 + j]; visit[i][j] = 0; } } } Direction::~Direction() {} void Direction::udlr(int &amp;n, int &amp;m, int num) { if (num == 1) n--; else if (num == 2) n++; else if (num == 3) m--; else m++; }//著名方向 void Direction::durl(int &amp;n, int &amp;m, int num) { if (num == 1) n++; else if (num == 2) n--; else if (num == 3) m++; else m--; }//著名方向 void Direction::output() { int num = 0; while (zxh[num].a != -1) { if (num % 7 == 0) cout &lt;&lt; endl; cout &lt;&lt; &quot;(&quot; &lt;&lt; zxh[num].a &lt;&lt; &quot;,&quot; &lt;&lt; zxh[num].b &lt;&lt; &quot;)&quot;&lt;&lt;&quot; &quot;; num++; } } void Direction::DFS(int n, int m) { if (n == 7 &amp;&amp; m == 7) { output(); cout &lt;&lt; endl; return; } else { for (int i = 1; i &lt; 5; i++) { udlr(n, m, i); if (n &gt;= 0 &amp;&amp; n &lt; 8 &amp;&amp; m &gt;= 0 &amp;&amp; m &lt; 8 &amp;&amp; a[n][m] == 0) { zxh[count1].a = n; zxh[count1].b = m; count1++; a[n][m] = 1; DFS(n, m); a[n][m] = 0; count1--; zxh[count1].a = -1; zxh[count1].b = -1; } durl(n, m, i); } } } #endif +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #include&quot;Direction.h&quot; #include&lt;iostream&gt; using namespace std; int main() { Direction z; z.DFS(0,0); return 0; }","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"哈夫曼树","date":"2014-11-08T16:23:00.000Z","path":"zxh/20141109.html","text":"关于哈夫曼树其基本定义我就在这不多说了，我写的这个哈夫曼树没有太多的功能， 就是我们参考书上的一个作业，就俩个功能，一个是表示孩子双亲表示法，，还有就是吧这个最有二叉树给画出来，其他的就没有了。另外在今天我调试的时候发现我的代码还是有很多欠缺的地方的，比如哦说我的画图功能中就没有办法完整的输出，而是无法输出最后四个结点。原因我还在寻找，下面就哈夫曼树我来谈谈我当时的构思：首先我是吧他当作一个二叉树来写的。我首先申明一个结点构造的结点函数element，在element中我全部都是用的int 来定义的，因为在哈发满树中我们需要的是每个节点的权值，所以我们就不需要用到类模板 了，而是直接用int来解决这个类。然偶就是在这个类中添砖加瓦的事情了。自己想要什么函数，在里面申明解释就行了。我在构造函数的时候其中有selected和画图函数比较难搞。下面#ifndef HFMTREE_H #define HFMTREE_H const int Max = 100; #include&quot;BiTree.h&quot; #include&lt;iostream&gt; using namespace std; struct element { int weight; int lchild, rchild, parent; }; class HfmTree { public: HfmTree(int size); void Creat(int n); void SeLect(int k, int &amp;s1, int &amp;s2 ,int z); void reset(int size); void print(int size); void Makeary(int size); void printInl(int size, int i); void printInr(int size, int i); void Build(int size); private: int m1; int top = 0; element *root; int maxsize; int *pz; element *root3; }; void HfmTree::reset(int size) { int m; m = 2 * size - 1; pz = new int[m]; int i; pz[0] = root[m].weight; for (i = 1; i &lt; m; i++) pz[i] = 0; } void HfmTree::Build(int size) { BiTree&lt;int&gt; zxh1(pz, 2 * size - 1, 0); cout &lt;&lt; zxh1; } void HfmTree::printInl(int m, int i) { if (m == -1)return; if (m!=-1) { //pz[i - 1] = root[m].weight; pz[2 * i - 1] = root[root[m].lchild].weight; pz[2 * i] = root[root[m].rchild].weight; m = root[m].lchild; printInl(m, 2 * i); m = root[m].lchild; } } void HfmTree::printInr(int m, int i) { if (m == -1)return; if (m!=-1) { //pz[i - 1] = root[m].weight; pz[2 * i - 1] = root[root[m].lchild].weight; pz[2 * i] = root[root[m].rchild].weight; m = root[m].rchild; printInr(m, 2*i+1); m = root[m].rchild; } } void HfmTree::Makeary(int size) { int m; m = 2 * size - 1; pz = new int[m]; int i; for (i = 1; i &lt;= m; i++) pz[i] = 0; i = 1; while (root[m].parent != size-1) { if (m == -1)break; pz[i-1] = root[m].weight; i=2*i; m = root[m].lchild; } m = 2 * size - 1; i = 1; while (root[m].parent != size-1) { if (m == -1)break; pz[i-1] = root[m].weight; i = 2 * i + 1; m = root[m].rchild; } BiTree&lt;int&gt; zxh1(pz, 2*size+1, 0); cout &lt;&lt; zxh1; } void HfmTree::SeLect(int k, int &amp;s1, int &amp;s2 ,int z) { int w1, w2, i = 1,j; w1 = w2 = Max; //s1 = s2 = i; for (i = 1; i &lt;= k; i++) { //if (i == s1 || i == s2)continue; if (root[i].parent==-1) { if (root[i].weight &lt; w1) { w2 = w1; w1 = root[i].weight; s2 = s1; s1 = i; //w1,s1是对应的，且他们的weight是较小者 } else if (root[i].weight &lt; w2) { w2 = root[i].weight; s2 = i; } } } } void HfmTree::Creat(int n) { int *w1; int i,m,*w,s1,s2; element *p; if (n &lt; 1)throw&quot;构建有误！&quot;; w = new int[2 * n - 1]; w1 = new int[2 * n - 1]; m = 2 * n - 1; //n个结点过程中有2*n-1个结点 m1 = m; root = new element[m + 1]; for (i =1; i &lt;= 2 * n - 1; i++) { //root[i].weight = NULL; root[i].lchild = -1; root[i].rchild = -1; root[i].parent = -1; } for (p = root + 1, i = 1; i &lt;= n; i++, p++) { cout &lt;&lt; &quot;请输入全职:&quot; &lt;&lt; endl; cin &gt;&gt; w[i]; p-&gt;weight = w[i]; p-&gt;lchild = -1; p-&gt;rchild = -1; p-&gt;parent = -1; } for (i = n+1 ; i &lt;= m; i++, p++) { p-&gt;weight = NULL; p-&gt;lchild = -1; p-&gt;rchild = -1; p-&gt;parent = -1; } for (i = n+1 ; i &lt;= m; i++) { SeLect(i-1 , s1, s2,m); root[s1].parent = i-1; root[s2].parent = i-1; root[i].weight = root[s1].weight + root[s2].weight; root[i].lchild = s1; root[i].rchild = s2; } for (int i = 1; i &lt;= n; i++) { w1[i-1] = w[n - i + 1]; } } HfmTree::HfmTree(int size) { Creat(size); } void HfmTree::print(int size) { int m, i; m = 2 * size - 1;//树结点总个数。 cout &lt;&lt; &quot;构建的哈夫曼树为&quot; &lt;&lt; endl; cout &lt;&lt; &quot;no&quot; &lt;&lt;&quot; &quot;&lt;&lt; &quot;weight&quot; &lt;&lt;&quot; &quot;&lt;&lt;&quot;Parent&quot;&lt;&lt;&quot; &quot;&lt;&lt; &quot;lchild&quot; &lt;&lt;&quot; &quot;&lt;&lt; &quot;rchild&quot; &lt;&lt; endl; for (i = 1; i &lt;= m; i++){ cout &lt;&lt; i &lt;&lt;&quot; &quot;&lt;&lt; root[i].weight &lt;&lt;&quot; &quot;&lt;&lt;root[i].parent&lt;&lt;&quot; &quot;&lt;&lt; root[i].lchild &lt;&lt;&quot; &quot;&lt;&lt; root[i].rchild &lt;&lt; endl; } } #endif —————————————————————————————————————————————————————————————————————— #include&quot;HfmTree.h&quot; //#include&quot;BiTree.h&quot; #include&lt;iostream&gt; using namespace std; void main() { int num; cout &lt;&lt; &quot;请输入您想构造的哈夫曼树的结点个数(num):&quot;; cin &gt;&gt; num; HfmTree zxh(num); zxh.print(num); //zxh.Makeary(num); zxh.reset(num); zxh.printInl(2*num-1,1); zxh.printInr(2*num-1, 1); zxh.Build(num); } 主要用代码解释","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"二叉树的算法与讲法","date":"2014-11-02T13:22:00.000Z","path":"zxh/20141102.html","text":"二叉树属于数据结构中层次性的数据关系， 他又祖先——后代，上级——下属，整体——部分以及其他类似的关系，树结构在计算机领域中有着广泛的应用，例如在编译程序中庸语法树来表示元程序的语言结构，在数据挖掘中庸决策树来进行数据分类等等。在我的前一个博客中也有提到就是二叉树的相关知识重点。不清楚的同行可以参考我的文章。其中若有不妥之处，还请大家指点。下面是我在学习二叉树的时候编写的二叉树的几个常见的功能的函数，以及他的一些构造函数等等。 #ifndef BITREE_H #define BITREE_H #include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; template &lt;typename T&gt; struct BiNode { T data; BiNode&lt;T&gt; *lchild, *rchild; //利用递归的方法进行结点的构造 }; template&lt;typename T&gt; class BiTree { template&lt;typename T&gt; friend ostream &amp; operator&lt;&lt;(ostream &amp;os, BiTree&lt;T&gt; &amp;bt); public: BiTree(T none); //构造一个空的二叉树 BiTree(T ary[], int num, T none); //构造一个num个结点的二叉树 ~BiTree(); //析构函数 void Parent(T x); //与pretected中的ParentIn对应 void print(ostream &amp;os); //遍历操作 void Count(); //与protected中的CountIn对应 void PreOrderPrint(); //与protected中的PreOrderPrintIn对应 void Depth(); //与protected中的DepthIn对应 void PostOrderN(); //与protected中的PostOrderN对应 void Delete(T x); //与pretected中的DeleteIn对应 protected: void CountIn(BiNode&lt;T&gt; *root); void Creat(BiNode&lt;T&gt; * &amp;root, T none); BiNode&lt;T&gt; *Build(T ary[], int num, T none, int idx); BiNode&lt;T&gt; *ParentIn(BiNode&lt;T&gt; * root, T x); //查询某结点的双 亲 void Release(BiNode&lt;T&gt;* &amp;root); void printIn(ostream &amp;os, BiNode&lt;T&gt; *root, int depth); //和上述的四个函数 具有对应的功能 void PreOrderPrintIn(BiNode&lt;T&gt; *root); //求二叉树的叶子节 点输出 int DepthIn(BiNode&lt;T&gt; *root); //求二叉树的深度 void PostOrderNIn(BiNode&lt;T&gt; *root); //求二叉树的逆后 序输出遍历的算法 void DeleteIn(BiNode&lt;T&gt; * root, T x); //求二叉树的删除 的算法 private: BiNode&lt;T&gt; *p = NULL; BiNode&lt;T&gt; *rootPtr; //申请一个跟指针 int count = 0; //全局变量在Count函数中用 int highl = 0,highr=0; //全局变量在Depth函数中用 }; template&lt;typename T&gt; void BiTree&lt;T&gt;::CountIn(BiNode&lt;T&gt; *root) { if (root != NULL) { CountIn(root-&gt;lchild); count++; CountIn(root-&gt;rchild); /*在左右之间count++是在左子数递归结束之时才加 在最后一个左子数结束的时候就是+*/ } } template&lt;typename T&gt; void BiTree&lt;T&gt;::Creat(BiNode&lt;T&gt; * &amp;root, T none) //子数的创建 { T x; cout &lt;&lt; &quot;请输入（&quot; &lt;&lt; none &lt;&lt; &quot;表示空）:&quot;; cin &gt;&gt; x; if (x == none) root == NULL; //如果输入的是空的话，那么这个二叉树 就是空二叉树 else //下面准备实现元素的插入 { root = new BiNode&lt;T&gt;; //首先让根指针变为根结点 root-&gt;data = x; //对结点进行赋值 Creat(root-&gt;lchild, none); //创建根结点的左子数，此时左子数为空 Creat(root-&gt;rchild, none); //创建根结点的右子数，此时右子数为空 } //当前结点赋值成功，且其子数创建也成功 } //次函数不是循环创建，只是在根结点进行赋值与 子数的创建，下面的操作靠其他 template&lt;typename T&gt; BiNode&lt;T&gt; *BiTree&lt;T&gt;::Build(T ary[], int num, T none, int idx) { /*ary就表示数组，num表示数组长度，none表示空，idx表示结点的序号 在进行第一次操作的时候理所应当的赋值为1*/ BiNode&lt;T&gt; *p; //申请指针p int left, right; //定义左右 if (idx - 1 &lt; num&amp;&amp;ary[idx - 1] != none)//为什么此处是idx-1呢？？？？ { /*因为数组从0开始，又为了idx能够按倍数增长，所以idx从一开始 则在判断的时候自然就要减去一了，方便后面的赋值*/ p = new BiNode&lt;T&gt;; //将指针p结点划 p-&gt;data = ary[idx - 1]; //将该结点的数值部分赋值为数组中对应 的元素 left = 2 * idx; right = 2 * idx + 1; //确保了左右子数的左右性 p-&gt;lchild = Build(ary, num, none, left); p-&gt;rchild = Build(ary, num, none, right);//开始进行赋值 return p; } else return NULL; //else表示数组已经赋值完了，没有值在来扩建了 所以就返回空 } template&lt;typename T&gt; void BiTree&lt;T&gt;::Release(BiNode&lt;T&gt; * &amp; root)//有释放的意思 { if (root != NULL) //首先从根结点开始 { Release(root-&gt;lchild); Release(root-&gt;rchild); delete root; //后续遍历性的释放 } } template&lt;typename T&gt; void BiTree&lt;T&gt;::Count() { CountIn(rootPtr); cout &lt;&lt; &quot;|&quot; &lt;&lt; setw(5) &lt;&lt; &quot;该树结点数为:&quot; &lt;&lt; count &lt;&lt;setw(5)&lt;&lt; &quot;|&quot; &lt;&lt; endl; } template&lt;typename T&gt; BiTree&lt;T&gt;::BiTree(T none) { Creat(rootPtr, none); } template &lt;typename T&gt; BiTree&lt;T&gt;::BiTree(T ary[], int num, T none) { rootPtr = Build(ary, num, none, 1); //none用来传递空 } template &lt;typename T&gt; BiTree&lt;T&gt;::~BiTree() { Release(rootPtr); } template &lt;typename T&gt; void BiTree&lt;T&gt;::printIn(ostream &amp;os, BiNode&lt;T&gt; *root, int depth) { if (root != NULL) { printIn(os, root-&gt;rchild, depth + 1); for (int i = 0; i &lt; 4 * (depth - 1); i++) os &lt;&lt; &quot; &quot;; os &lt;&lt; &quot;*--&quot; &lt;&lt; root-&gt;data &lt;&lt; endl; //这句是函数共同所有 printIn(os, root-&gt;lchild, depth+1); } } template&lt;typename T&gt; void BiTree&lt;T&gt;::PreOrderPrintIn(BiNode&lt;T&gt; *root) { if (root != NULL) { if (root-&gt;lchild==NULL&amp;&amp;root-&gt;rchild==NULL) cout &lt;&lt;setw(3)&lt;&lt; root-&gt;data; //先输出根结点 数据 PreOrderPrintIn(root-&gt;lchild); //然后在开始进行左结点输出 PreOrderPrintIn(root-&gt;rchild); //然后右结点输出 } } template&lt;typename T&gt; void BiTree&lt;T&gt;::PreOrderPrint() { PreOrderPrintIn(rootPtr); } template&lt;typename T&gt; int BiTree&lt;T&gt;::DepthIn(BiNode&lt;T&gt; *root) { if (root == NULL)return 0; //标志访问结束 else //标志继续向下访问 { highl = DepthIn(root-&gt;lchild);//为何在这一步就可以进行 赋值？ highr = DepthIn(root-&gt;rchild); if (highl &gt; highr) return highl + 1; else return highr + 1; } } template&lt;typename T&gt; void BiTree&lt;T&gt;::Depth() { cout&lt;&lt;DepthIn(rootPtr); } template&lt;typename T&gt; void BiTree&lt;T&gt;::PostOrderNIn(BiNode&lt;T&gt; * root) { if (root != NULL) { cout &lt;&lt; setw(3) &lt;&lt; root-&gt;data; PostOrderNIn(root-&gt;rchild); PostOrderNIn(root-&gt;lchild); } } template&lt;typename T&gt; void BiTree&lt;T&gt;::PostOrderN() { PostOrderNIn(rootPtr); } template&lt;typename T&gt; BiNode&lt;T&gt; *BiTree&lt;T&gt;::ParentIn(BiNode&lt;T&gt; *root, T x) { if (root != NULL) { if (root-&gt;data == x)cout&lt;&lt;p-&gt;data; else { p = root; ParentIn(root-&gt;lchild, x); ParentIn(root-&gt;rchild, x); } } return 0; } template&lt;typename T&gt; void BiTree&lt;T&gt;::Parent(T x) { ParentIn(rootPtr, x); } template&lt;typename T&gt; void BiTree&lt;T&gt;::DeleteIn(BiNode&lt;T&gt; * root, T x) { if (root != NULL) { if (root-&gt;data == x) { if (p == NULL) root = NULL; else if (p-&gt;lchild == root) p-&gt;lchild = NULL; else p-&gt;rchild = NULL; } else { p = root; DeleteIn(root-&gt;lchild, x); DeleteIn(root-&gt;rchild, x); } } } template&lt;typename T&gt; void BiTree&lt;T&gt;::Delete(T x) { DeleteIn(rootPtr, x); } template&lt;typename T&gt; void BiTree&lt;T&gt;::print(ostream &amp; os) { printIn(os, rootPtr, 1); } template&lt;typename T&gt; ostream &amp; operator&lt;&lt;(ostream &amp; os, BiTree&lt;T&gt; &amp;bt) { bt.print(os); return os; } #endif ************************************************************************ #include&quot;BiTree.h&quot; #include&lt;iostream&gt; using namespace std; void main() { char ary[] = { &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;#&#39;, &#39;E&#39;, &#39;F&#39;, &#39;#&#39;, &#39;G&#39;, &#39;#&#39;, &#39;#&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;#&#39;, &#39;#&#39;, &#39;L&#39; }; char zxh,gmy; BiTree&lt;char&gt; myBTree(ary, 18, &#39;#&#39;); cout &lt;&lt; myBTree &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; //cout &lt;&lt; &quot;++++++++++++++++++++++++++++++++++++++++++++++++++&quot; &lt;&lt; endl; cout &lt;&lt; &quot;求二叉树结点个数(第一题算法)&quot; &lt;&lt; endl; myBTree.Count(); //cout &lt;&lt; &quot;++++++++++++++++++++++++++++++++++++++++++++++++++&quot; &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; //cout &lt;&lt; &quot;++++++++++++++++++++++++++++++++++++++++++++++++++&quot; &lt;&lt; endl; cout &lt;&lt; &quot;求二叉树叶子节点次序(第二题算法)&quot;&lt;&lt;endl; cout &lt;&lt; &quot;该树的叶子结点按前序次序de方式排列输出为:&quot;; myBTree.PreOrderPrint(); cout &lt;&lt; endl; //cout &lt;&lt; &quot;++++++++++++++++++++++++++++++++++++++++++++++++++&quot; &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;求二叉树深度(第三题揭发):&quot; &lt;&lt; endl; cout &lt;&lt; &quot;这个二叉树的深度为:&quot;&lt;&lt;endl; myBTree.Depth(); cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;求二叉树后序逆遍历(第四道题解法):&quot; &lt;&lt; endl; cout &lt;&lt; &quot;该二叉树的逆向后序遍历为:&quot; &lt;&lt; endl; myBTree.PostOrderN(); cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;求二叉树某结点双亲(第五道题解法):&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入您想查询的结点(！注：区分大小写):&quot;; cin &gt;&gt; zxh; cout &lt;&lt; &quot;您查询的结点为:&quot; &lt;&lt; zxh &lt;&lt; &quot;他的双亲为:&quot; &lt;&lt; endl; myBTree.Parent(zxh); cout &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入您想删除的字符:&quot;; cin &gt;&gt; gmy; myBTree.Delete(gmy); cout &lt;&lt; &quot;删除后的二叉树为:&quot; &lt;&lt; endl; cout &lt;&lt; myBTree; } 个人小结：第一次接触到二叉树这个东西，我明显的感觉到了与前面学的顺序表单链表有所不同了，最大的特点就是二叉树中函数都是成对的，因为原始的二叉树函数在主函数中是无法调用的，所以他就需要在类的构造中在定义一个与之对应的函数，以此方便在主函数中调用了。但说白了二叉树呢，也没什么难得，只要我们明白其中的原理，在多多的练习就很容易解决了。","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"二叉树逻辑结构重点","date":"2014-11-01T04:24:00.000Z","path":"zxh/20141101.html","text":"看看清单 二叉树1.满二叉树：在二叉树中所有的根结点都有左右子数。并且所有的叶子都在同一层上2.完全二叉树：编号为i的结点与同深度的满二叉树中编号为i的元素位置相同。3.满二叉树特点： a.叶子只能出现在最下面一层； b.只有度为0或2的4.完全二叉树特点： a.叶子只能出现在最下两层,且最下层的叶子主要集中在左侧的连续位置 b.若有且仅有一个度为1的结点，并且该节点只能有左结点。5.二叉树性质： a.二叉树的第i层上最多有2^（i-1）个结点 b.一颗深度为K的二叉树中，最多有2^k-1个结点，最少有K个结点 （出现最多的情况是满二叉树 ，最少的情况是斜二叉树） c.二叉树中，如果叶子的结点的个数为n0,度=2的结点个数为n2,则有n0=1+n2; d.具有n个结点的完全二叉树的深度为【log2n(以二为底n的对数)】+1 e.具有n个结点的完全二叉树中的结点从1开始按层标号，任意的编号为i的结点有： @1.如果i&gt;1,结点i的双亲的编号为【i/2】，否则结点i就是根结点，无双亲； @2.若2i&lt;=n,结点i的左孩子的编号为2i，否则无左孩子。 @3.若2i+1&lt;=n,结点i的右孩子编号为2i+1,否则无右孩子。 *6.二叉树的遍历：从根结点出发，按照某种次序访问书中的所有的结点，每个结点都被访问密且仅被访问一次。因为二叉树有根结点和左右子数，所有遍历就有三种方式：前序遍历||中序遍历||后序遍历。另外从另一个角度考虑可以按层遍历。所以一共四种遍历方式。 a.前序遍历：根结点-&gt;左结点-&gt;右结点 b.中序遍历：左结点-&gt;根结点-&gt;右结点 c.后序遍历：左结点-&gt;右结点-&gt;根结点 d.层序遍历：按曾从上到下，在每层中按从左到右的顺序遍历。","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"数据结构循环链表","date":"2014-10-30T05:39:00.000Z","path":"zxh/20141030.html","text":"循环链表和单链表没有本质上的差别。 唯一不同的链表的最后不再是空的了，而是指向了first头指针。只有这样我们才会实现链表的循环功能，那么问题来了，我们在下面的函数功能中我们只是需要把里面用的头指针的重用名换到first-&gt;next中，而且其中的计数器count也从1开始计数，这样就避免了在while的循环中第一步实行不下去。废话不多说。详细看wo的代码吧。 #ifndef CirLinkList_H #define CirLinkList_H #include&lt;iostream&gt; using namespace std; template&lt;typename T&gt; struct Node{//结点 T data; Node&lt;T&gt; * next; }; template&lt;typename T&gt; class CirLinkList {//无头结点的循环单链表 template&lt;typename T&gt; friend ostream &amp; operator&lt;&lt;(ostream &amp;,CirLinkList&lt;T&gt; &amp;); public: CirLinkList(); //创建空循环单链表（即：first指向空指针）。 CirLinkList(T a[],int n); //建立含n个元素的循环单链表。 ~CirLinkList(); //析构函数，清除所有结点。 int Length(); //求表长度。 T Get(int i); //取表中第i个元素。10分 void Insert(int i,T &amp; x);//在第i个结点之后，插入新元素。 T Delete(int i); //删除第ｉ个元素。 bool isEmpty(); //判断表是否为空。 void DelTheSame(); //删除表中相同元素，仅保留一个。 private: Node&lt;T&gt; * first; }; template&lt;typename T&gt; ostream &amp; operator&lt;&lt;(ostream &amp; os,CirLinkList&lt;T&gt; &amp; l){ Node&lt;T&gt; * p=l.first-&gt;next; if(p!=l.first){ do{ os&lt;&lt;p-&gt;data&lt;&lt;&quot;,&quot;; p=p-&gt;next; }while(p!=l.first); } else os&lt;&lt;endl; return os; } template&lt;typename T&gt; CirLinkList&lt;T&gt;::CirLinkList() { Node&lt;T&gt; *first; first=new Node&lt;T&gt;; first-&gt;next=first;//初始化循环单链表 } template&lt;typename T&gt; CirLinkList&lt;T&gt;::CirLinkList(T a[],int n) { Node&lt;T&gt; *r,*s; first=new Node&lt;T&gt;; r=first; for(int i=0;i&lt;n;i++) { s=new Node&lt;T&gt;; s-&gt;data=a[i]; r-&gt;next=s; r=s; } r-&gt;next=first;//这里的first一直没变 } template&lt;typename T&gt; CirLinkList&lt;T&gt;::~CirLinkList() { Node&lt;T&gt; *q=NULL; while(first!=NULL) { q=first; first=first-&gt;next; delete q; //可能有问题？ } } template&lt;typename T&gt; int CirLinkList&lt;T&gt;::Length() { Node&lt;T&gt; *p=first-&gt;next; int count=0; while(p!=first) { p=p-&gt;next; count++; } return count; } template&lt;typename T&gt; T CirLinkList&lt;T&gt;::Get(int i) { Node&lt;T&gt; *p=first-&gt;next; int count=1; while(p!=first&amp;&amp;count&lt;i) { p=p-&gt;next; count++; } if(p==first)throw&quot;位置&quot;; else return p-&gt;data; } template&lt;typename T&gt; void CirLinkList&lt;T&gt;::Insert(int i,T &amp; x) { Node&lt;T&gt; *p=first-&gt;next; int count=1; while(p!=first&amp;&amp;count&lt;i) { p=p-&gt;next; count++; } if(p==first)throw&quot;位置&quot;; else { Node&lt;T&gt; *s; s=new Node&lt;T&gt;; s-&gt;data=x; s-&gt;next=p-&gt;next; p-&gt;next=s; } } template&lt;typename T&gt; T CirLinkList&lt;T&gt;::Delete(int i) { Node&lt;T&gt; *p=first-&gt;next; T x;int count=1; while(p!=first&amp;&amp;count&lt;i-1) { p=p-&gt;next; count++; } if(p==first||p-&gt;next==first)throw&quot;位置&quot;; else { Node&lt;T&gt; *q; q=p-&gt;next; x=q-&gt;data; p-&gt;next=q-&gt;next; delete q; return x; } } template&lt;typename T&gt; bool CirLinkList&lt;T&gt;::isEmpty() { Node&lt;T&gt; *q; if(first=first-&gt;next) return 0; } template&lt;typename T&gt; void CirLinkList&lt;T&gt;::DelTheSame() { Node&lt;T&gt; *q=first-&gt;next; while(q!=first) { Node&lt;T&gt; *s=q-&gt;next; Node&lt;T&gt; *r; r=s; if(q==r) { delete s; r=r-&gt;next; } } } #endif **************************************************** #include&lt;iostream&gt; #include&quot;CirLinkList.h&quot; using namespace std; int main(){ int ary[]={2,4,6,8,12,32,43,6,9,2,7},x=11; CirLinkList&lt;int&gt; myLink(ary,11); cout&lt;&lt;&quot;链表内容：&quot;&lt;&lt;myLink&lt;&lt;endl; cout&lt;&lt;&quot;链表长度：&quot;&lt;&lt;myLink.Length()&lt;&lt;endl; cout&lt;&lt;&quot;第11号元素：&quot;&lt;&lt;myLink.Get(11)&lt;&lt;endl; myLink.Insert(3,x); cout&lt;&lt;&quot;在3号元素后插入11后，链表内容：&quot;&lt;&lt;myLink&lt;&lt;endl; cout&lt;&lt;&quot;被删除的5号元素内容：&quot;&lt;&lt;myLink.Delete(5)&lt;&lt;endl; cout&lt;&lt;&quot;链表当前内容：&quot;&lt;&lt;myLink&lt;&lt;endl; myLink.DelTheSame(); cout&lt;&lt;&quot;删除相同元素后，链表内容：&quot;&lt;&lt;myLink&lt;&lt;endl; if(myLink.isEmpty()) cout&lt;&lt;&quot;空:&quot;; return 0; }","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"数据结构单链表","date":"2014-10-26T15:16:00.000Z","path":"zxh/20141026.html","text":"直接贴代码 ``` #ifndef LINKLIST_H #define LINKLIST_H #includeusing namespace std;template struct Node{ T data; Node next;};template class LinkList{public: LinkList(); //无参构造函数，建立只有头结点的空链表 LinkList(T a[], int n); //有参构造函数，建立由n个元素的单链表 ~LinkList(); //析构函数 int Length(); //求单链表的长度 T Get(int i); //按位查找，查找单链表中的第i个元素的数值 int Locate(T x); //查找该元素在单链表中的位置 void Insert(int i, T x); //在第i个位置插入该元素 T Delete(int i); //删除第i个元素 void PrintList(); //打印单链表private: Node first; //创建单链表的头指针};template LinkList::LinkList(){ Node first; //申明头结点 first = new Node; //生成头结点 first-&gt;next = NULL; //初始化头节点}template LinkList::LinkList(T a[], int n){ Node r, s; //申明两个临时结点 first = new Node; //生成头结点 r = first; //尾指针初始化 for (int i = 0; i &lt; n; i++) { s = new Node; //生成S结点来存储数组中对应的元素 s-&gt;data = a[i]; //将数组中对应的元素赋值到对应结点的数值部位 r-&gt;next = s; r = s; //上两部是将s插入到终端结点之后 } r-&gt;next = NULL;}template LinkList::~LinkList(){ Node q = NULL; //建立一个空的结点 while (first != NULL) //该循环释放结点的存储空间 { q = first; first = first-&gt;next; delete q; }}template int LinkList::Length(){ Nodep=first-&gt;next; int count = 0; //初始化 while (p != NULL) { p = p-&gt;next; //p指针后移 count++; } return count;}template T LinkList::Get(int i){ Node p = first-&gt;next; int count = 1; while (p != NULL&amp;&amp;count &lt; i) { p = p-&gt;next; count++; } if (p == NULL)throw”位置”; else return p-&gt;data; //单恋表中first是空结点，不算在单链表中的，所以第一个元素是在第一个结点中的。序号是对应的}template int LinkList::Locate(T x){ Node p = first-&gt;next; int count = 1; //上述初始化工作量 while (p != NULL) { if (p-&gt;data == x) return count; p = p-&gt;next; count++; } return 0; //推出循环查找，表示查找失败。}template void LinkList::Insert(int i, T x){ Node p = first; int count = 0; //上述初始化工作量 while (p != NULL&amp;&amp;count &lt; i - 1) { p = p-&gt;next; count++; } if (p == NULL)throw”位置”; else { Node s; s = new Node; s-&gt;data = x; s-&gt;next = p-&gt;next; p-&gt;next = s; }}template T LinkList::Delete(int i){ Node p = first; T x; int count = 0; while (p != NULL&amp;&amp;count &lt; i - 1) { p = p-&gt;next; count++; } if (p == NULL || p-&gt;next == NULL)throw”位置”; else { Node q; q = p-&gt;next; x = q-&gt;data; p-&gt;next = q-&gt;next; delete q; return x; }}template void LinkList::PrintList(){ Node p; p = first-&gt;next; while (p != NULL) { cout &lt;&lt; p-&gt;data&lt;&lt;”-&gt;”; p = p-&gt;next; }} #endif ******************************************************************* #include”LinkList.h” #include #includeusing namespace std;void main(){ int a[10] = { 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 }; int ch; LinkList zxh(a,10); cout &lt;&lt; “生成的单链表为:”; zxh.PrintList(); cout &lt;&lt; endl; cout &lt;&lt; “1-求长度”&lt;&lt;setw(17); cout &lt;&lt; “2-按位查找” &lt;&lt; endl; cout &lt;&lt; “3-按值查找” &lt;&lt; setw(15); cout &lt;&lt; “4-插入操作” &lt;&lt; endl; cout &lt;&lt; “5-删除操作” &lt;&lt; setw(15); cout &lt;&lt; “6-遍历操作” &lt;&lt; endl; cout &lt;&lt; “请输入您想进行的操作:”; cin &gt;&gt; ch; switch (ch) { case 1:zxh.Length(); break; case 2:int m1; cout &lt;&lt; “请输入您想按位查找的位号:”; cin &gt;&gt; m1; zxh.Get(m1); break; case 3: int m2; cout &lt;&lt; “请输入您想查找的值:”; cin &gt;&gt; m2; zxh.Locate(m2); break; case 4:int m3, m4; cout &lt;&lt; “请输入想插入的位置:”; cin &gt;&gt; m3; cout &lt;&lt; “请输入想插入的元素:”; cin &gt;&gt; m4; zxh.Insert(m3, m4); break; case 5: int m5; cout &lt;&lt; “请输入想删除的位置:”; cin &gt;&gt; m5; zxh.Delete(m5); break; case 6: zxh.PrintList(); }}```这个单恋表中我自己刚才测试了一下。基本上没什么大问题。但是好像在球长度的时候就不正确了。希望大家可以提出指证。","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"数据结构线性表","date":"2014-10-23T09:51:00.000Z","path":"zxh/20141023.html","text":"直接贴代码 #ifndef SEQLIST_H #define SEQLIST_H #include&lt;iostream&gt; using namespace std; const int Maxsize = 100; template&lt;typename T&gt; class SeqList { public: SeqList();//构造空链表 SeqList(T a[], int n); //构造长度为n的链表 ~SeqList(); int Length(){ return length; };//求线性表的长度 T Get(int i);//按位查找 int Locate(T x); void Insert(int i, T x);//插入操作中，在第i个元素插入x T Delete(int i);//删除第i个元素 void PrintList();//输出线性表 private: T data[Maxsize]; int length; }; template&lt;typename T&gt; SeqList&lt;T&gt;::SeqList()//构造空链表 { length = 0; } template&lt;typename T&gt; SeqList&lt;T&gt;::SeqList(T a[], int n) //构造长度为n的链表 { int i; if (n &gt; Maxsize)throw&quot;参数非法&quot;; for (i = 0; i &lt; n; i++) data[i] = a[i]; length = n; } template&lt;typename T&gt; SeqList&lt;T&gt;::~SeqList() { //delete[]data; } template&lt;typename T&gt; T SeqList&lt;T&gt;::Get(int i)//按位查找 { if (i&lt;1 &amp;&amp; i&gt;length)throw&quot;查找位置非法&quot;; else return data[i - 1]; } template&lt;typename T&gt; int SeqList&lt;T&gt;::Locate(T x) { int i; for (i = 0; i &lt; length;i++) if (data[i] == x)return i + 1; return 0; } template&lt;typename T&gt; void SeqList&lt;T&gt;::Insert(int i, T x)//插入操作中，在第i个元素插入x { int j; if (length &gt;= Maxsize)throw&quot;上溢&quot;; if (i&lt;1 || i&gt;length + 1)throw&quot;位置&quot;; for (j = length; j &gt;= i; j--) data[j] = data[j - 1]; data[i - 1] = x; length++; } template&lt;typename T&gt; T SeqList&lt;T&gt;::Delete(int i)//删除第i个元素 { int j; if (length == 0)throw&quot;下溢&quot;; if (i&lt;1 || i&gt;length)throw&quot;位置&quot;; T x = data[i-1]; for (j = i; j &lt; length; j++) data[j - 1] = data[j]; length--; return x; } template&lt;typename T&gt; void SeqList&lt;T&gt;::PrintList()//输出线性表 { int i; for (i = 0; i &lt; length; i++) cout &lt;&lt;&quot; &quot;&lt;&lt;data[i]; cout &lt;&lt; endl; } #endif **************************************************************************************************************** #include&quot;SeqList.h&quot; #include&lt;iostream&gt; using namespace std; void main() { int a[10] = { 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 }; int m, n; SeqList&lt;int&gt; zxh(a,10); cout &lt;&lt; &quot;构造的函数数组:&quot;; zxh.PrintList(); cout &lt;&lt; &quot;请输入您要插入的数字及其位置:&quot;; cin &gt;&gt; m &gt;&gt; n; zxh.Insert(n,m); cout &lt;&lt; &quot;更改后函数数组:&quot;; zxh.PrintList(); cout &lt;&lt; &quot;请输入您想删除的元素的位置:&quot;; cin &gt;&gt; m; zxh.Delete(m); cout &lt;&lt; &quot;更改后函数数组:&quot;; zxh.PrintList(); cout &lt;&lt; &quot;请输入您想查找的元素的位置:&quot;; cin &gt;&gt; m; cout &lt;&lt; &quot;您查询的元素:&quot;; cout &lt;&lt; zxh.Get(m) &lt;&lt; endl;; cout &lt;&lt; &quot;请输入您要查询的元素:&quot;; cin &gt;&gt; m; cout &lt;&lt; &quot;您要查询的元素的位置:&quot;; cout &lt;&lt; zxh.Locate(m) &lt;&lt; endl;; } 上面代码是线性表的主要能实现的功能，这个代码是学数据结构的基础代码。他主要调动了学者对线性表的认识，在刚开是编写的时候，我没有那个数组的构造函数，只有一个初始化的构造函数。在调用插入函数的时候我就一直没有办法实现元素的插入，因为在初始话的时候length变成了0，这就无法在线性表中进行插入。因为我是学完整张才回来便携的。我以为他和栈中的出栈入栈是一个原理。结果显示是我想错了。在线性表中length=0是初始化但是我们还是要在给他开辟一个长度供他实现基本操作的。最后一个问题就是在析构函数中我也是犯了同样的错误，在线性表中的析构函数是不需要任何东西的。","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"表达式求值","date":"2014-10-18T13:49:00.000Z","path":"zxh/20141018.html","text":"直接贴代码 #ifndef OPND_H #define OPND_H #include&lt;iostream&gt; using namespace std; template &lt;typename T&gt; class OPND { template &lt;typename T&gt; friend ostream &amp; operator&lt;&lt;(ostream &amp; os, OPND&lt;T&gt; &amp; bs); public: OPND(int size); ~OPND(); void Push(T x); T Pop(); private: int Num2; T *data; int top; }; template &lt;typename T&gt; ostream &amp; operator&lt;&lt;(ostream &amp; os, OPND&lt;T&gt; &amp; bs) { int i = bs.Num2; os &lt;&lt; bs.data[i-1]; return os; } template &lt;typename T&gt; OPND&lt;T&gt;::OPND(int size) { data = new T[size]; Num2 = size; top = -1; } template &lt;typename T&gt; OPND&lt;T&gt;::~OPND(){ delete[] data; } template &lt;typename T&gt; void OPND&lt;T&gt;::Push(T x) { if (top == Num2 - 1)throw&quot;上溢&quot;; data[++top] = x; } template &lt;typename T&gt; T OPND&lt;T&gt;::Pop() { if (top == -1)throw&quot;下溢&quot;; return data[top--]; } #endif #ifndef OPTR_H #define OPTR_H #include&lt;iostream&gt; using namespace std; template &lt;typename T&gt; class OPTR { template &lt;typename T&gt; friend ostream &amp; operator&lt;&lt;(ostream &amp; os, OPTR&lt;T&gt; &amp; bs); template &lt;typename T&gt; friend ostream &amp; operator&gt;(ostream &amp; os, OPTR&lt;T&gt; &amp; bs); public: OPTR(int size); ~OPTR(); void Push(T x); T Pop(); private: int Num1; T *data; int top; }; template &lt;typename T&gt; ostream &amp; operator&gt;(ostream &amp; os, OPTR&lt;T&gt; &amp; bs) { char zxh = bs.Pop(); char zxh2 = bs.Pop(); if (zxh == &#39;*&#39; || zxh == &#39;/&#39;) { os &lt;&lt; zxh; bs.Push(zxh2); } if (zxh == &#39;+&#39; || zxh == &#39;-&#39;) { if (zxh2 == &#39;*&#39; || zxh2 == &#39;/&#39;) { os &lt;&lt; zxh2; bs.Push(zxh); } else { os &lt;&lt; zxh; bs.Push(zxh2); } } } template &lt;typename T&gt; ostream &amp; operator&lt;&lt;(ostream &amp; os, OPTR&lt;T&gt; &amp; bs) { int i = bs.Num1; os &lt;&lt; bs.data[i-1]; return os; } template &lt;typename T&gt; OPTR&lt;T&gt;::OPTR(int size) { data = new T[size]; Num1 = size; top = -1; //data[0] = &#39;#&#39;; } template &lt;typename T&gt; OPTR&lt;T&gt;::~OPTR(){ delete[] data; } template &lt;typename T&gt; void OPTR&lt;T&gt;::Push(T x) { if (top == Num1 - 1)throw&quot;上溢&quot;; data[++top] = x; } template &lt;typename T&gt; T OPTR&lt;T&gt;::Pop() { if (top == -1)throw&quot;下溢&quot;; return data[top--];//此处要求弹出顶部元素来参与运算所以不能全部的弹出 } #endif #include&quot;OPND.h&quot; #include&quot;OPTR.h&quot; #include&lt;iostream&gt; using namespace std; int main() { int num; cout &lt;&lt; &quot;请输入您想运算的运算式中的数字的个数:&quot;; cin &gt;&gt; num; OPTR&lt;char&gt; tr(num); OPND&lt;int&gt; nd(num); char ch; int a[100]; char b[100]; char ch1=&#39;+&#39;; int sum; cout &lt;&lt; &quot;输入您要运算的一位的整数:&quot;;//上接INT sum for (int i = 0; i &lt; num; i++) { cin &gt;&gt; a[i]; nd.Push(a[i]); } cout &lt;&lt; &quot;请输入对应的运算符（以#号开始录入）:&quot;; for (int i = 0; i &lt; num ; i++) { cin &gt;&gt; b[i]; tr.Push(b[i]); } while (ch1!= &#39;#&#39;) { char zxh = tr.Pop(); char zxh2 = tr.Pop(); if (zxh == &#39;*&#39; || zxh == &#39;/&#39;) { ch = zxh; tr.Push(zxh2); ch1 = zxh2; } if (zxh == &#39;+&#39; || zxh == &#39;-&#39;) { if (zxh2 == &#39;*&#39; || zxh2 == &#39;/&#39;) { ch = zxh2; tr.Push(zxh); ch1 = zxh; } else { ch = zxh; tr.Push(zxh2); ch1 = zxh2; } } if (ch==&#39;+&#39;) sum = nd.Pop() + nd.Pop(); if (ch==&#39;-&#39;) sum = nd.Pop() - nd.Pop(); if (ch==&#39;*&#39;) sum = nd.Pop() * nd.Pop(); if (ch==&#39;/&#39;) sum = nd.Pop() / nd.Pop(); nd.Push(sum); } cout &lt;&lt; &quot;您要求的表达式的值为:&quot; &lt;&lt; sum &lt;&lt; endl; return 0; }","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"动态数组的申请与鞍点的测算","date":"2014-10-17T04:54:00.000Z","path":"zxh/20141017.html","text":"今天老师上课数据结构讲到了字符串和数组，字符串让我们用回溯法测算。后来叫我们做了一个动态数组的申请，加上算鞍点的算法。 下面是我的完整代码 #include&lt;iostream&gt; using namespace std; void main() { int *p; int m,n,i,j; cout&lt;&lt;&quot;请输入行:&quot;;cin&gt;&gt;m; cout&lt;&lt;&quot;请输入列:&quot;;cin&gt;&gt;n; p=new int[m*n]; for(int i=1;i&lt;=m*n;i++) p[i]=100+i; cout&lt;&lt;&quot;您创建的二维数组是:&quot;&lt;&lt;endl; for(i=1;i&lt;=m;i++) {for(j=1;j&lt;=n;j++) cout&lt;&lt;&quot; &quot;&lt;&lt;p[(i-1)*n+j]; cout&lt;&lt;endl;} for(i=1;i&lt;=m;i++) { int m1=0; int Min=p[(i-1)*n+1],Min1=p[(i-1)*n+1]; for(j=1;j&lt;=n;j++) {if(Min&lt;p[(i-1)*n+j]) m1=j;} for(j=1;j&lt;=m;j++) if(p[(j-1)*n+m1]&lt;p[(i-1)*n+m1]) break; if(j==5) {cout&lt;&lt;endl; cout&lt;&lt;&quot;鞍点:&quot;&lt;&lt;p[(i-1)*n+m1];break; } if(i==5) cout&lt;&lt;&quot;此矩阵不存在鞍点.&quot;;} } 在做这个程序的时候我遇到了几个问题和心得，下面我们就来分享一下1.在动态申请的时候我首先是用指针的，刚开始我把输入动态的数组的个数给忘了，最后在运行的时候系统报错的。在不断的调试中找到了这个低级的错误，从这件事情上我感觉到像我们这样的程序员在编写程序的时候范这样的低级错误也是不可避免的，在遇到这种情况的时候我们要淡定。我们要学会用调试找到我们的错误所在。2.就是在算鞍点的时候我有大意了，在循环的时候我没有设置全局的变量而是在for循环里了，导致我运行的时候不识别局部的变量i和j了。大概就是这几个方面。希望在以后能狗得到改变","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"数据结构心得","date":"2014-10-12T08:30:00.000Z","path":"zxh/20141012.html","text":"开学已经有一个月了，再在这一个月里我学习了数据结构， 听老师说迷宫问题是网上的热题。关于这两个问题，我还要在写实验报告。以后每次作业我争取每次都把刚开始入门的时候感觉很乱，学的也不会，到现在已经慢慢的摸索到一点了，数据结构比起之前我学的C++相比，数据结构更加的灵活，在数据结构中我们可以按照自己的想法编写但要求的是更强逻辑，而不像C++，C++里面是强行的逻辑是要让我们先了解C++才可以。而数据结构呢就是在我们自己的想法中来实现问题的算法。现在我学到了队列的出入队。今天编写了好长时间才勉强的会了。还记得上次编写遇到问题是在上学期的课程设计中， 编写了这么多的数据结构中是首先必须得有类，因为都是用类来实现的。然后就是类中的构造函数，没有一个构造函数那么最后在主函数中定义对象就无法实现了。子啊构造函数后面就是数据结构中的几个基本操作了，最主要的就是出和入。这两个函数我们有数组的方法还有指针的方法，个人觉得指针比较好，灵活多变。数组也叫顺序结构太死板了。就像我最近编写的几个程序一样，用顺序链接的方法就很麻烦。还有几个程序我用数组就无法编写，最后我编写的指针就可以实现问题。这部分写完之后我就要开始写下面的问题了。 综合实验：表达式求值+迷宫问题心得写在自己的技术博客上。","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"银行系统改编版","date":"2014-04-14T00:37:00.000Z","path":"zxh/20140414.html","text":"今天对银行系统进行了修改终于修改好了。下面是我今天忙了一大早的成果。大家看看吧。 #include&lt;iostream&gt; using namespace std; class Account { friend class CheckingAccount; protected: double balance; //账户余额 public: Account(double Balanc); void credit();//向当前余额加钱 int debit();//从账中取钱 int getBalance();//返回balance值 }; Account::Account(double Balance) { balance=Balance; } void Account::credit() { int save; cout&lt;&lt;&quot;您的银行可用余额为:&quot;&lt;&lt;balance&lt;&lt;endl; cout&lt;&lt;&quot;请输入您要存入的金额:&quot;&lt;&lt;endl; cin&gt;&gt;save; balance=balance+save; cout&lt;&lt;&quot;存入后的余额为:&quot;&lt;&lt;endl; cout&lt;&lt;balance&lt;&lt;endl; } int Account::debit() { int demand;int flag=1; cout&lt;&lt;&quot;请输入您要取出的金额:&quot;&lt;&lt;endl; cin&gt;&gt;demand; if(demand&gt;balance) {balance=balance; cout&lt;&lt;&quot;对不起！您的余额不足,请充值:&quot;&lt;&lt;endl; } else { balance=balance-demand; cout&lt;&lt;&quot;您已成功取出&quot;&lt;&lt;demand&lt;&lt;&quot;元现金&quot;&lt;&lt;endl; cout&lt;&lt;&quot;您的余额为&quot;&lt;&lt;getBalance()&lt;&lt;endl;; //cout&lt;&lt;&quot;您的余额为&quot;&lt;&lt;balance&lt;&lt;endl; flag=0;//表示钱已被取走 } return flag; } int Account::getBalance() { return balance; } class SavingAccount:public Account { friend class CheckingAccount;//下面的CheckingAccount中会用到//SavingAccount中的caclculateInterest private: //double balance; double interestrate;//账户的比例 public: SavingAccount(double Balance,double Interestrate); int caclculateInterest(); }; SavingAccount::SavingAccount(double Balance,double Interestrate):Account(Balance) { balance=balance; interestrate=Interestrate; //credit();//存 //debit();//取 } int SavingAccount::caclculateInterest() { double money; money=balance*interestrate; return money;//利息 } class CheckingAccount:public SavingAccount { private: double fare;//表示每笔的费用 public: CheckingAccount(double Balance,double Interestrate,double Fare); void rescredit(); int resdebit(); }; CheckingAccount::CheckingAccount(double Balance,double Interestrate,double Fare):SavingAccount(Balance,Interestrate) { balance=Balance; interestrate=Interestrate; fare=Fare; } /*void CheckingAccount::rescredit() { credit(); //caclculateInterest(); int save; cout&lt;&lt;&quot;请输入您要存入的金额:&quot;&lt;&lt;endl; cin&gt;&gt;save; balance=balance+save; }*/ int CheckingAccount::resdebit() {bool flag; //credit(); //debit(); if(debit()==0) { cout&lt;&lt;&quot;您已成功提出钱！:&quot;&lt;&lt;endl; balance=balance-fare; cout&lt;&lt;&quot;取钱收取费用!&quot;&lt;&lt;endl; cout&lt;&lt;&quot;收取的费用后余额产生的利息:&quot;&lt;&lt;caclculateInterest()&lt;&lt;endl; } else cout&lt;&lt;&quot;收费不成功:&quot;&lt;&lt;endl; return balance; } void main() { cout&lt;&lt;&quot;************欢迎您使用张新华银行系统************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; Account A1(100); A1.credit();A1.debit();A1.getBalance(); cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; SavingAccount S1(A1.getBalance(),0.2); S1.credit(); S1.debit(); S1.getBalance(); cout&lt;&lt;&quot;账户的利息:&quot;&lt;&lt;S1.caclculateInterest()&lt;&lt;endl; cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; CheckingAccount C1(S1.getBalance(),0.2,30); C1.credit(); //C1.debit(); cout&lt;&lt;&quot;收取费用后的余额:&quot;&lt;&lt;C1.resdebit(); }","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"C++学习想法","date":"2014-04-13T23:35:00.000Z","path":"zxh/20140414.html","text":"今天是周一，今天做早操的时候舍友说准备买一本C++基础的书。我觉得这样的想法很好，突然想到自己最近几天因为自己私人原因事情很忙，蛋这不能成为我不学C++的理由。所以我在这规划了我这一周的学习进程。首先我要完善我的学生管理系统。其次就是我要好好准备周三的C++课。我现在好准备在这个月结束前开始学习JAVA，不知道我能不能实现。现在我的C++学的都还不是很精通，就开始学习java不知道是不是好高骛远呢，希望大家看到我的这篇文章后可以来帮我解答一下我现在的疑惑。我现在就是那种老式讲的可以消化的了的。自己又想继续的往前前进的，但是我有怕我自己应付不了这么大的学习量的。","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"图书馆系统","date":"2014-04-11T13:44:00.000Z","path":"zxh/20140411.html","text":"这个是我们的开始题目。在清明的时候我仔细的想了想。我在家做了一下。下面就是我的源代码： #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;fstream&gt; #define N 1 using namespace std; class lab { private: char ISBN[20]; //图书号 char bookname[20]; char authorname[20]; char flno[20];//分类号 char department[20];//出版单位 char time[15]; float price; int count; public: void input(lab l[],int n); void output(lab l[],int n); void output1(lab l[],int n); void reeadfile(lab l[],int n); void showinfor(lab l[],int n); void saveinfor(lab l[],int n); void saveinfor1(lab l[],int n); void search(lab l[],int n); void search1(lab l[],int n); void search2(lab l[],int n); void search3(lab l[],int n); void search4(lab l[],int n); void search5(lab l[],int n); void search6(lab l[],int n); void search7(lab l[],int n); void delete1(lab l[],int n); }; void lab::input(lab l[],int n) { cout&lt;&lt;&quot;请输入您要录入的图书的信息(作者名 书名 出版单位 分类号 图书编号 价格 时间):&quot;&lt;&lt;endl; for(int i=0;i&lt;n;i++) cin&gt;&gt;l[i].authorname&gt;&gt;l[i].bookname&gt;&gt; l[i].department&gt;&gt;l[i].flno&gt;&gt;l[i].ISBN&gt;&gt;l[i].price&gt;&gt;l[i].time; } void lab::reeadfile(lab l[],int n) { ifstream f2; f2.open(&quot;d:\\\\图书馆信息库.txt&quot;); for(int i=0;i&lt;8;i++) f2&gt;&gt;l[i].authorname&gt;&gt;l[i].bookname&gt;&gt; l[i].department&gt;&gt;l[i].flno&gt;&gt;l[i].ISBN&gt;&gt;l[i].price&gt;&gt;l[i].time; } void lab::output1(lab l[],int n) { cout&lt;&lt;&quot;录入后的图书信息为:&quot;&lt;&lt;endl; for(int i=0;i&lt;N;i++) cout&lt;&lt;l[i].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[i].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[i].department&lt;&lt;&quot; &quot;&lt;&lt;l[i].flno&lt;&lt;&quot; &quot;&lt;&lt;l[i].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[i].price&lt;&lt;&quot; &quot;&lt;&lt;l[i].time; cout&lt;&lt;endl; } void lab::saveinfor1(lab l[],int n) { ofstream f3; f3.open(&quot;d:\\\\图书馆.txt&quot;); for(int i=0;i&lt;n;i++) { f3&lt;&lt;l[i].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[i].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[i].department&lt;&lt;&quot; &quot;&lt;&lt;l[i].flno&lt;&lt;&quot; &quot;&lt;&lt;l[i].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[i].price&lt;&lt;&quot; &quot;&lt;&lt;l[i].time; f3&lt;&lt;endl; } f3.close(); } void lab::saveinfor(lab l[],int n) { ofstream f1; f1.open(&quot;d:\\\\图书馆.txt&quot;); for(int i=0;i&lt;N+8;i++) { f1&lt;&lt;l[i].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[i].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[i].department&lt;&lt;&quot; &quot;&lt;&lt;l[i].flno&lt;&lt;&quot; &quot;&lt;&lt;l[i].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[i].price&lt;&lt;&quot; &quot;&lt;&lt;l[i].time; f1&lt;&lt;endl; } f1.close(); } void lab::output(lab l[],int n) { //cout&lt;&lt;&quot;您录入后的图书信息为:&quot;&lt;&lt;endl; for(int i=0;i&lt;N+8;i++) { cout&lt;&lt;l[i].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[i].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[i].department&lt;&lt;&quot; &quot;&lt;&lt;l[i].flno&lt;&lt;&quot; &quot;&lt;&lt;l[i].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[i].price&lt;&lt;&quot; &quot;&lt;&lt;l[i].time; cout&lt;&lt;endl; } } void lab::search1(lab l[],int n) { string t;int m=-1; cout&lt;&lt;&quot;请输入您要查询的作者名:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) { if(l[i].authorname==t) { m=i; cout&lt;&lt;l[m].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[m].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[m].department&lt;&lt;&quot; &quot;&lt;&lt;l[m].flno&lt;&lt;&quot; &quot;&lt;&lt;l[m].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[m].price&lt;&lt;&quot; &quot;&lt;&lt;l[m].time; cout&lt;&lt;endl;} } if(m==-1) cout&lt;&lt;&quot;抱歉！本图书馆暂未收录您所查询的图书:&quot;&lt;&lt;endl; } void lab::search2(lab l[],int n) { string t;int m=-1; cout&lt;&lt;&quot;请输入您要查询的书名:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) { if(l[i].bookname==t) { m=i; cout&lt;&lt;l[m].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[m].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[m].department&lt;&lt;&quot; &quot;&lt;&lt;l[m].flno&lt;&lt;&quot; &quot;&lt;&lt;l[m].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[m].price&lt;&lt;&quot; &quot;&lt;&lt;l[m].time; cout&lt;&lt;endl;} } if(m==-1) cout&lt;&lt;&quot;抱歉！本图书馆暂未收录您所查询的图书:&quot;&lt;&lt;endl; } void lab::search3(lab l[],int n) { string t;int m=-1; cout&lt;&lt;&quot;请输入您要查询的出版单位:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) { if(l[i].department==t) {m=i; cout&lt;&lt;l[m].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[m].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[m].department&lt;&lt;&quot; &quot;&lt;&lt;l[m].flno&lt;&lt;&quot; &quot;&lt;&lt;l[m].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[m].price&lt;&lt;&quot; &quot;&lt;&lt;l[m].time; cout&lt;&lt;endl;} } if(m==-1) cout&lt;&lt;&quot;抱歉！本图书馆暂未收录您所查询的图书:&quot;&lt;&lt;endl; } void lab::search4(lab l[],int n) { string t;int m=-1; cout&lt;&lt;&quot;请输入您要查询的分类号:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) { if(l[i].flno==t) { m=i; cout&lt;&lt;l[m].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[m].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[m].department&lt;&lt;&quot; &quot;&lt;&lt;l[m].flno&lt;&lt;&quot; &quot;&lt;&lt;l[m].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[m].price&lt;&lt;&quot; &quot;&lt;&lt;l[m].time; cout&lt;&lt;endl;} } if(m==-1) cout&lt;&lt;&quot;抱歉！本图书馆暂未收录您所查询的图书:&quot;&lt;&lt;endl; } void lab::search5(lab l[],int n) { string t;int m=-1; cout&lt;&lt;&quot;请输入您要查询的图书编号:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) { if(l[i].ISBN==t) { m=i; cout&lt;&lt;l[m].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[m].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[m].department&lt;&lt;&quot; &quot;&lt;&lt;l[m].flno&lt;&lt;&quot; &quot;&lt;&lt;l[m].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[m].price&lt;&lt;&quot; &quot;&lt;&lt;l[m].time; cout&lt;&lt;endl;} } if(m==-1) cout&lt;&lt;&quot;抱歉！本图书馆暂未收录您所查询的图书:&quot;&lt;&lt;endl; } void lab::search6(lab l[],int n) { int t;int m=-1; cout&lt;&lt;&quot;请输入您要查询的价格:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) if(l[i].price==t) {m=i; cout&lt;&lt;l[m].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[m].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[m].department&lt;&lt;&quot; &quot;&lt;&lt;l[m].flno&lt;&lt;&quot; &quot;&lt;&lt;l[m].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[m].price&lt;&lt;&quot; &quot;&lt;&lt;l[m].time; cout&lt;&lt;endl;} if(m==-1) cout&lt;&lt;&quot;抱歉！本图书馆暂未收录您所查询的图书:&quot;&lt;&lt;endl; } void lab::search7(lab l[],int n) { string t;int m=-1; cout&lt;&lt;&quot;请输入您要查询的时间:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) { if(l[i].time==t) { m=i; cout&lt;&lt;l[m].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[m].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[m].department&lt;&lt;&quot; &quot;&lt;&lt;l[m].flno&lt;&lt;&quot; &quot;&lt;&lt;l[m].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[m].price&lt;&lt;&quot; &quot;&lt;&lt;l[m].time; cout&lt;&lt;endl;} } if(m==-1) cout&lt;&lt;&quot;抱歉！本图书馆暂未收录您所查询的图书:&quot;&lt;&lt;endl; } void lab::search(lab l[],int n) { string t; int m,k; cout&lt;&lt;&quot;请输入您想通过查询的方式:&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1-作者名查询 2-书名查询 3-出版单位查询 4-分类号查询 5-图书编号查询 6-价格查询 7-时间查询&quot;&lt;&lt;endl; cin&gt;&gt;k; switch(k) { case 1:search1(l,N);break; case 2:search2(l,N);break; case 3:search3(l,N);break; case 4:search4(l,N);break; case 5:search5(l,N);break; case 6:search6(l,N);break; case 7:search7(l,N);break; } } void lab::delete1(lab l[],int n) { string t; char t1; int x=-1; cout&lt;&lt;&quot;请输入您认为无价值的书的名称:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;8;i++) if(l[i].bookname==t) {x=i; cout&lt;&lt;&quot;您要删除的图书的资料为:&quot;&lt;&lt;endl; cout&lt;&lt;l[x].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[x].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[x].department&lt;&lt;&quot; &quot;&lt;&lt;l[x].flno&lt;&lt;&quot; &quot;&lt;&lt;l[x].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[x].price&lt;&lt;&quot; &quot;&lt;&lt;l[x].time; cout&lt;&lt;&quot;Are you sure to delete the informatiom of the book(Y/N):&quot;&lt;&lt;endl; cin&gt;&gt;t1; if(t1==&#39;y&#39;||t1==&#39;Y&#39;) {for(int i=0;i&lt;x;i++) l[i]=l[i]; for(int i=x;i&lt;8;i++) l[i]=l[i+1]; cout&lt;&lt;&quot;删除后的信息为:&quot;&lt;&lt;endl; for(int i=0;i&lt;7;i++) { cout&lt;&lt;l[i].authorname&lt;&lt;&quot; &quot;&lt;&lt;l[i].bookname&lt;&lt;&quot; &quot;&lt;&lt; l[i].department&lt;&lt;&quot; &quot;&lt;&lt;l[i].flno&lt;&lt;&quot; &quot;&lt;&lt;l[i].ISBN&lt;&lt;&quot; &quot;&lt;&lt;l[i].price&lt;&lt;&quot; &quot;&lt;&lt;l[i].time; cout&lt;&lt;endl;} } else cout&lt;&lt;&quot;您放弃了删除该图书请认真保存该图书吧:&quot;&lt;&lt;endl; } if(x==-1) cout&lt;&lt;&quot;被系统内暂无无用的图书:&quot;&lt;&lt;endl; } void main() { lab l[N]; lab zxh; zxh.reeadfile(l,N);zxh.saveinfor(l,N); int k; cout&lt;&lt;&quot;********************淮阴师范学院图书馆欢迎您********************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1-图书信息的录入 2-图书信息的查询 3-图书信息的删除 4-退出系统&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入您要选择的功能的序号:&quot;&lt;&lt;endl; cin&gt;&gt;k; switch(k) { case 1:zxh.input(l,N);zxh.output1(l,N);zxh.output(l,N);break; case 2:zxh.search(l,8);break; case 3:zxh.delete1(l,8);break; case 4:cout&lt;&lt;&quot;********欢迎使用本系统！欢迎下次继续使用本系统********&quot;&lt;&lt;endl;break; } }","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"银行系统","date":"2014-04-11T13:42:00.000Z","path":"zxh/20140411.html","text":"昨天我们老师布置了我们的一个简单的银行系统。 刚一看到我一点想法都没有。我回去后仔细想了想用昨天的继承方法可以做的。首先我定义了第一个类Account作为父类、然后就是SavingAccount作为子类。再定义一个子类CheckingAccount.由于我做的时间不长而且最近比较忙可能没时间在改这个系统了。所以就将就把这个系统先放上来。我的程序的缺点是在运行每一个类的同时我多无法让银行账户的余额做到更新。下面是我的源代码： #include&lt;iostream&gt; using namespace std; class Account { friend class CheckingAccount; protected: double balance; //账户余额 public: Account(double Balance=100); void credit();//向当前余额加钱 int debit();//从账中取钱 int getBalance();//返回balance值 }; Account::Account(double Balance) { balance=Balance; } void Account::credit() { int save; cout&lt;&lt;&quot;您的银行可用余额为:&quot;&lt;&lt;balance&lt;&lt;endl; cout&lt;&lt;&quot;请输入您要存入的金额:&quot;&lt;&lt;endl; cin&gt;&gt;save; balance=balance+save; cout&lt;&lt;&quot;存入后的余额为:&quot;&lt;&lt;endl; cout&lt;&lt;balance&lt;&lt;endl; } int Account::debit() { int demand;int flag=1; cout&lt;&lt;&quot;请输入您要取出的金额:&quot;&lt;&lt;endl; cin&gt;&gt;demand; if(demand&gt;balance) {balance=balance; cout&lt;&lt;&quot;对不起！您的余额不足,请充值:&quot;&lt;&lt;endl; } else { balance=balance-demand; cout&lt;&lt;&quot;您已成功取出&quot;&lt;&lt;demand&lt;&lt;&quot;元现金&quot;&lt;&lt;endl; cout&lt;&lt;&quot;您的余额为&quot;&lt;&lt;getBalance()&lt;&lt;endl;; //cout&lt;&lt;&quot;您的余额为&quot;&lt;&lt;balance&lt;&lt;endl; flag=0;//表示钱已被取走 } return flag; } int Account::getBalance() { return balance; } class SavingAccount:public Account { friend class CheckingAccount; private: //double balance; double interestrate;//账户的比例 public: SavingAccount(double Balance=100,double Interestrate=0.2); int caclculateInterest(); }; SavingAccount::SavingAccount(double Balance,double Interestrate):Account(Balance) { getBalance(); balance=balance; interestrate=Interestrate; //credit();//存 //debit();//取 } int SavingAccount::caclculateInterest() { double money; money=balance*interestrate; return money;//利息 } class CheckingAccount:public SavingAccount { private: double fare;//表示每笔的费用 public: CheckingAccount(double Balance=100,double Interestrate=0.2,double Fare=30); void rescredit(); int resdebit(); }; CheckingAccount::CheckingAccount(double Balance,double Interestrate,double Fare):SavingAccount(Interestrate) { balance=Balance; interestrate=Interestrate; fare=Fare; } /*void CheckingAccount::rescredit() { credit(); //caclculateInterest(); int save; cout&lt;&lt;&quot;请输入您要存入的金额:&quot;&lt;&lt;endl; cin&gt;&gt;save; balance=balance+save; }*/ int CheckingAccount::resdebit() {bool flag; //credit(); //debit(); if(debit()==0) { cout&lt;&lt;&quot;您已成功提出钱！:&quot;&lt;&lt;endl; balance=balance-fare; } return balance; } void main() { cout&lt;&lt;&quot;************欢迎您使用张新华银行系统************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; Account A1; A1.credit();A1.debit();A1.getBalance(); cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; SavingAccount S1; S1.credit(); S1.debit(); S1.getBalance(); cout&lt;&lt;&quot;账户的利息:&quot;&lt;&lt;S1.caclculateInterest()&lt;&lt;endl; cout&lt;&lt;&quot;***********************************&quot;&lt;&lt;endl; CheckingAccount C1; C1.credit(); cout&lt;&lt;&quot;收取费用后的余额:&quot;&lt;&lt;C1.resdebit(); cout&lt;&lt;&quot;取钱收取费用!&quot;&lt;&lt;endl; cout&lt;&lt;&quot;收取的费用后余额产生的利息:&quot;&lt;&lt;C1.caclculateInterest()&lt;&lt;endl;; }","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"学生管理系统","date":"2014-04-11T13:31:00.000Z","path":"zxh/20140411.html","text":"我现在是大一新生！这个系统我写了一个月。 但是还是不是很好。但是我想着是我的第一个系统。我在写的时候发现我的删除功能不是很好的。还有就是在这个过程中我学会了再这里我学到了如何使用类中的函数的多个成员的方法。下面是我的源代码。 #include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;string&gt; #include&lt;fstream&gt; using namespace std; class score { friend class student; private: string no; string kcnum; //课程编号 string kcname; //课程名称 float kcxf; //课程学分 float ydxf; //应得学分 float pscj; //平时成绩 float sycj; //实验成绩 float jmcj; //卷面成绩 float zhcj; //综合成绩 public: friend void readfilescore(score s[],int &amp;num); friend void saveinforscore(score s[],int &amp;num); }; void readfilescore(score s[],int &amp;num) { ifstream f1; f1.open(&quot;d:\\\\学生管理系统.txt&quot;); int i=0; while(!f1.eof()) { f1&gt;&gt;s[i].no&gt;&gt;s[i].kcnum&gt;&gt;s[i].kcname&gt;&gt;s[i].kcxf&gt;&gt;s[i].ydxf &gt;&gt;s[i].pscj&gt;&gt;s[i].sycj&gt;&gt;s[i].jmcj&gt;&gt;s[i].zhcj; if(s[i].sycj==-1) s[i].zhcj=s[i].pscj*0.3+s[i].jmcj*0.7; else s[i].zhcj=s[i].pscj*0.15+s[i].sycj*0.15+s[i].jmcj*0.7; if(s[i].zhcj&gt;=60) s[i].ydxf=s[i].kcxf; else s[i].ydxf=0; i++; } num=i; f1.close(); } void saveinforscore(score s[],int &amp;num) { ofstream f2; f2.open(&quot;d:\\\\学生管理系统2.txt&quot;); for(int i=0;i&lt;num;i++) f2&lt;&lt;s[i].no&lt;&lt;s[i].kcnum&lt;&lt;s[i].kcname&lt;&lt;s[i].kcxf&lt;&lt;s[i].ydxf &lt;&lt;s[i].pscj&lt;&lt;s[i].sycj&lt;&lt;s[i].jmcj&lt;&lt;s[i].zhcj; f2.close(); } class student { string sno; //学生学号 string name; //学生姓名 string sex; //学生性别 string department;//宿舍 string phone; //联系方式 float score1; public: bool operator&lt;(student &amp;t); friend void readfile(student s2[],int &amp;num); friend void saveinfor(student s2[],int &amp;num); friend void delete1(student s1[],score s2[],int &amp;num1,int &amp;num2); friend void searchno(student s[],int &amp;num); friend void searchname(student s[],int &amp;num); friend void search(student s2[],int &amp;num); friend void sort(student s2[],int &amp;num); }; bool student::operator&lt;(student &amp;t) { if(score1&lt;t.score1) return true; else return false; } void readfile(student s2[],int &amp;num) { ifstream f2; f2.open(&quot;d:\\\\学生管理系统.txt&quot;); int i=0; while(!f2.eof()) { f2&gt;&gt;s2[i].sno&gt;&gt;s2[i].name&gt;&gt;s2[i].sex&gt;&gt;s2[i].department&gt;&gt;s2[i].phone; i++; } num=i; f2.close(); } void saveinfor(student s2[],int &amp;num) { ofstream f3; f3.open(&quot;d:\\\\学生管理系统2.txt&quot;); for(int i=0;i&lt;num;i++) f3&lt;&lt;s2[i].sno&lt;&lt;s2[i].name&lt;&lt;s2[i].sex&lt;&lt;s2[i].department&lt;&lt;s2[i].phone; f3.close(); } void delete1(student s1[],score s2[],int &amp;num1,int &amp;num2) { int x,y; string z; cout&lt;&lt;&quot;请输入您要删除的学生的学号:&quot;; cin&gt;&gt;z; for(int i=0;i&lt;num1;i++) if(z==s1[i].sno) { x=i;//break; for(i=x;i&lt;num1-1;i++) {s1[i]=s1[i+1]; s2[i]=s2[i+1]; } } } void searchno(student s[],int &amp;num) { string z; int x; cout&lt;&lt;&quot;请输入您要查询的学生的学号:&quot;&lt;&lt;endl; cin&gt;&gt;z; for(int i=0;i&lt;num;i++) if(z==s[i].sno) { x=i;break;} cout&lt;&lt;s[x].sno&lt;&lt;s[x].name&lt;&lt;s[x].sex&lt;&lt;s[x].department&lt;&lt;s[x].phone; } void searchname(student s[],int &amp;num) { string t; int x; cout&lt;&lt;&quot;请输入您要查询的学生的姓名:&quot;&lt;&lt;endl; cin&gt;&gt;t; for(int i=0;i&lt;num;i++) if(t==s[i].name) {x=i;break;} cout&lt;&lt;s[x].sno&lt;&lt;s[x].name&lt;&lt;s[x].sex&lt;&lt;s[x].department&lt;&lt;s[x].phone; } void search(student s2[],int &amp;num) { int a; string x,y,z; cout&lt;&lt;&quot;请选择您是选通过哪种方式查询信息:&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1-通过学号查询，2-通过姓名查询:&quot;&lt;&lt;endl; cin&gt;&gt;a; switch(a) { case 1:searchno(s2,num);break; case 2:searchname(s2,num);break; } } void main () { score s[10]; score s1; int num1=0; student ss[10]; student ss1; int num2=0; cout&lt;&lt;&quot;*************淮阴师范学院学生信息管理系统*************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1-学生信息录入 2-学生信息查询 3-学生信息的删除 4-学生信息的排序&quot;&lt;&lt;endl; int x; cout&lt;&lt;&quot;请输入您要选择的功能:&quot;&lt;&lt;endl; cin&gt;&gt;x; switch(x) { case 1:cout&lt;&lt;&quot;请输入学生信息（学号 成绩 性别 宿舍 联系方式等信息）:&quot;&lt;&lt;endl;readfilescore(s,num1);readfile(ss,num2);break; case 2:search(ss,num2);break; case 3:delete1(ss,s,num1,num2);break; //case 4:sort(ss,num2);break; case 5:cout&lt;&lt;&quot;退出系统！！！:&quot;&lt;&lt;endl; } }","tags":[{"name":"C++","slug":"C","permalink":"https://zxhtom.oschina.io/tags/C/"}]},{"title":"无题","date":"2014-01-09T07:44:00.000Z","path":"zxh/20140109.html","text":"还有两天就要考C++了。 现在发现学的终于可以得以只用了，在下面的考试中我会好好表线的。最近的c++学习中我发现学习初期我们要学会模仿。然后我们应该学会在模仿中来总计为出自己的一套思维。在模仿中我们也要注意到C++语言中的特有的格式。现在是我刚写的博客。所以我只有想到一点就写一点来了。呵呵！！","tags":[{"name":"感慨","slug":"感慨","permalink":"https://zxhtom.oschina.io/tags/感慨/"}]},{"title":"我的第一张博客","date":"2014-01-07T14:42:00.000Z","path":"zxh/20140107.html","text":"今天突然想到我还有博客没有写。 今天很高兴，因为我开始了自己人生的第一步的技术博客的写作。第一次我不知道该写什么好。所以在这里就随便写写自己的感想。我想自己以后可以做一个IT精英，在计算机领域里面我也可以做到家喻户晓。这样说当然有点夸张了啊。但是希望总是应该想的远大 一些的。对自己的人生规划也没有太大的规划。首先我得好好学好自己目前的C++。在C++里面我有自己的一套思维。我自己觉得我可以好好的学好这样科目。计算机中的计算机语言我也没有打算全部学完。我也就是想好好学好这个C++，然后再学好C++的语言的基础上我就可以自己和志同道合的人一起开通自己喜欢的软件。 现在的我还是大一，准备在大二里面好好学习。在大二的时候我就可以在网上接一些网上程序。这样既可以来满足自己经济上的需求，有可以利用自己的专业来实现自己的欲望。对大二的总的计划就是找几个有这方面倾向的人一起探讨C++软件开发的问题。这些人也将是我软件路上的小组人。我们以后就会在一起开发软件。第一次真心的不知道什么是技术博客。以后会改善的。","tags":[{"name":"感慨","slug":"感慨","permalink":"https://zxhtom.oschina.io/tags/感慨/"}]}]